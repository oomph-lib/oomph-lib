//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC// Copyright (C) 2006-2021 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header functions for classes that define Telements
#ifndef OOMPH_TELEMENT_HEADER
#define OOMPH_TELEMENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//oomph-lib headers
#include "Vector.h"
#include "shape.h"
#include "integral.h"
#include "elements.h"

namespace oomph
{



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//===================================================
/// Triangular Face class
//===================================================
 class TFace
 {
  
 public:
  
  /// Constructor: Pass in the three vertex nodes
  TFace(Node* node1_pt, Node* node2_pt, Node* node3_pt)
   {
    if ( (node1_pt==node2_pt) || (node2_pt==node3_pt) || (node1_pt==node3_pt) )
     {
#ifdef PARANOID
      std::ostringstream error_stream;
      error_stream << "TFace cannot have two identical vertex nodes\n";
      throw OomphLibError(
       error_stream.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
#endif
     }
    
    // Sort lexicographically based on pointer address of nodes
    std::set<Node*> nodes;
    nodes.insert(node1_pt);
    nodes.insert(node2_pt);
    nodes.insert(node3_pt);
    std::set<Node*>::iterator it=nodes.begin();
    Node1_pt=(*it);
    it++;
    Node2_pt=(*it);
    it++;
    Node3_pt=(*it);
    it++;
   }
  
  
  /// Access to the first vertex node
  Node* node1_pt() const {return Node1_pt;}
  
  /// Access to the second vertex node
  Node* node2_pt() const {return Node2_pt;}
  
  /// Access to the third vertex node
  Node* node3_pt() const {return Node3_pt;}
  
  /// Comparison operator
  bool operator==(const TFace& other) const
   {
    if ((Node1_pt==other.node1_pt())&&
        (Node2_pt==other.node2_pt())&&
        (Node3_pt==other.node3_pt()))     
     {
       return true;
     }
    else
     {
      return false;
     }
   }
  
  
  
  /// Less-than operator
  bool operator<(const TFace& other) const
   {
    if (Node1_pt<other.node1_pt())
     {
      return true;
     }
    else if (Node1_pt==other.node1_pt())
     {
      if (Node2_pt<other.node2_pt())
       {
        return true;
       }
      else if (Node2_pt==other.node2_pt())
       {
        if (Node3_pt<other.node3_pt())
         {
          return true;
         }
        else
         {
          return false;
         }
       }
      else
       {
        return false;
       }
     }    
    else
     {
      return false;
     }
   }


  /// \short Test whether the face lies on a boundary. Relatively simple
  /// test, based on all vertices lying on (some) boundary.
  bool is_on_boundary()  const
  {
   return (Node1_pt->is_on_boundary() && 
           Node2_pt->is_on_boundary() &&
           Node3_pt->is_on_boundary() );
  }
  

  /// \short Test whether the face is a boundary face, i.e. does it
  /// connnect three boundary nodes?
  bool is_boundary_face()  const
  {
   return ((dynamic_cast<BoundaryNodeBase*>(Node1_pt)!=0)&&
           (dynamic_cast<BoundaryNodeBase*>(Node2_pt)!=0)&&
           (dynamic_cast<BoundaryNodeBase*>(Node3_pt)!=0));
  }
  
  /// \short Access to pointer to set of mesh boundaries that this 
  /// face occupies; NULL if the node is not on any boundary.
  /// Construct via set intersection of the boundary sets for the
  /// associated vertex nodes
  void get_boundaries_pt(std::set<unsigned>* &boundaries_pt) 
   {
    std::set<unsigned> set1;
    std::set<unsigned>* set1_pt=&set1;
    Node1_pt->get_boundaries_pt(set1_pt);
    std::set<unsigned> set2;
    std::set<unsigned>* set2_pt=&set2;
    Node2_pt->get_boundaries_pt(set2_pt);
    std::set<unsigned> set3;
    std::set<unsigned>* set3_pt=&set3;
    Node3_pt->get_boundaries_pt(set3_pt);
    std::set<unsigned> aux_set;
    set_intersection((*set1_pt).begin(),(*set1_pt).end(),
                     (*set2_pt).begin(),(*set2_pt).end(),
                     inserter(aux_set, aux_set.begin())); 
    set_intersection(aux_set.begin(),aux_set.end(),
                     (*set3_pt).begin(),(*set3_pt).end(),
                     inserter((*boundaries_pt), (*boundaries_pt).begin())); 
   }


 private:
  
  /// First vertex node
  Node* Node1_pt;
  
  /// Second vertex node
  Node* Node2_pt;

  /// Third vertex node
  Node* Node3_pt;

 };
 


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////




//========================================================================
/// A class for those member functions that must be fully specialised
/// for the Telements. The fact that member functions of partially
/// specialised classes cannot necessarily be fully specialised 
/// means that we must either fully specialise every class, or use this
/// base class to fully specialize only those functions that are required.
//========================================================================
template<unsigned DIM, unsigned NNODE_1D>
 class TElementShape { };

/////////////////////////////////////////////////////////////////////////
/// TElementShape inline functions:
/////////////////////////////////////////////////////////////////////////
template<>
 class TElementShape<1,2>
 {
   public:

//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(1);
    switch (j)
     {
     case 0:
      s[0]=0.0;
      break;
      
     case 1:
      s[0]=1.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has two nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<1,2>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
   {
    psi[0] = 1.0 - s[0];
    psi[1] = s[0];
   }
  

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,2>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
    this->shape(s, psi);
    
    // Derivatives
    dpsids(0,0) = -1.0;
    dpsids(1,0) = 1.0;
   }
  
  
//=======================================================================
/// Second derivatives of shape functions for specific TElement<1,2>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    this->dshape_local(s, psi,dpsids);

    d2psids(0,0) = 0.0;
    d2psids(1,0) = 0.0;
   }
 };


template<>
 class TElementShape<1,3>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(1);
    switch (j)
     {
     case 0:
      s[0]=0.0;
      break;
      
     case 1:
      s[0]=0.5;
      break;
      
     case 2:
      s[0]=1.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message 
       << "Element only has three nodes; called with node number " 
       << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<1,3>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
{
 psi[0] = 2.0*(s[0] - 1.0)*(s[0]-0.5);
 psi[1] = 4.0*(1.0-s[0])*s[0];
 psi[2] = 2.0*(s[0] -  0.5)*s[0];
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<1,3>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);

 dpsids(0,0) = 4.0*s[0] - 3.0;
 dpsids(1,0) = 4.0 - 8.0*s[0];
 dpsids(2,0) = 4.0*s[0] - 1.0;
}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<1,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    //ALH: Don't know why object qualifier is needed
    this->dshape_local(s, psi,dpsids);
    
    d2psids(0,0) = 4.0;
    d2psids(1,0) = -8.0;
    d2psids(2,0) = 4.0;
   }

 };

template<>
 class TElementShape<1,4>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(1);
    switch (j)
  {
  case 0:
   s[0]=0.0;
   break;

  case 1:
   s[0]=(1.0/3.0);
   break;

  case 2:
   s[0]=(2.0/3.0);
   break;

  case 3:
   s[0]=1.0;
   break;

  default:
   std::ostringstream error_message;
   error_message << "Element only has four nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }
}


//=======================================================================
/// Shape function for specific TElement<1,4>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
{
 psi[0] = 0.5*(1.0 - s[0])*(3.0*s[0] -2.0)*(3.0*s[0] - 1.0);
 psi[1] = -4.5*s[0]*(1.0-s[0])*(3.0*s[0] - 2.0);
 psi[2] =  4.5*s[0]*(1.0-s[0])*(3.0*s[0] - 1.0);
 psi[3] = 0.5*s[0]*(3.0*s[0] -2.0)*(3.0*s[0] - 1.0);
}

//=======================================================================
/// Derivatives of shape functions for specific TElement<1,4>
//=======================================================================
 void dshape_local(const Vector<double> &s,
                   Shape &psi, DShape &dpsids) const
{
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 dpsids(0,0) = -13.5*s[0]*s[0] + 18.0*s[0] - 5.5;
 dpsids(1,0) = 40.5*s[0]*s[0] - 45.0*s[0] + 9.0;
 dpsids(2,0) = -40.5*s[0]*s[0] + 36.0*s[0] - 4.5;
 dpsids(3,0) = 13.5*s[0]*s[0] - 9.0*s[0] + 1.0;
}

//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,4>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
//=======================================================================
void d2shape_local(const Vector<double> &s,
                   Shape &psi,
                   DShape &dpsids,
                   DShape &d2psids) const
{
 throw OomphLibError("Not checked yet",
                     OOMPH_CURRENT_FUNCTION,
                     OOMPH_EXCEPTION_LOCATION);

 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);
 
 d2psids(0,0) = 0.0;
 d2psids(1,0) = 0.0;
 d2psids(2,0) = 0.0;
 d2psids(3,0) = 0.0;
}
};




template<>
 class TElementShape<2,2>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(2);

    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has three nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<2,2>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
   {
    psi[0] = s[0];
    psi[1] = s[1];
    psi[2] = 1.0-s[0]-s[1];
   }
  

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,2>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
    this->shape(s, psi);
    
    // Derivatives
    dpsids(0,0) = 1.0;
    dpsids(0,1) = 0.0;
    dpsids(1,0) = 0.0;
    dpsids(1,1) = 1.0;
    dpsids(2,0) = -1.0;
    dpsids(2,1) = -1.0;
   }
  
  
//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,2>:
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    this->dshape_local(s, psi,dpsids);
    
    for(unsigned i=0;i<3;i++)
     {
      d2psids(i,0) = 0.0;
      d2psids(i,1) = 0.0;
      d2psids(i,2) = 0.0;
     }
   }
 };

template<>
 class TElementShape<2,3>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(2);

    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     case 3:
      s[0]=0.5;
      s[1]=0.5;
      break;
      
     case 4:
      s[0]=0.0;
      s[1]=0.5;
      break;
      
     case 5:
      s[0]=0.5;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has six nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<2,3>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
{
 // Reconstruct the third area coordinate
 double s_2=1.0-s[0]-s[1];

 // note that s[2] needs replacing by s_2 everywhere since only 
 // two independent variables s[0],s[1] and s_2 is expressed in terms of those
 // later.
 psi[0] = 2.0*s[0]*(s[0]-0.5);
 psi[1] = 2.0*s[1]*(s[1]-0.5);
 psi[2] = 2.0*s_2 *(s_2 -0.5);
 psi[3] = 4.0*s[0]*s[1];
 psi[4] = 4.0*s[1]*s_2;
 psi[5] = 4.0*s_2*s[0];
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<2,3>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);

 dpsids(0,0) = 4.0*s[0]-1.0;
 dpsids(0,1) = 0.0;
 dpsids(1,0) = 0.0;
 dpsids(1,1) = 4.0*s[1]-1.0;
 dpsids(2,0) = 2.0*(2.0*s[0]-1.5+2.0*s[1]);
 dpsids(2,1) = 2.0*(2.0*s[0]-1.5+2.0*s[1]);
 dpsids(3,0) = 4.0*s[1];
 dpsids(3,1) = 4.0*s[0];
 dpsids(4,0) = -4.0*s[1];
 dpsids(4,1) = 4.0*(1.0-s[0]-2.0*s[1]);
 dpsids(5,0) = 4.0*(1.0-2.0*s[0]-s[1]);
 dpsids(5,1) = -4.0*s[0];
}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    //ALH: Don't know why object qualifier is needed
    this->dshape_local(s, psi,dpsids);
    
    d2psids(0,0) = 4.0;
    d2psids(0,1) = 0.0;
    d2psids(0,2) = 0.0;
    
    d2psids(1,0) = 0.0;
    d2psids(1,1) = 4.0;
    d2psids(1,2) = 0.0;
    
    d2psids(2,0) = 4.0;
    d2psids(2,1) = 4.0;
    d2psids(2,2) = 4.0;

    d2psids(3,0) = 0.0;
    d2psids(3,1) = 0.0;
    d2psids(3,2) = 4.0;
    
    d2psids(4,0) = 0.0;
    d2psids(4,1) = -8.0;
    d2psids(4,2) = -4.0;
    
    d2psids(5,0) = -8.0;
    d2psids(5,1) = 0.0;
    d2psids(5,2) = -4.0;
   }
  
 };

template<>
 class TElementShape<2,4>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(2);

    switch (j)
  {
  case 0:
   s[0]=1.0;
   s[1]=0.0;
   break;

  case 1:
   s[0]=0.0;
   s[1]=1.0;
   break;

  case 2:
   s[0]=0.0;
   s[1]=0.0;
   break;

  case 3:
   s[0]=2.0/3.0;
   s[1]=1.0/3.0;
   break;

  case 4:
   s[0]=1.0/3.0;
   s[1]=2.0/3.0;
   break;

  case 5:
   s[0]=0.0;
   s[1]=2.0/3.0;
   break;

  case 6:
   s[0]=0.0;
   s[1]=1.0/3.0;
   break;

  case 8:
   s[0]=2.0/3.0;
   s[1]=0.0;
   break;

  case 7:
   s[0]=1.0/3.0;
   s[1]=0.0;
   break;

  case 9:
   s[0]=1.0/3.0;
   s[1]=1.0/3.0;
   break;

  default:
   std::ostringstream error_message;
   error_message << "Element only has ten nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }
}


//=======================================================================
/// Shape function for specific TElement<2,4>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
{
 psi[0] = 0.5*s[0]*(3.0*s[0]-2.0)*(3.0*s[0]-1.0);
 psi[1] = 0.5*s[1]*(3.0*s[1]-2.0)*(3.0*s[1]-1.0);
 psi[2] = 0.5*(1.0-s[0]-s[1])*(1.0-3.0*s[0]-3.0*s[1])*(2.0-3.0*s[0]-3.0*s[1]);
 psi[3] = 4.5*s[0]*s[1]*(3.0*s[0]-1.0);
 psi[4] = 4.5*s[0]*s[1]*(3.0*s[1]-1.0);
 psi[5] = 4.5*s[1]*(1.0-s[0]-s[1])*(3.0*s[1]-1.0);
 psi[6] = 4.5*s[1]*(1.0-s[0]-s[1])*(3.0*(1.0-s[0]-s[1])-1.0);
 psi[7] = 4.5*s[0]*(1.0-s[0]-s[1])*(2.0-3*s[0]-3*s[1]);
 psi[8] = 4.5*s[0]*(1.0-s[0]-s[1])*(3.0*s[0]-1.0);
 psi[9] = 27.0*s[0]*s[1]*(1.0-s[0]-s[1]);
}

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,4>
//=======================================================================
 void dshape_local(const Vector<double> &s,
                   Shape &psi, DShape &dpsids) const
{
  
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 dpsids(0,0) = 13.5*s[0]*s[0]-9.0*s[0]+1.0;
 dpsids(0,1) = 0.0;
 dpsids(1,0) = 0.0;
 dpsids(1,1) = 13.5*s[1]*s[1]-9.0*s[1]+1.0;
 dpsids(2,0) = 0.5*(36.0*s[0]+36.0*s[1]-27.0*s[0]*s[0]-
                    27.0*s[1]*s[1]-54.0*s[0]*s[1]-11.0);
 dpsids(2,1) = 0.5*(36.0*s[0]+36.0*s[1]-27.0*s[0]*s[0]-
                    27.0*s[1]*s[1]-54.0*s[0]*s[1]-11.0);
 dpsids(3,0) = 27.0*s[0]*s[1]-4.5*s[1];
 dpsids(3,1) = 4.5*s[0]*(3.0*s[0]-1.0);
 dpsids(4,0) = 4.5*s[1]*(3.0*s[1]-1.0);
 dpsids(4,1) = 27.0*s[0]*s[1]-4.5*s[0];
 dpsids(5,0) = 4.5*(s[1]-3.0*s[1]*s[1]);
 dpsids(5,1) = 4.5*(s[0]-6.0*s[0]*s[1]-9.0*s[1]*s[1]+8*s[1]-1.0);
 dpsids(6,0) = 4.5*(6.0*s[0]*s[1]-5.0*s[1]+6.0*s[1]*s[1]);
 dpsids(6,1) = 4.5*(2.0-5.0*s[0]+3.0*s[0]*s[0]+12.0*s[0]*s[1]-
                    10.0*s[1]+9.0*s[1]*s[1]);
 dpsids(7,0) = 4.5*(2.0-10.0*s[0]+9.0*s[0]*s[0]+12.0*s[0]*s[1]-
                    5.0*s[1]+3.0*s[1]*s[1]);
 dpsids(7,1) = 4.5*(6.0*s[0]*s[0]-5.0*s[0]+6.0*s[0]*s[1]);
 dpsids(8,0) = 4.5*(s[1]-6.0*s[0]*s[1]-9.0*s[0]*s[0]+8*s[0]-1.0);
 dpsids(8,1) = 4.5*(s[0]-3.0*s[0]*s[0]);
 dpsids(9,0) = 27.0*s[1]-54.0*s[0]*s[1]-27.0*s[1]*s[1];
 dpsids(9,1) = 27.0*s[0]-54.0*s[0]*s[1]-27.0*s[0]*s[0];
 
}

//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,4>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
//=======================================================================
void d2shape_local(const Vector<double> &s,
                   Shape &psi,
                   DShape &dpsids,
                   DShape &d2psids) const
{
 throw OomphLibError("Not checked yet",
                     OOMPH_CURRENT_FUNCTION,
                     OOMPH_EXCEPTION_LOCATION);

 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);
 
 d2psids(0,0) = 9.0*(3.0*s[0]-1.0);
 d2psids(0,1) = 0.0;
 d2psids(0,2) = 0.0;
 d2psids(1,0) = 0.0;
 d2psids(1,1) = 0.0;
 d2psids(1,2) = 9.0*(3.0*s[1]-1.0);
 d2psids(2,0) = 9.0*(2.0-3.0*s[0]-3.0*s[1]);
 d2psids(2,1) = 9.0*(2.0-3.0*s[0]-3.0*s[1]);
 d2psids(2,2) = 9.0*(2.0-3.0*s[0]-3.0*s[1]);
 d2psids(3,0) = 27.0*s[1];
 d2psids(3,1) = 0.0;
 d2psids(3,2) = 27.0*s[0]-4.5;
 d2psids(4,0) = 0.0;
 d2psids(4,1) = 27.0*s[0];
 d2psids(4,2) = 27.0*s[1]-4.5;
 d2psids(5,0) = 0.0;
 d2psids(5,1) = 9.0*(4.0-3.0*s[0]-9.0*s[1]);
 d2psids(5,2) = 4.5*(1.0-6.0*s[1]);
 d2psids(6,0) = 27.0*s[1];
 d2psids(6,1) = 9.0*(6.0*s[0]+9.0*s[1]-5.0);
 d2psids(6,2) = 4.5*(6.0*s[0]+12.0*s[1]-5.0);
 d2psids(8,0) = 9.0*(4.0-9.0*s[0]-3.0*s[1]);
 d2psids(8,1) = 0.0;
 d2psids(8,2) = 4.5*(1.0-6.0*s[0]);
 d2psids(7,0) = 9.0*(9.0*s[0]+6.0*s[1]-5.0);
 d2psids(7,1) = 27.0*s[0];
 d2psids(7,2) = 4.5*(12.0*s[0]+6.0*s[1]-5.0);
 d2psids(9,0) = -54.0*s[1];
 d2psids(9,1) = -54.0*s[0];
 d2psids(9,2) = 27.0-54.0*s[0]-54.0*s[1];
}
};



//========================================================================
/// A class for those member functions that must be fully specialised
/// for Telements that are enriched by bubbble functions. 
/// The fact that member functions of partially
/// specialised classes cannot necessarily be fully specialised 
/// means that we must either fully specialise every class, or use this
/// base class to fully specialize only those functions that are required.
//========================================================================
template<unsigned DIM, unsigned NNODE_1D>
 class TBubbleEnrichedElementShape { };


///////////////////////////////////////////////////////////////////////
/// Specific Enriched TElementShape inline functions
//////////////////////////////////////////////////////////////////////

//===============================================================
///Standard quadratic shape functions enriched by the addition
///of a cubic bubble, which consists of adding a single node
///at the centroid
//=============================================================
template<>
 class TBubbleEnrichedElementShape<2,3>
 {
   public:

  //=====================================================================
  /// Return the number of nodes required for enrichement
  //====================================================================
  unsigned n_enriched_nodes() {return 1;}
  
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
   {
    s.resize(2);

    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     case 3:
      s[0]=0.5;
      s[1]=0.5;
      break;
      
     case 4:
      s[0]=0.0;
      s[1]=0.5;
      break;
      
     case 5:
      s[0]=0.5;
      s[1]=0.0;
      break;
     
      //Add the centroid as the enriched node
     case 6:
      s[0] = 1.0/3.0;
      s[1] = 1.0/3.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << 
       "Element only has seven nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TBubbleEnrichedElement<2,3>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
{
 // Reconstruct the third area coordinate
 const double s_2=1.0-s[0]-s[1];

 //Calculate the enrichment function
 const double cubic_bubble = s[0]*s[1]*s_2;
 //The appropriate amount of the cubic bubble function is 
 //added/subtracted to each original quadratic shape function to ensure that
 //it is zero at the centroid (1/3,1/3).

 // note that s[2] needs replacing by s_2 everywhere since only 
 // two independent variables s[0],s[1] and s_2 is expressed in terms of those
 // later.
 psi[0] = 2.0*s[0]*(s[0]-0.5) + 3.0*cubic_bubble;
 psi[1] = 2.0*s[1]*(s[1]-0.5) + 3.0*cubic_bubble;
 psi[2] = 2.0*s_2 *(s_2 -0.5) + 3.0*cubic_bubble;
 psi[3] = 4.0*s[0]*s[1] - 12.0*cubic_bubble;
 psi[4] = 4.0*s[1]*s_2  - 12.0*cubic_bubble;
 psi[5] = 4.0*s_2*s[0]  - 12.0*cubic_bubble;
 //The bubble function scaled to have magnitude one at (1/3,1/3)
 psi[6] = 27.0*cubic_bubble;
}


//=======================================================================
/// Derivatives of shape functions for specific TBubbleElement<2,3>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 //Calculate derivatives of bubble functions
 const double d_bubble_ds0 = s[1]*(1.0 - s[1] - 2.0*s[0]);
 const double d_bubble_ds1 = s[0]*(1.0 - s[0] - 2.0*s[1]);

 //Add the appropriate derivatives to the shape functions
 dpsids(0,0) = 4.0*s[0]-1.0 + 3.0*d_bubble_ds0;
 dpsids(0,1) = 0.0 + 3.0*d_bubble_ds1;
 dpsids(1,0) = 0.0 + 3.0*d_bubble_ds0;
 dpsids(1,1) = 4.0*s[1]-1.0 + 3.0*d_bubble_ds1;
 dpsids(2,0) = 2.0*(2.0*s[0]-1.5+2.0*s[1]) + 3.0*d_bubble_ds0;
 dpsids(2,1) = 2.0*(2.0*s[0]-1.5+2.0*s[1]) + 3.0*d_bubble_ds1;
 dpsids(3,0) = 4.0*s[1] - 12.0*d_bubble_ds0;
 dpsids(3,1) = 4.0*s[0] - 12.0*d_bubble_ds1;
 dpsids(4,0) = -4.0*s[1] - 12.0*d_bubble_ds0;
 dpsids(4,1) = 4.0*(1.0-s[0]-2.0*s[1]) - 12.0*d_bubble_ds1;
 dpsids(5,0) = 4.0*(1.0-2.0*s[0]-s[1]) - 12.0*d_bubble_ds0;
 dpsids(5,1) = -4.0*s[0] - 12.0*d_bubble_ds1;
 dpsids(6,0) = 27.0*d_bubble_ds0;
 dpsids(6,1) = 27.0*d_bubble_ds1;
}


//=======================================================================
/// Second derivatives of shape functions for specific 
/// TBubbleElement<2,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    //ALH: Don't know why object qualifier is needed
    this->dshape_local(s, psi,dpsids);
    
    //Calculate derivatives of bubble functions
    const double d2_bubble_ds0 = -2.0*s[1];
    const double d2_bubble_ds1 = -2.0*s[0];
    const double d2_bubble_ds2 = 1.0 - 2.0*s[0] - 2.0*s[1];

    d2psids(0,0) = 4.0 + 3.0*d2_bubble_ds0;
    d2psids(0,1) = 0.0 + 3.0*d2_bubble_ds1;
    d2psids(0,2) = 0.0 + 3.0*d2_bubble_ds2;
    
    d2psids(1,0) = 0.0 + 3.0*d2_bubble_ds0;
    d2psids(1,1) = 4.0 + 3.0*d2_bubble_ds1;
    d2psids(1,2) = 0.0 + 3.0*d2_bubble_ds2;
    
    d2psids(2,0) = 4.0 + 3.0*d2_bubble_ds0;
    d2psids(2,1) = 4.0 + 3.0*d2_bubble_ds1;
    d2psids(2,2) = 4.0 + 3.0*d2_bubble_ds2;

    d2psids(3,0) = 0.0 - 12.0*d2_bubble_ds0;
    d2psids(3,1) = 0.0 - 12.0*d2_bubble_ds1;
    d2psids(3,2) = 4.0 - 12.0*d2_bubble_ds2;
    
    d2psids(4,0) = 0.0 - 12.0*d2_bubble_ds0;
    d2psids(4,1) = -8.0 - 12.0*d2_bubble_ds1;
    d2psids(4,2) = -4.0 - 12.0*d2_bubble_ds2;
    
    d2psids(5,0) = -8.0 - 12.0*d2_bubble_ds0;
    d2psids(5,1) = 0.0 - 12.0*d2_bubble_ds1;
    d2psids(5,2) = -4.0 - 12.0*d2_bubble_ds2;

    d2psids(6,0) = 27.0*d2_bubble_ds0;
    d2psids(6,1) = 27.0*d2_bubble_ds1;
    d2psids(6,2) = 27.0*d2_bubble_ds2;
   }
  
 };

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//========================================================================
/// Empty base class for Telements (created so that 
/// we can use dynamic_cast<>() to figure out if a an element
/// is a Telement (from a purely geometric point of view).
//========================================================================
 class TElementGeometricBase : public virtual FiniteElement
{

  public:

 /// Empty default constructor
 TElementGeometricBase(){} 

 /// Broken copy constructor
 TElementGeometricBase(const TElementGeometricBase&) 
  { 
   BrokenCopy::broken_copy("TElementGeometricBase");
  } 
 
 /// Broken assignment operator
//Commented out broken assignment operator because this can lead to a conflict warning
//when used in the virtual inheritence hierarchy. Essentially the compiler doesn't
//realise that two separate implementations of the broken function are the same and so,
//quite rightly, it shouts.
 /*void operator=(const TElementGeometricBase&) 
  {
   BrokenCopy::broken_assign("TElementGeometricBase");
   }*/


};


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//========================================================================
/// Empty base class for Telements (created so that 
/// we can use dynamic_cast<>() to figure out if a an element
/// is a Telement).
//========================================================================
 class TElementBase : public virtual TElementGeometricBase
{

  public:

 /// Empty default constructor
 TElementBase(){} 

 /// Broken copy constructor
 TElementBase(const TElementBase&) 
  { 
   BrokenCopy::broken_copy("TElementBase");
  } 
 
 /// Broken assignment operator
 /*void operator=(const TElementBase&) 
  {
   BrokenCopy::broken_assign("TElementBase");
   }*/

 /// It's a T element!
 ElementGeometry::ElementGeometry element_geometry() const
 {
  return ElementGeometry::T;
 }

 ///Check whether the local coordinates are valid or not
 bool local_coord_is_valid(const Vector<double> &s) 
  {

   // Check coordinates
   unsigned ncoord=dim();
   double sum=0.0;   
   for (unsigned i=0;i<ncoord;i++)
    {
     //Each local coordinate must be positive
     if (s[i]<0.0)
      {
       return false;
      }
     sum+=s[i];
    }
   
   //Sum must be less than 1
   if (sum<=1.0)
    {
     return true;
    }
   
   // We're outside...
   return false;

  }
 
 /// \short Adjust local coordinates so that they're located inside
 /// the element
 void move_local_coord_back_into_element(Vector<double> &s) const
 {
   // Check coordinates
   unsigned ncoord=dim();
   double sum=0.0;
   for (unsigned i=0;i<ncoord;i++)
    {
     //Each coordinate must be positive individually
     if (s[i]<0.0) s[i]=0.0;
     sum+=s[i];
    }
   
   //Sum must be less than 1
   double excess=sum-1.0;
   if (excess>0.0)
    {
     // Subtract excess equally from all coordinates
     double sub=excess/double(ncoord);
     for (unsigned i=0;i<ncoord;i++)
      {
       s[i]-=sub;
      }
    }
   

  }

};

//=======================================================================
///General TElement class
///
/// Empty, just establishes the template parameters
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class TElement 
{
};			 


//=======================================================================
/// General TElement class specialised to one spatial dimensions
/// Ordering of nodes is 0 at local coordinate s[0] = 0, 1 at local 
/// coordinate s[0] = 1 and then filling in the intermediate values
/// from s[0]=0 to 1. 
//=======================================================================
template<unsigned NNODE_1D>
class TElement<1,NNODE_1D> : public virtual TElementBase, 
 public TElementShape<1,NNODE_1D>
{
  private:
  
 /// \short Default integration rule: Gaussian integration of same 'order' as 
 /// the element
 //This is sort of optimal, because it means that the integration is exact
 //for the shape functions. Can overwrite this in specific element defintion.
 static TGauss<1,NNODE_1D> Default_integration_scheme;
  
public:
 
 /// Constructor
 TElement()
  {
   // Number of nodes
   switch (NNODE_1D)
    {
    case 2:
    case 3:
    case 4:
     break;

    default:
     std::string error_message =
      "One-dimensional TElements are currently only implemented for\n";
     error_message +=
      "three and six nodes, i.e. NNODE_1D=2 , 3 , 4\n";
     
     throw OomphLibError(error_message,
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Set the number of nodes
   unsigned n_node = NNODE_1D;
   this->set_n_node(n_node);

   // Set the elemental and nodal dimension
   set_dimension(1);

   //Assign default (full) spatial integration scheme
   set_integration_scheme(&Default_integration_scheme);
  }
 

 /// Broken copy constructor
 TElement(const TElement&) 
  { 
   BrokenCopy::broken_copy("TElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const TElement&) 
  {
   BrokenCopy::broken_assign("TElement");
   }*/


 /// Destructor
 ~TElement() {}
 
 /// Number of nodes along each element edge
 unsigned nnode_1d() const {return NNODE_1D;} 


 /// \short Number of vertex nodes in the element: One more
 /// than spatial dimension
 unsigned nvertex_node() const {return 2;}
 
 /// \short Pointer to the j-th vertex node in the element
 Node* vertex_node_pt(const unsigned& j) const
  {
   switch (j)
    {
    case 0:

     return node_pt(0);
     break;

    case 1:

     return node_pt(NNODE_1D-1);
     break;

    default:
     
     std::ostringstream error_message;
     error_message 
      << "Element only has two vertex nodes; called with node number " 
      << j << std::endl;     
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
  }

 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {TElementShape<1,NNODE_1D>::shape(s,psi);}
 
 /// \short Compute the  geometric shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {TElementShape<1,NNODE_1D>::dshape_local(s,psi,dpsids);}

 /// \short Compute the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s 
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
 inline void d2shape_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {TElementShape<1,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);}

 /// \short Overload the template-free interface for the calculation of
 /// inverse jacobian matrix. This is a one dimensional element, so use
 /// the 1D version.
 double invert_jacobian_mapping(const DenseMatrix<double> &jacobian,
                                DenseMatrix<double>&inverse_jacobian) const
  {return FiniteElement::invert_jacobian<1>(jacobian,inverse_jacobian);}
  
 /// Min. value of local coordinate
 double s_min() const {return 0.0;}

 /// Max. value of local coordinate
 double s_max() const {return 1.0;}

 /// Return local coordinates of node j
 inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s) const
  {TElementShape<1,NNODE_1D>::local_coordinate_of_node(j,s);}

 /// \short Return the number of actual plot points for paraview
 /// plot with parameter nplot.
 unsigned nplot_points_paraview(const unsigned& nplot) const
  {
   return nplot;
  }
 
 /// \short Return the number of local sub-elements for paraview plot with 
 /// parameter nplot.
 unsigned nsub_elements_paraview(const unsigned& nplot) const 
  {
   return (nplot-1);   
  }

 /// \short Fill in the offset information for paraview plot.
 /// Needs to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_output_offset_information(std::ofstream& file_out,
                                               const unsigned& nplot,
                                               unsigned& counter) const
  {
   // Number of local elements we want to plot over
   unsigned plot=nsub_elements_paraview(nplot);
   
   // loops over the i-th local element in parent element
   for(unsigned i=0;i<plot;i++)
    {
     file_out << i+counter << " "
              << i+1+counter 
              << std::endl;
    }
   counter+=nplot_points_paraview(nplot);
  }

 /// \short Return the paraview element type.
 /// Needs to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_type(std::ofstream& file_out,
                          const unsigned& nplot) const
  {
   unsigned local_loop=nsub_elements_paraview(nplot);
   for(unsigned i=0;i<local_loop;i++)
    {
     file_out << "3" << std::endl;
    }
  }
 
 /// \short Return the offsets for the paraview sub-elements. Needs 
 /// to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_offsets(std::ofstream& file_out,
                             const unsigned& nplot, 
                             unsigned& offset_sum) const
  {
   // Loop over all local elements and add its offset to the overall offset_sum
   unsigned local_loop=nsub_elements_paraview(nplot);
   for(unsigned i=0;i<local_loop;i++)
    {
     offset_sum+=2;
     file_out << offset_sum << std::endl;
    }
  }

  /// Output
  void output(std::ostream &output);

  /// Output at specified number of plot points
  void output(std::ostream &outfile, const unsigned &nplot);

 /// C-style output 
 void output(FILE* file_pt);

 /// C_style output at n_plot points
 void output(FILE* file_pt, const unsigned &n_plot);

 /// \short  Get vector of local coordinates of plot point i (when plotting 
 /// nplot points in each "coordinate direction").
 void get_s_plot(
  const unsigned& i, 
  const unsigned& nplot,
  Vector<double>& s,
  const bool& use_equally_spaced_interior_sample_points=false) const 
 {
   if (nplot>1)
    {
     s[0] = double(i)/double(nplot-1);

     if (use_equally_spaced_interior_sample_points)
      {
       double range=1.0;
       double dx_new=range/double(nplot);
       double range_new=double(nplot-1)*dx_new;
       s[0]=0.5*dx_new+range_new*s[0]/range;
      }
    }
   else
    {
     s[0]=0.5;
    }
  }
 
 /// \short Return string for tecplot zone header (when plotting 
 /// nplot points in each "coordinate direction)
 std::string tecplot_zone_string(const unsigned& nplot) const
 {
  std::ostringstream header;
  header << "ZONE I=" << nplot << "\n";
  return header.str();
 }
 
 /// Return total number of plot points (when plotting 
 /// nplot points in each "coordinate direction)
 unsigned nplot_points(const unsigned& nplot) const
  {return nplot;}

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// PointElement).  The face index takes two values
 /// corresponding to the two possible faces:
 /// -1 (Left)  s[0] = -1.0
 /// +1 (Right) s[0] =  1.0
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);

};


//=======================================================================
/// General TElement class specialised to two spatial dimensions
/// Ordering of nodes as in Zienkiwizc sketches: vertex nodes
/// 0 - 1 - 2 anticlockwise. Midside nodes filled in progressing
/// along the consecutive edges. Central node(s) come(s) last.
//=======================================================================
template<unsigned NNODE_1D>
class TElement<2,NNODE_1D> : public virtual TElementBase, 
 public TElementShape<2,NNODE_1D>
{
  private:

 /// Nodal translation scheme for use when generating face elements
 static const unsigned Node_on_face[3][NNODE_1D];
 
 /// \short Default integration rule: Gaussian integration of same 'order' as 
 /// the element
 //This is sort of optimal, because it means that the integration is exact
 //for the shape functions. Can overwrite this in specific element defintion.
 static TGauss<2,NNODE_1D> Default_integration_scheme;
 
 
public:
 
 /// Constructor
 TElement()
  {
   // Number of nodes
   switch (NNODE_1D)
    {
    case 2:
    case 3:
    case 4:
     break;

    default:
     std::string error_message =
      "Triangles are currently only implemented for\n";
     error_message +=
      "three and six nodes, i.e. NNODE_1D=2 , 3 , 4\n";
     
     throw OomphLibError(error_message,
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Set the number of nodes
   unsigned n_node = (NNODE_1D*(NNODE_1D+1))/2;
   this->set_n_node(n_node);

   // Set the elemental and nodal dimension
   set_dimension(2);

   //Assign default (full) spatial integration scheme
   set_integration_scheme(&Default_integration_scheme);
  }

 /// Alternative constructor
 TElement(const bool &allow_high_order)
  {
   // Check if we are overriding the restriction on NNODE_1D
   if(!allow_high_order)
    {
     // Call the default constructor
     TElement<2,NNODE_1D>();
    }
   else
    {
     // Set the number of nodes
     unsigned n_node = (NNODE_1D*(NNODE_1D+1))/2;
     this->set_n_node(n_node);

     // Set the elemental and nodal dimension
     set_dimension(2);

     //Assign default (full) spatial integration scheme
     set_integration_scheme(&Default_integration_scheme);
    }
  }
 

 /// Broken copy constructor
 TElement(const TElement&) 
  { 
   BrokenCopy::broken_copy("TElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const TElement&) 
  {
   BrokenCopy::broken_assign("TElement");
   }*/


 /// Destructor
 ~TElement() {}
 
 /// Number of nodes along each element edge
 unsigned nnode_1d() const {return NNODE_1D;} 

 /// \short Number of vertex nodes in the element: One more
 /// than spatial dimension
 unsigned nvertex_node() const {return 3;}

 /// \short Public access function for Node_on_face.
 unsigned get_bulk_node_number(const int& face_index,
                               const unsigned& i) const
 {
  return Node_on_face[face_index][i];
 }
 
 /// \short Pointer to the j-th vertex node in the element
 Node* vertex_node_pt(const unsigned& j) const
  {
   // Vertex nodes come first:
#ifdef PARANOID
   if (j>2)
    {
     std::ostringstream error_message;
     error_message 
      << "Element only has three vertex nodes; called with node number " 
      << j << std::endl;     
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return node_pt(j);
  }

 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {TElementShape<2,NNODE_1D>::shape(s,psi);}
 
 /// \short Compute the  geometric shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {TElementShape<2,NNODE_1D>::dshape_local(s,psi,dpsids);}

 /// \short Compute the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s 
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
 inline void d2shape_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {TElementShape<2,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);}

 /// \short Overload the template-free interface for the calculation of
 /// inverse jacobian matrix. This is a two dimensional element, so use
 /// the 2D version.
 double invert_jacobian_mapping(const DenseMatrix<double> &jacobian,
                                DenseMatrix<double>&inverse_jacobian) const
  {return FiniteElement::invert_jacobian<2>(jacobian,inverse_jacobian);}
  
 /// Min. value of local coordinate
 double s_min() const {return 0.0;}

 /// Max. value of local coordinate
 double s_max() const {return 1.0;}

 /// Return local coordinates of node j
 inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s) const
  {TElementShape<2,NNODE_1D>::local_coordinate_of_node(j,s);}

 /// \short Return the number of actual plot points for paraview
 /// plot with parameter nplot.
 unsigned nplot_points_paraview(const unsigned& nplot) const 
  {
   unsigned node_sum=0;
   for(unsigned i=1;i<=nplot;i++) {node_sum+=i;}
   return node_sum;
  } 
 
 /// \short Return the number of local sub-elements for paraview plot with 
 /// parameter nplot.
 unsigned nsub_elements_paraview(const unsigned& nplot) const
  {
   unsigned local_sum=0;
   for(unsigned i=1;i<nplot;i++) {local_sum+=2*(nplot-i-1)+1;}
   return local_sum;
  }

 /// \short Fill in the offset information for paraview plot.
 /// Needs to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_output_offset_information(std::ofstream& file_out,
                                               const unsigned& nplot,
                                               unsigned& counter) const
  {

   // Outputs list of connectivity of Paraview elements, 
   // whilst remembering the overall ordering 

   unsigned node_count=0;
   for(unsigned i=0;i<nplot-1;i++)
    {
     for(unsigned j=0;j<nplot-i-1;j++)
      {
       file_out << j+node_count+counter<< " "
                << j+node_count+1+counter << " "
                << j+nplot+node_count-i+counter << std::endl;

       if(j<nplot-i-2)
        {
         file_out << j+node_count+1+counter << " "
                  << j+nplot+node_count-i+1+counter << " "
                  << j+nplot+node_count-i+counter << std::endl;
        }
      }
     node_count+=(nplot-i);
    }
   counter+=nplot_points_paraview(nplot);
  }

 /// \short Return the paraview element type.
 /// Needs to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_type(std::ofstream& file_out,
                          const unsigned& nplot) const
  {
   unsigned local_loop=nsub_elements_paraview(nplot);

   // Loop over all the local elements and print its paraview type
   for(unsigned i=0;i<local_loop;i++)
    {
     file_out << "5" << std::endl;
    }
  }

 /// \short Return the offsets for the paraview sub-elements. Needs 
 /// to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_offsets(std::ofstream& file_out,
                             const unsigned& nplot,
                             unsigned& offset_sum) const
  {
   unsigned local_loop=nsub_elements_paraview(nplot);

   // Loop over all local elements and add its offset to the overall offset_sum
   for(unsigned i=0;i<local_loop;i++)
    {
     offset_sum+=3;
     file_out << offset_sum << std::endl;
    }
  }

  /// Output
  void output(std::ostream &output);

  /// Output at specified number of plot points
  void output(std::ostream &outfile, const unsigned &nplot);

 /// C-style output 
 void output(FILE* file_pt);

 /// C_style output at n_plot points
 void output(FILE* file_pt, const unsigned &n_plot);

 /// \short  Get vector of local coordinates of plot point i (when plotting 
 /// nplot points in each "coordinate direction").
 void get_s_plot(
  const unsigned& iplot, 
  const unsigned& nplot,
  Vector<double>& s,
  const bool& use_equally_spaced_interior_sample_points=false) const
 {
   if (nplot>1)
    {
     unsigned np=0,i,j;
     for(i=0;i<nplot;++i)
      {
       for(j=0;j<nplot-i;++j)
        {
         if(np==iplot)
          {
           s[0] = double(j)/double(nplot-1);
           s[1] = double(i)/double(nplot-1);
           if (use_equally_spaced_interior_sample_points)
            {
             double range=1.0;
             double dx_new=range/(double(nplot)+0.5);
             double range_new=double(nplot-1)*dx_new;
             s[0]=0.5*dx_new+range_new*s[0]/range;
             s[1]=0.5*dx_new+range_new*s[1]/range;
            }
           return;
          }
         ++np;
        }
      }
    }
   else
    {
     s[0] = 1.0/3.0;
     s[1] = 1.0/3.0;
    }
  }
 
 /// \short Return string for tecplot zone header (when plotting 
 /// nplot points in each "coordinate direction)
 std::string tecplot_zone_string(const unsigned& nplot) const
 {
  std::ostringstream header;
  unsigned nel=0;
  for (unsigned i=1;i<nplot;i++) {nel+=2*i-1;}  
  header << "ZONE N=" << nplot_points(nplot) << ", E=" 
         << nel << ", F=FEPOINT, ET=TRIANGLE\n";
  return header.str();
 }

 /// \short Add tecplot zone "footer" to output stream (when plotting 
 /// nplot points in each "coordinate direction).
 /// Empty by default -- can be used, e.g., to add FE connectivity
 /// lists to elements that need it.
 void write_tecplot_zone_footer(std::ostream& outfile, 
                                const unsigned& nplot) const
  {
   //Output node lists for sub elements for Tecplot (node index 
   //must start at 1)
   unsigned nod_count=1;
   for(unsigned i=0;i<nplot;i++)
    {
     for(unsigned j=0;j<nplot-i;j++)
      {
       if(j<nplot-i-1)
        {
         outfile << nod_count << " " << nod_count+1 
                 << " " << nod_count+nplot-i << std::endl;
         if(j<nplot-i-2)
          {
           outfile << nod_count+1 << " " 
                   << nod_count+nplot-i+1 << " " 
                   << nod_count+nplot-i << std::endl;
          }
        }
       ++nod_count;
      }
    }
  }
 
 /// \short Add tecplot zone "footer" to C-style output. (when plotting 
 /// nplot points in each "coordinate direction).
 /// Empty by default -- can be used, e.g., to add FE connectivity
 /// lists to elements that need it.
 void write_tecplot_zone_footer(FILE* file_pt,
                                const unsigned& nplot) const
  {
   //Output node lists for sub elements for Tecplot (node index 
   //must start at 1)
   unsigned nod_count=1;
   for(unsigned i=0;i<nplot;i++)
    {
     for(unsigned j=0;j<nplot-i;j++)
      {
       if(j<nplot-i-1)
        {
         fprintf(file_pt,"%i %i %i \n",nod_count,nod_count+1,
                 nod_count+nplot-i);
         if(j<nplot-i-2)
          {
           fprintf(file_pt,"%i %i %i \n",nod_count+1,nod_count+nplot-i+1,
                   nod_count+nplot-i);
          }
        }
       ++nod_count;
      }
    }
  }
 
 /// Return total number of plot points (when plotting 
 /// nplot points in each "coordinate direction)
 unsigned nplot_points(const unsigned& nplot) const
  {
   unsigned np=0;
   for (unsigned i=1;i<=nplot;i++) {np+=i;}
   return np;
  }


 /// \short Build the lower-dimensional FaceElement (an element of type
 /// TElement<1,NNODE_1D>). The face index takes three possible values:
 /// 0 (Left)         s[0] = 0.0
 /// 1 (Bottom)       s[1] = 0.0
 /// 2 (Sloping face) s[0] = 1.0 - s[1]
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);


};


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=======================================================================
/// Return local coordinates of node j
//=======================================================================
template<>
class TElementShape<3,2>
{
  public:
 void local_coordinate_of_node(const unsigned& j,
                               Vector<double>& s) const
  {
   s.resize(3);

   switch (j)
    {
    case 0:
     s[0]=1.0;
     s[1]=0.0;
     s[2]=0.0;
     break;
     
    case 1:
     s[0]=0.0;
     s[1]=1.0;
     s[2]=0.0;
     break;
     
    case 2:
     s[0]=0.0;
     s[1]=0.0;
     s[2]=1.0;
     break;
     
    case 3:
     s[0]=0.0;
     s[1]=0.0;
     s[2]=0.0;
     break;
     
    default:
     std::ostringstream error_message;
     error_message << "Element only has four nodes; called with node number " 
                   << j << std::endl;
     
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
  }



//=======================================================================
/// Shape function for specific TElement<3,2>
//=======================================================================
 void shape(const Vector<double> &s, Shape &psi) const
  {
   psi[0] = s[0];
   psi[1] = s[1];
   psi[2] = s[2];
   psi[3] = 1.0-s[0]-s[1]-s[2];
  }


//=======================================================================
/// Derivatives of shape functions for specific TElement<3,2>
//=======================================================================
 void dshape_local(const Vector<double> &s,
                   Shape &psi, DShape &dpsids) const
  {
   //ALH: Don't know why object qualifier is needed
   this->shape(s, psi);
   
   // Derivatives
   dpsids(0,0) = 1.0;
 dpsids(0,1) = 0.0;
 dpsids(0,2) = 0.0;

 dpsids(1,0) = 0.0;
 dpsids(1,1) = 1.0;
 dpsids(1,2) = 0.0;

 dpsids(2,0) = 0.0;
 dpsids(2,1) = 0.0;
 dpsids(2,2) = 1.0;

 dpsids(3,0) = -1.0;
 dpsids(3,1) = -1.0;
 dpsids(3,2) = -1.0;
}



//=======================================================================
/// Second derivatives of shape functions for specific TElement<3,2>: 
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ 
/// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
/// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ 
/// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ 
//=======================================================================
 void d2shape_local(const Vector<double> &s,
                    Shape &psi,
                                         DShape &dpsids,
                                         DShape &d2psids) const
{
 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);

 for(unsigned i=0;i<4;i++)
  {
   d2psids(i,0) = 0.0;
   d2psids(i,1) = 0.0;
   d2psids(i,2) = 0.0;
   d2psids(i,3) = 0.0;
   d2psids(i,4) = 0.0;
   d2psids(i,5) = 0.0;
  }
}

};



//=======================================================================
/// Return local coordinates of node j
//=======================================================================
template<>
 class TElementShape<3,3>
 {
   public:
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
{
 s.resize(3);

 switch (j)
  {
  case 0:
   s[0]=1.0;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 1:
   s[0]=0.0;
   s[1]=1.0;
   s[2]=0.0;
   break;

  case 2:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=1.0;
   break;

  case 3:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 4:
   s[0]=0.5;
   s[1]=0.5;
   s[2]=0.0;
   break;

  case 5:
   s[0]=0.5;
   s[1]=0.0;
   s[2]=0.5;
   break;

  case 6:
   s[0]=0.5;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 7:
   s[0]=0.0;
   s[1]=0.5;
   s[2]=0.5;
   break;

  case 8:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=0.5;
   break;

  case 9:
   s[0]=0.0;
   s[1]=0.5;
   s[2]=0.0;
   break;

  default:
   std::ostringstream error_message;
   error_message << "Element only has ten nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }
}



//=======================================================================
/// Shape function for specific TElement<3,3>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
{
 double s3=1.0-s[0]-s[1]-s[2];
 psi[0] = (2.0*s[0]-1.0)*s[0];
 psi[1] = (2.0*s[1]-1.0)*s[1];
 psi[2] = (2.0*s[2]-1.0)*s[2];
 psi[3] = (2.0*s3-1.0)*s3;
 psi[4] = 4.0*s[0]*s[1];
 psi[5] = 4.0*s[0]*s[2];
 psi[6] = 4.0*s[0]*s3;
 psi[7] = 4.0*s[1]*s[2];
 psi[8] = 4.0*s[2]*s3;
 psi[9] = 4.0*s[1]*s3;
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<3,3>
//=======================================================================
void dshape_local(const Vector<double> &s,
                  Shape &psi, DShape &dpsids) const
{
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 // Derivatives
 double s3=1.0-s[0]-s[1]-s[2];

 dpsids(0,0) = 4.0*s[0]-1.0;
 dpsids(0,1) = 0.0;
 dpsids(0,2) = 0.0;

 dpsids(1,0) = 0.0;
 dpsids(1,1) = 4.0*s[1]-1.0;
 dpsids(1,2) = 0.0;

 dpsids(2,0) = 0.0;
 dpsids(2,1) = 0.0;
 dpsids(2,2) = 4.0*s[2]-1.0;

 dpsids(3,0) = -4.0*s3+1.0;
 dpsids(3,1) = -4.0*s3+1.0;
 dpsids(3,2) = -4.0*s3+1.0;

 dpsids(4,0) = 4.0*s[1];
 dpsids(4,1) = 4.0*s[0];
 dpsids(4,2) = 0.0;

 dpsids(5,0) = 4.0*s[2];
 dpsids(5,1) = 0.0;
 dpsids(5,2) = 4.0*s[0];

 dpsids(6,0) = 4.0*(s3-s[0]);
 dpsids(6,1) = -4.0*s[0];
 dpsids(6,2) = -4.0*s[0];

 dpsids(7,0) = 0.0;
 dpsids(7,1) = 4.0*s[2];
 dpsids(7,2) = 4.0*s[1];

 dpsids(8,0) = -4.0*s[2];
 dpsids(8,1) = -4.0*s[2];
 dpsids(8,2) = 4.0*(s3-s[2]);

 dpsids(9,0) = -4.0*s[1];
 dpsids(9,1) = 4.0*(s3-s[1]);
 dpsids(9,2) = -4.0*s[1];


}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<3,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ 
/// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
/// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ 
/// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ 
//=======================================================================
void d2shape_local(const Vector<double> &s,
                                         Shape &psi,
                                         DShape &dpsids,
                                         DShape &d2psids) const
{
 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);

 //(.,3) for mixed derivative s[0]-s[1]
 //(.,4) for mixed derivative s[0]-s[2]
 //(.,5) for mixed derivative s[1]-s[2]

 d2psids(0,0) = 4.0;
 d2psids(0,1) = 0.0;
 d2psids(0,2) = 0.0;
 d2psids(0,3) = 0.0;
 d2psids(0,4) = 0.0;
 d2psids(0,5) = 0.0;


 d2psids(1,0) = 0.0;
 d2psids(1,1) = 4.0;
 d2psids(1,2) = 0.0;
 d2psids(1,3) = 0.0;
 d2psids(1,4) = 0.0;
 d2psids(1,5) = 0.0;

 d2psids(2,0) = 0.0;
 d2psids(2,1) = 0.0;
 d2psids(2,2) = 4.0;
 d2psids(2,3) = 0.0;
 d2psids(2,4) = 0.0;
 d2psids(2,5) = 0.0;

 d2psids(3,0) = 4.0;
 d2psids(3,1) = 4.0;
 d2psids(3,2) = 4.0;
 d2psids(3,3) = 4.0;
 d2psids(3,4) = 4.0;
 d2psids(3,5) = 4.0;

 d2psids(4,0) = 0.0;
 d2psids(4,1) = 0.0;
 d2psids(4,2) = 0.0;
 d2psids(4,3) = 4.0;
 d2psids(4,4) = 0.0;
 d2psids(4,5) = 0.0;

 d2psids(5,0) = 0.0;
 d2psids(5,1) = 0.0;
 d2psids(5,2) = 0.0;
 d2psids(5,3) = 0.0;
 d2psids(5,4) = 4.0;
 d2psids(5,5) = 0.0;

 d2psids(6,0) =-8.0;
 d2psids(6,1) = 0.0;
 d2psids(6,2) = 0.0;
 d2psids(6,3) = -4.0;
 d2psids(6,4) = -4.0;
 d2psids(6,5) = 0.0;

 d2psids(7,0) = 0.0;
 d2psids(7,1) = 0.0;
 d2psids(7,2) = 0.0;
 d2psids(7,3) = 0.0;
 d2psids(7,4) = 0.0;
 d2psids(7,5) = 4.0;

 d2psids(8,0) = 0.0;
 d2psids(8,1) = 0.0;
 d2psids(8,2) = -8.0;
 d2psids(8,3) = 0.0;
 d2psids(8,4) = -4.0;
 d2psids(8,5) = -4.0;

 d2psids(9,0) = 0.0;
 d2psids(9,1) = -8.0;
 d2psids(9,2) = 0.0;
 d2psids(9,3) = -4.0;
 d2psids(9,4) = 0.0;
 d2psids(9,5) = -4.0;

}


};

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//====================================================================
///Standard quadratic shape functions enriched by the addition of 
///three cubic "face" bubbles and quartic "volume" bubble, 
///which consists of adding a node at the centroid of
///each face and a single node at the centroid
///of the tetrahedron
//=========================================================================

//=======================================================================
/// Return local coordinates of node j
//=======================================================================
template<>
 class TBubbleEnrichedElementShape<3,3>
 {
   public:
  
  unsigned n_enriched_nodes() {return 5;}

  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s) const
{
 s.resize(3);

 switch (j)
  {
  case 0:
   s[0]=1.0;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 1:
   s[0]=0.0;
   s[1]=1.0;
   s[2]=0.0;
   break;

  case 2:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=1.0;
   break;

  case 3:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 4:
   s[0]=0.5;
   s[1]=0.5;
   s[2]=0.0;
   break;

  case 5:
   s[0]=0.5;
   s[1]=0.0;
   s[2]=0.5;
   break;

  case 6:
   s[0]=0.5;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 7:
   s[0]=0.0;
   s[1]=0.5;
   s[2]=0.5;
   break;

  case 8:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=0.5;
   break;

  case 9:
   s[0]=0.0;
   s[1]=0.5;
   s[2]=0.0;
   break;

   //Node at centroid of face spanned by nodes 0, 1, 3
  case 10:
   s[0]=1.0/3.0;
   s[1]=1.0/3.0;
   s[2]=0.0;
   break;

   //Node at centroid of face spanned by nodes 0, 1, 2
  case 11:
   s[0]=1.0/3.0;
   s[1]=1.0/3.0;
   s[2]=1.0/3.0;
   break;

   //Node at centroid of face spanned by nodes 0, 2, 3
  case 12:
   s[0]=1.0/3.0;
   s[1]=0.0;
   s[2]=1.0/3.0;
   break;
   
   //Node at centroid of face spannd by nodes 1, 2, 3
  case 13:
   s[0]=0.0;
   s[1]=1.0/3.0;
   s[2]=1.0/3.0;
   break;
   
   //Node at centroid of volume
  case 14:
   s[0] = 0.25;
   s[1] = 0.25;
   s[2] = 0.25;
   break;


  default:
   std::ostringstream error_message;
   error_message << "Element only has fifteen nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }
}



//=======================================================================
/// Shape function for specific TBubbleEnrichedElement<3,3>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
 {
  //Constructe the fourth volume coordinate
  const double s3=1.0-s[0]-s[1]-s[2];
  //calculate the enrichment functions
  const double quartic_bubble = s[0]*s[1]*s[2]*s3;
  const double cubic_bubble012 = s[0]*s[1]*s[2];
  const double cubic_bubble013 = s[0]*s[1]*s3;
  const double cubic_bubble023 = s[0]*s[2]*s3;
  const double cubic_bubble123 = s[1]*s[2]*s3;

  //The appropriate "amount" of cubic and quartic bubble functions are
  //added/subtracted
  //to each original quadratic shape function to ensure that the new 
  //shape function is zero at the centroid (0.25,0.25,0.25)
  //and at the face centroids
  psi[0] = (2.0*s[0]-1.0)*s[0]   
   + 3.0*(cubic_bubble012 + cubic_bubble013 + cubic_bubble023)
   - 4.0*quartic_bubble;
  psi[1] = (2.0*s[1]-1.0)*s[1]   
   + 3.0*(cubic_bubble012 + cubic_bubble013 + cubic_bubble123)
   - 4.0*quartic_bubble;
  psi[2] = (2.0*s[2]-1.0)*s[2]   
   + 3.0*(cubic_bubble012 + cubic_bubble023 + cubic_bubble123)
   - 4.0*quartic_bubble;
  psi[3] = (2.0*s3-1.0)*s3       
   + 3.0*(cubic_bubble013 + cubic_bubble023 + cubic_bubble123)
   -4.0*quartic_bubble;
  psi[4] = 4.0*s[0]*s[1] 
   - 12.0*(cubic_bubble012 + cubic_bubble013)
   + 32.0*quartic_bubble;
  psi[5] = 4.0*s[0]*s[2] 
   - 12.0*(cubic_bubble012 + cubic_bubble023)
   + 32.0*quartic_bubble;
  psi[6] = 4.0*s[0]*s3   
   - 12.0*(cubic_bubble013 + cubic_bubble023)
   + 32.0*quartic_bubble;
  psi[7] = 4.0*s[1]*s[2] 
   - 12.0*(cubic_bubble012 + cubic_bubble123)
   + 32.0*quartic_bubble;
  psi[8] = 4.0*s[2]*s3   
   - 12.0*(cubic_bubble023 + cubic_bubble123)
   + 32.0*quartic_bubble;
  psi[9] = 4.0*s[1]*s3   
   - 12.0*(cubic_bubble013 + cubic_bubble123)
   + 32.0*quartic_bubble;
  //Add the bubble function on the face spanned by 0 1 3
  psi[10] = 27.0*cubic_bubble013 - 108.0*quartic_bubble;
  //Add the bubble function on the face spanned by 0 1 2
  psi[11] = 27.0*cubic_bubble012 - 108.0*quartic_bubble;
  //Add the bubble function on the face spanned by 0 2 3
  psi[12] = 27.0*cubic_bubble023 - 108.0*quartic_bubble;
  //Add the bubble function on the face spanned by 1 2 3
  psi[13] = 27.0*cubic_bubble123 - 108.0*quartic_bubble;
  //Add the volume bubble function, scaled to have value one
  psi[14] = 256.0*quartic_bubble;
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<3,3>
//=======================================================================
void dshape_local(const Vector<double> &s,
                  Shape &psi, DShape &dpsids) const
{
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);

 //Define s3 the fourth volume coordinate
 const double s3=1.0-s[0]-s[1]-s[2]; 

 //Calculate derivatives of the bubble function
 const double d_quartic_bubble_ds0 = s[1]*s[2]*(1.0 - s[1] - s[2] - 2.0*s[0]);
 const double d_quartic_bubble_ds1 = s[0]*s[2]*(1.0 - s[0] - s[2] - 2.0*s[1]);
 const double d_quartic_bubble_ds2 = s[0]*s[1]*(1.0 - s[0] - s[1] - 2.0*s[2]);

 const double d_cubic_bubble012_ds0 = s[1]*s[2];
 const double d_cubic_bubble012_ds1 = s[0]*s[2];
 const double d_cubic_bubble012_ds2 = s[0]*s[1];

 const double d_cubic_bubble013_ds0 = s[1]*(s3 - s[0]);
 const double d_cubic_bubble013_ds1 = s[0]*(s3 - s[1]);
 const double d_cubic_bubble013_ds2 = -s[0]*s[1];

 const double d_cubic_bubble023_ds0 = s[2]*(s3 - s[0]);
 const double d_cubic_bubble023_ds1 = -s[0]*s[2]; 
 const double d_cubic_bubble023_ds2 = s[0]*(s3 - s[2]);

 const double d_cubic_bubble123_ds0 = -s[1]*s[2];
 const double d_cubic_bubble123_ds1 = s[2]*(s3 - s[1]);
 const double d_cubic_bubble123_ds2 = s[1]*(s3 - s[2]);


 //Add the appropriate dervatives of the bubble function to the
 //shape function derivatives
 dpsids(0,0) = 4.0*s[0]-1.0 
  + 3.0*(d_cubic_bubble012_ds0 + d_cubic_bubble013_ds0 + d_cubic_bubble023_ds0)
  - 4.0*d_quartic_bubble_ds0;
 dpsids(0,1) = 0.0          
  + 3.0*(d_cubic_bubble012_ds1 + d_cubic_bubble013_ds1 + d_cubic_bubble023_ds1)
   - 4.0*d_quartic_bubble_ds1;
 dpsids(0,2) = 0.0          
  + 3.0*(d_cubic_bubble012_ds2 + d_cubic_bubble013_ds2 + d_cubic_bubble023_ds2)
  - 4.0*d_quartic_bubble_ds2;

 dpsids(1,0) = 0.0          
  + 3.0*(d_cubic_bubble012_ds0 + d_cubic_bubble013_ds0 + d_cubic_bubble123_ds0)
  - 4.0*d_quartic_bubble_ds0;
 dpsids(1,1) = 4.0*s[1]-1.0 
  + 3.0*(d_cubic_bubble012_ds1 + d_cubic_bubble013_ds1 + d_cubic_bubble123_ds1)
  - 4.0*d_quartic_bubble_ds1;
 dpsids(1,2) = 0.0          
  + 3.0*(d_cubic_bubble012_ds2 + d_cubic_bubble013_ds2 + d_cubic_bubble123_ds2)
  - 4.0*d_quartic_bubble_ds2;

 dpsids(2,0) = 0.0          
  + 3.0*(d_cubic_bubble012_ds0 + d_cubic_bubble023_ds0 + d_cubic_bubble123_ds0)
  - 4.0*d_quartic_bubble_ds0;
 dpsids(2,1) = 0.0          
  + 3.0*(d_cubic_bubble012_ds1 + d_cubic_bubble023_ds1 + d_cubic_bubble123_ds1)
  - 4.0*d_quartic_bubble_ds1;
 dpsids(2,2) = 4.0*s[2]-1.0 
  + 3.0*(d_cubic_bubble012_ds2 + d_cubic_bubble023_ds2 + d_cubic_bubble123_ds2)
  - 4.0*d_quartic_bubble_ds2;

 dpsids(3,0) = -4.0*s3+1.0   
  + 3.0*(d_cubic_bubble013_ds0 + d_cubic_bubble023_ds0 + d_cubic_bubble123_ds0)
  -4.0*d_quartic_bubble_ds0;
 dpsids(3,1) = -4.0*s3+1.0 
  + 3.0*(d_cubic_bubble013_ds1 + d_cubic_bubble023_ds1 + d_cubic_bubble123_ds1)
  -4.0*d_quartic_bubble_ds1;
 dpsids(3,2) = -4.0*s3+1.0   
  + 3.0*(d_cubic_bubble013_ds2 + d_cubic_bubble023_ds2 + d_cubic_bubble123_ds2)
  -4.0*d_quartic_bubble_ds2;

 dpsids(4,0) = 4.0*s[1]  
  - 12.0*(d_cubic_bubble012_ds0 + d_cubic_bubble013_ds0)
   + 32.0*d_quartic_bubble_ds0;
 dpsids(4,1) = 4.0*s[0]  
  - 12.0*(d_cubic_bubble012_ds1 + d_cubic_bubble013_ds1)
   + 32.0*d_quartic_bubble_ds1;
 dpsids(4,2) = 0.0       
  - 12.0*(d_cubic_bubble012_ds2 + d_cubic_bubble013_ds2)
  + 32.0*d_quartic_bubble_ds2;

 dpsids(5,0) = 4.0*s[2]    
  - 12.0*(d_cubic_bubble012_ds0 + d_cubic_bubble023_ds0)
  + 32.0*d_quartic_bubble_ds0;
 dpsids(5,1) = 0.0       
  - 12.0*(d_cubic_bubble012_ds1 + d_cubic_bubble023_ds1)
  + 32.0*d_quartic_bubble_ds1;
 dpsids(5,2) = 4.0*s[0]  
  - 12.0*(d_cubic_bubble012_ds2 + d_cubic_bubble023_ds2)
  + 32.0*d_quartic_bubble_ds2;
 
 dpsids(6,0) = 4.0*(s3-s[0]) 
  - 12.0*(d_cubic_bubble013_ds0 + d_cubic_bubble023_ds0)
   + 32.0*d_quartic_bubble_ds0;
 dpsids(6,1) = -4.0*s[0]     
  - 12.0*(d_cubic_bubble013_ds1 + d_cubic_bubble023_ds1)
   + 32.0*d_quartic_bubble_ds1;
 dpsids(6,2) = -4.0*s[0]     
  - 12.0*(d_cubic_bubble013_ds2 + d_cubic_bubble023_ds2)
   + 32.0*d_quartic_bubble_ds2;

 dpsids(7,0) = 0.0            
  - 12.0*(d_cubic_bubble012_ds0 + d_cubic_bubble123_ds0)
  + 32.0*d_quartic_bubble_ds0;
 dpsids(7,1) = 4.0*s[2]       
  - 12.0*(d_cubic_bubble012_ds1 + d_cubic_bubble123_ds1)
  + 32.0*d_quartic_bubble_ds1;
 dpsids(7,2) = 4.0*s[1]       
  - 12.0*(d_cubic_bubble012_ds2 + d_cubic_bubble123_ds2)
  + 32.0*d_quartic_bubble_ds2;

 dpsids(8,0) = -4.0*s[2]     
  - 12.0*(d_cubic_bubble023_ds0 + d_cubic_bubble123_ds0)
  + 32.0*d_quartic_bubble_ds0;
 dpsids(8,1) = -4.0*s[2]     
  - 12.0*(d_cubic_bubble023_ds1 + d_cubic_bubble123_ds1)
  + 32.0*d_quartic_bubble_ds1;
 dpsids(8,2) = 4.0*(s3-s[2]) 
  - 12.0*(d_cubic_bubble023_ds2 + d_cubic_bubble123_ds2)
  + 32.0*d_quartic_bubble_ds2;

 dpsids(9,0) = -4.0*s[1]     
  - 12.0*(d_cubic_bubble013_ds0 + d_cubic_bubble123_ds0)
  + 32.0*d_quartic_bubble_ds0;
 dpsids(9,1) = 4.0*(s3-s[1])  
  - 12.0*(d_cubic_bubble013_ds1 + d_cubic_bubble123_ds1)
  + 32.0*d_quartic_bubble_ds1;
 dpsids(9,2) = -4.0*s[1]     
  - 12.0*(d_cubic_bubble013_ds2 + d_cubic_bubble123_ds2)
  + 32.0*d_quartic_bubble_ds2;

 //Add the bubble function on the face spanned by 0 1 3
 dpsids(10,0) = 27.0*d_cubic_bubble013_ds0 - 108.0*d_quartic_bubble_ds0;
 dpsids(10,1) = 27.0*d_cubic_bubble013_ds1 - 108.0*d_quartic_bubble_ds1;
 dpsids(10,2) = 27.0*d_cubic_bubble013_ds2 - 108.0*d_quartic_bubble_ds2;

 //Add the bubble function on the face spanned by 0 1 2
 dpsids(11,0) = 27.0*d_cubic_bubble012_ds0 - 108.0*d_quartic_bubble_ds0;
 dpsids(11,1) = 27.0*d_cubic_bubble012_ds1 - 108.0*d_quartic_bubble_ds1;
 dpsids(11,2) = 27.0*d_cubic_bubble012_ds2 - 108.0*d_quartic_bubble_ds2;

 //Add the bubble function on the face spanned by 0 2 3
 dpsids(12,0) = 27.0*d_cubic_bubble023_ds0 - 108.0*d_quartic_bubble_ds0;
 dpsids(12,1) = 27.0*d_cubic_bubble023_ds1 - 108.0*d_quartic_bubble_ds1;
 dpsids(12,2) = 27.0*d_cubic_bubble023_ds2 - 108.0*d_quartic_bubble_ds2;

 //Add the bubble function on the face spanned by 1 2 3
 dpsids(13,0) = 27.0*d_cubic_bubble123_ds0 - 108.0*d_quartic_bubble_ds0;
 dpsids(13,1) = 27.0*d_cubic_bubble123_ds1 - 108.0*d_quartic_bubble_ds1;
 dpsids(13,2) = 27.0*d_cubic_bubble123_ds2 - 108.0*d_quartic_bubble_ds2;

 //Add the volumetric bubble function derivatives
 dpsids(14,0) = 256.0*d_quartic_bubble_ds0;
 dpsids(14,1) = 256.0*d_quartic_bubble_ds1;
 dpsids(14,2) = 256.0*d_quartic_bubble_ds2;
}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<3,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ 
/// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
/// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ 
/// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ 
//=======================================================================
void d2shape_local(const Vector<double> &s,
                                         Shape &psi,
                                         DShape &dpsids,
                                         DShape &d2psids) const
{
 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);

 // Define s3
 const double s3=1.0-s[0]-s[1]-s[2]; 

 //Calculate second derivatives of the bubble functions
 //(.,3) for mixed derivative s[0]-s[1]
 //(.,4) for mixed derivative s[0]-s[2]
 //(.,5) for mixed derivative s[1]-s[2]


 const double d2_quartic_bubble_ds0 = -2.0*s[1]*s[2];
 const double d2_quartic_bubble_ds1 = -2.0*s[0]*s[2];
 const double d2_quartic_bubble_ds2 = -2.0*s[0]*s[1];
 const double d2_quartic_bubble_ds3 = s[2]*(1.0 - 2.0*s[0] - 2.0*s[1] - s[2]);
 const double d2_quartic_bubble_ds4 = s[1]*(1.0 - 2.0*s[0] - 2.0*s[2] - s[1]);
 const double d2_quartic_bubble_ds5 = s[0]*(1.0 - 2.0*s[1] - 2.0*s[2] - s[0]);

 const double d2_cubic_bubble012_ds0 = 0.0;
 const double d2_cubic_bubble012_ds1 = 0.0;
 const double d2_cubic_bubble012_ds2 = 0.0;
 const double d2_cubic_bubble012_ds3 = s[2];
 const double d2_cubic_bubble012_ds4 = s[1];
 const double d2_cubic_bubble012_ds5 = s[0];

 const double d2_cubic_bubble013_ds0 = -2.0*s[1];
 const double d2_cubic_bubble013_ds1 = -2.0*s[0];
 const double d2_cubic_bubble013_ds2 = 0.0;
 const double d2_cubic_bubble013_ds3 = s3 - s[0] - s[1];
 const double d2_cubic_bubble013_ds4 = -s[1];
 const double d2_cubic_bubble013_ds5 = -s[0];

 const double d2_cubic_bubble023_ds0 = -2.0*s[2];
 const double d2_cubic_bubble023_ds1 = 0.0;
 const double d2_cubic_bubble023_ds2 = -2.0*s[0];
 const double d2_cubic_bubble023_ds3 = -s[2];
 const double d2_cubic_bubble023_ds4 = s3 - s[0] - s[2];
 const double d2_cubic_bubble023_ds5 = -s[0];

 const double d2_cubic_bubble123_ds0 = 0.0;
 const double d2_cubic_bubble123_ds1 = -2.0*s[2];
 const double d2_cubic_bubble123_ds2 = -2.0*s[1];
 const double d2_cubic_bubble123_ds3 = -s[2];
 const double d2_cubic_bubble123_ds4 = -s[1];
 const double d2_cubic_bubble123_ds5 = s3 - s[1] - s[2];


 d2psids(0,0) = 4.0 
  + 3.0*(d2_cubic_bubble012_ds0 + d2_cubic_bubble013_ds0 
         + d2_cubic_bubble023_ds0)
  - 4.0*d2_quartic_bubble_ds0;
 d2psids(0,1) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds1 + d2_cubic_bubble013_ds1 
         + d2_cubic_bubble023_ds1)
  - 4.0*d2_quartic_bubble_ds1;
 d2psids(0,2) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds2 + d2_cubic_bubble013_ds2 
         + d2_cubic_bubble023_ds2)
  - 4.0*d2_quartic_bubble_ds2;
 d2psids(0,3) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds3 + d2_cubic_bubble013_ds3 
         + d2_cubic_bubble023_ds3)
  - 4.0*d2_quartic_bubble_ds3;
 d2psids(0,4) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds4 + d2_cubic_bubble013_ds4 
         + d2_cubic_bubble023_ds4)
  - 4.0*d2_quartic_bubble_ds4;
 d2psids(0,5) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds5 + d2_cubic_bubble013_ds5 
         + d2_cubic_bubble023_ds5)
  - 4.0*d2_quartic_bubble_ds5;
 
 
 d2psids(1,0) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds0 + d2_cubic_bubble013_ds0 
         + d2_cubic_bubble123_ds0)
  - 4.0*d2_quartic_bubble_ds0;
 d2psids(1,1) = 4.0 
  + 3.0*(d2_cubic_bubble012_ds1 + d2_cubic_bubble013_ds1 
         + d2_cubic_bubble123_ds1)
  - 4.0*d2_quartic_bubble_ds1;
  d2psids(1,2) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds2 + d2_cubic_bubble013_ds2 
          + d2_cubic_bubble123_ds2)
   - 4.0*d2_quartic_bubble_ds2;
  d2psids(1,3) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds3 + d2_cubic_bubble013_ds3 
          + d2_cubic_bubble123_ds3)
   - 4.0*d2_quartic_bubble_ds3;
  d2psids(1,4) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds4 + d2_cubic_bubble013_ds4 
          + d2_cubic_bubble123_ds4)
   - 4.0*d2_quartic_bubble_ds4;
  d2psids(1,5) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds5 + d2_cubic_bubble013_ds5 
          + d2_cubic_bubble123_ds5)
   - 4.0*d2_quartic_bubble_ds5;


  d2psids(2,0) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds0 + d2_cubic_bubble023_ds0 
          + d2_cubic_bubble123_ds0)
   - 4.0*d2_quartic_bubble_ds0;
  d2psids(2,1) = 0.0 
  + 3.0*(d2_cubic_bubble012_ds1 + d2_cubic_bubble023_ds1 
         + d2_cubic_bubble123_ds1)
   - 4.0*d2_quartic_bubble_ds1;
  d2psids(2,2) = 4.0 
   + 3.0*(d2_cubic_bubble012_ds2 + d2_cubic_bubble023_ds2 
         + d2_cubic_bubble123_ds2)
   - 4.0*d2_quartic_bubble_ds2;
  d2psids(2,3) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds3 + d2_cubic_bubble023_ds3 
          + d2_cubic_bubble123_ds3)
   - 4.0*d2_quartic_bubble_ds3;
  d2psids(2,4) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds4 + d2_cubic_bubble023_ds4 
          + d2_cubic_bubble123_ds4)
   - 4.0*d2_quartic_bubble_ds4;
  d2psids(2,5) = 0.0 
   + 3.0*(d2_cubic_bubble012_ds5 + d2_cubic_bubble023_ds5 
          + d2_cubic_bubble123_ds5)
   - 4.0*d2_quartic_bubble_ds5;
  

  d2psids(3,0) = 4.0 
   + 3.0*(d2_cubic_bubble013_ds0 + d2_cubic_bubble023_ds0 
          + d2_cubic_bubble123_ds0)
   -4.0*d2_quartic_bubble_ds0;
  d2psids(3,1) = 4.0 
   + 3.0*(d2_cubic_bubble013_ds1 + d2_cubic_bubble023_ds1 
          + d2_cubic_bubble123_ds1)
   -4.0*d2_quartic_bubble_ds1;
  d2psids(3,2) = 4.0 
   + 3.0*(d2_cubic_bubble013_ds2 + d2_cubic_bubble023_ds2 
          + d2_cubic_bubble123_ds2)
   -4.0*d2_quartic_bubble_ds2;
  d2psids(3,3) = 4.0 
   + 3.0*(d2_cubic_bubble013_ds3 + d2_cubic_bubble023_ds3 
          + d2_cubic_bubble123_ds3)
   -4.0*d2_quartic_bubble_ds3;
  d2psids(3,4) = 4.0 
   + 3.0*(d2_cubic_bubble013_ds4 + d2_cubic_bubble023_ds4 
          + d2_cubic_bubble123_ds4)
   -4.0*d2_quartic_bubble_ds4;
  d2psids(3,5) = 4.0 
   + 3.0*(d2_cubic_bubble013_ds5 + d2_cubic_bubble023_ds5 
          + d2_cubic_bubble123_ds5)
   -4.0*d2_quartic_bubble_ds5;
  

 d2psids(4,0) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds0 + d2_cubic_bubble013_ds0)
  + 32.0*d2_quartic_bubble_ds0;
 d2psids(4,1) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds1 + d2_cubic_bubble013_ds1)
  + 32.0*d2_quartic_bubble_ds1;
 d2psids(4,2) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds2 + d2_cubic_bubble013_ds2)
  + 32.0*d2_quartic_bubble_ds2;
 d2psids(4,3) = 4.0 
  - 12.0*(d2_cubic_bubble012_ds3 + d2_cubic_bubble013_ds3)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(4,4) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds4 + d2_cubic_bubble013_ds4)
  + 32.0*d2_quartic_bubble_ds4;
 d2psids(4,5) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds5 + d2_cubic_bubble013_ds5)
  + 32.0*d2_quartic_bubble_ds5;


 d2psids(5,0) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds0 + d2_cubic_bubble023_ds0)
  + 32.0*d2_quartic_bubble_ds0;
 d2psids(5,1) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds1 + d2_cubic_bubble023_ds1)
  + 32.0*d2_quartic_bubble_ds1;
 d2psids(5,2) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds2 + d2_cubic_bubble023_ds2)
  + 32.0*d2_quartic_bubble_ds2;
 d2psids(5,3) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds3 + d2_cubic_bubble023_ds3)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(5,4) = 4.0 
  - 12.0*(d2_cubic_bubble012_ds4 + d2_cubic_bubble023_ds4)
  + 32.0*d2_quartic_bubble_ds4;
 d2psids(5,5) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds5 + d2_cubic_bubble023_ds5)
  + 32.0*d2_quartic_bubble_ds5;


 d2psids(6,0) =-8.0  
 - 12.0*(d2_cubic_bubble013_ds0 + d2_cubic_bubble023_ds0)
  + 32.0*d2_quartic_bubble_ds0;
 d2psids(6,1) = 0.0  
 - 12.0*(d2_cubic_bubble013_ds1 + d2_cubic_bubble023_ds1)
  + 32.0*d2_quartic_bubble_ds1;
 d2psids(6,2) = 0.0  
  - 12.0*(d2_cubic_bubble013_ds2 + d2_cubic_bubble023_ds2)
  + 32.0*d2_quartic_bubble_ds2;
 d2psids(6,3) = -4.0 
  - 12.0*(d2_cubic_bubble013_ds3 + d2_cubic_bubble023_ds3)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(6,4) = -4.0 
  - 12.0*(d2_cubic_bubble013_ds4 + d2_cubic_bubble023_ds4)
  + 32.0*d2_quartic_bubble_ds4;
 d2psids(6,5) = 0.0   
  - 12.0*(d2_cubic_bubble013_ds5 + d2_cubic_bubble023_ds5)
   + 32.0*d2_quartic_bubble_ds5;

 d2psids(7,0) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds0 + d2_cubic_bubble123_ds0)
  + 32.0*d2_quartic_bubble_ds0;
 d2psids(7,1) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds1 + d2_cubic_bubble123_ds1)
  + 32.0*d2_quartic_bubble_ds1;
 d2psids(7,2) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds2 + d2_cubic_bubble123_ds2)
  + 32.0*d2_quartic_bubble_ds2;
 d2psids(7,3) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds3 + d2_cubic_bubble123_ds3)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(7,4) = 0.0 
  - 12.0*(d2_cubic_bubble012_ds4 + d2_cubic_bubble123_ds4)
  + 32.0*d2_quartic_bubble_ds4;
 d2psids(7,5) = 4.0 
  - 12.0*(d2_cubic_bubble012_ds5 + d2_cubic_bubble123_ds5)
  + 32.0*d2_quartic_bubble_ds5;
 
 d2psids(8,0) = 0.0  
  - 12.0*(d2_cubic_bubble023_ds0 + d2_cubic_bubble123_ds0)
  + 32.0*d2_quartic_bubble_ds0;
 d2psids(8,1) = 0.0  
  - 12.0*(d2_cubic_bubble023_ds1 + d2_cubic_bubble123_ds1)
  + 32.0*d2_quartic_bubble_ds1;
 d2psids(8,2) = -8.0 
  - 12.0*(d2_cubic_bubble023_ds2 + d2_cubic_bubble123_ds2)
  + 32.0*d2_quartic_bubble_ds2;
 d2psids(8,3) = 0.0  
  - 12.0*(d2_cubic_bubble023_ds3 + d2_cubic_bubble123_ds3)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(8,4) = -4.0 
  - 12.0*(d2_cubic_bubble023_ds4 + d2_cubic_bubble123_ds4)
  + 32.0*d2_quartic_bubble_ds4;
 d2psids(8,5) = -4.0 
  - 12.0*(d2_cubic_bubble023_ds5 + d2_cubic_bubble123_ds5)
  + 32.0*d2_quartic_bubble_ds5;

 d2psids(9,0) = 0.0  
  - 12.0*(d2_cubic_bubble013_ds0 + d2_cubic_bubble123_ds0)
  + 32.0*d2_quartic_bubble_ds0;
 d2psids(9,1) = -8.0 
  - 12.0*(d2_cubic_bubble013_ds1 + d2_cubic_bubble123_ds1)
  + 32.0*d2_quartic_bubble_ds1;
 d2psids(9,2) = 0.0  
  - 12.0*(d2_cubic_bubble013_ds2 + d2_cubic_bubble123_ds2)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(9,3) = -4.0 
  - 12.0*(d2_cubic_bubble013_ds3 + d2_cubic_bubble123_ds3)
  + 32.0*d2_quartic_bubble_ds3;
 d2psids(9,4) = 0.0  
  - 12.0*(d2_cubic_bubble013_ds4 + d2_cubic_bubble123_ds4)
  + 32.0*d2_quartic_bubble_ds4;
 d2psids(9,5) = -4.0 
  - 12.0*(d2_cubic_bubble013_ds5 + d2_cubic_bubble123_ds5)
  + 32.0*d2_quartic_bubble_ds5;

 //Add the bubble function on the face spanned by 0 1 3
 d2psids(10,0) = 27.0*d2_cubic_bubble013_ds0 - 108.0*d2_quartic_bubble_ds0;
 d2psids(10,1) = 27.0*d2_cubic_bubble013_ds1 - 108.0*d2_quartic_bubble_ds1;
 d2psids(10,2) = 27.0*d2_cubic_bubble013_ds2 - 108.0*d2_quartic_bubble_ds2;
 d2psids(10,3) = 27.0*d2_cubic_bubble013_ds3 - 108.0*d2_quartic_bubble_ds3;
 d2psids(10,4) = 27.0*d2_cubic_bubble013_ds4 - 108.0*d2_quartic_bubble_ds4;
 d2psids(10,5) = 27.0*d2_cubic_bubble013_ds5 - 108.0*d2_quartic_bubble_ds5;

 //Add the bubble function on the face spanned by 0 1 2
 d2psids(11,0) = 27.0*d2_cubic_bubble012_ds0 - 108.0*d2_quartic_bubble_ds0;
 d2psids(11,1) = 27.0*d2_cubic_bubble012_ds1 - 108.0*d2_quartic_bubble_ds1;
 d2psids(11,2) = 27.0*d2_cubic_bubble012_ds2 - 108.0*d2_quartic_bubble_ds2;
 d2psids(11,3) = 27.0*d2_cubic_bubble012_ds3 - 108.0*d2_quartic_bubble_ds3;
 d2psids(11,4) = 27.0*d2_cubic_bubble012_ds4 - 108.0*d2_quartic_bubble_ds4;
 d2psids(11,5) = 27.0*d2_cubic_bubble012_ds5 - 108.0*d2_quartic_bubble_ds5;

 //Add the bubble function on the face spanned by 0 2 3
 d2psids(12,0) = 27.0*d2_cubic_bubble023_ds0 - 108.0*d2_quartic_bubble_ds0;
 d2psids(12,1) = 27.0*d2_cubic_bubble023_ds1 - 108.0*d2_quartic_bubble_ds1;
 d2psids(12,2) = 27.0*d2_cubic_bubble023_ds2 - 108.0*d2_quartic_bubble_ds2;
 d2psids(12,3) = 27.0*d2_cubic_bubble023_ds3 - 108.0*d2_quartic_bubble_ds3;
 d2psids(12,4) = 27.0*d2_cubic_bubble023_ds4 - 108.0*d2_quartic_bubble_ds4;
 d2psids(12,5) = 27.0*d2_cubic_bubble023_ds5 - 108.0*d2_quartic_bubble_ds5;

 //Add the bubble function on the face spanned by 1 2 3
 d2psids(13,0) = 27.0*d2_cubic_bubble123_ds0 - 108.0*d2_quartic_bubble_ds0;
 d2psids(13,1) = 27.0*d2_cubic_bubble123_ds1 - 108.0*d2_quartic_bubble_ds1;
 d2psids(13,2) = 27.0*d2_cubic_bubble123_ds2 - 108.0*d2_quartic_bubble_ds2;
 d2psids(13,3) = 27.0*d2_cubic_bubble123_ds3 - 108.0*d2_quartic_bubble_ds3;
 d2psids(13,4) = 27.0*d2_cubic_bubble123_ds4 - 108.0*d2_quartic_bubble_ds4;
 d2psids(13,5) = 27.0*d2_cubic_bubble123_ds5 - 108.0*d2_quartic_bubble_ds5;

 //Add the volumetric bubble function derivatives
 d2psids(14,0) = 256.0*d2_quartic_bubble_ds0;
 d2psids(14,1) = 256.0*d2_quartic_bubble_ds1;
 d2psids(14,2) = 256.0*d2_quartic_bubble_ds2;
 d2psids(14,3) = 256.0*d2_quartic_bubble_ds3;
 d2psids(14,4) = 256.0*d2_quartic_bubble_ds4;
 d2psids(14,5) = 256.0*d2_quartic_bubble_ds5;
}


};




//=======================================================================
/// General TElement class specialised to three spatial dimensions (tet)
/// Ordering of nodes inverted from Zienkiewizc sketches: When looking into the
/// tet from vertex node 0. The vertex nodes on the opposite face are
/// 1 - 2 - 3 in anticlockwise direction. Other nodes filled in edge by 
/// edge, then the face ones, then the internal ones.
//=======================================================================
template<unsigned NNODE_1D>
class TElement<3,NNODE_1D> : public virtual TElementBase,
                  public TElementShape<3,NNODE_1D>
{
  private:
  
 /// Nodal translation scheme for use when generating face elements
 static const unsigned Node_on_face[4][(NNODE_1D*(NNODE_1D+1))/2];
 
 /// \short Default integration rule: Gaussian integration of same 'order' as
 /// the element
 //This is sort of optimal, because it means that the integration is exact
 //for the shape functions. Can overwrite this in specific element defintion.
 static TGauss<3,NNODE_1D> Default_integration_scheme;
  
public:
 
 /// Constructor
 TElement()
  {
   switch (NNODE_1D)
    {
    case 2:
    case 3:
     break;

/*     case 4: */
/*      n_node = 20; */
/*      break; */

    default:
     std::string error_message =
      "Tets are currently only implemented for\n";
     error_message +=
      "four and ten nodes, i.e. NNODE_1D=2 , 3 \n";
     
     throw OomphLibError(error_message,
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }


   // Set the number of nodes
   unsigned n_node = (NNODE_1D*(NNODE_1D+1))/2 + 1 + 3*(NNODE_1D-2);
   this->set_n_node(n_node);

   // Set the elemental and nodal dimensions
   set_dimension(3);

   //Assign default (full) spatial integration scheme
   set_integration_scheme(&Default_integration_scheme);
  }



 /// Broken copy constructor
 TElement(const TElement&) 
  { 
   BrokenCopy::broken_copy("TElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const TElement&) 
  {
   BrokenCopy::broken_assign("TElement");
   }*/

  
 /// Destructor
 ~TElement() {}
 
 /// Number of nodes along each element edge
 unsigned nnode_1d() const {return NNODE_1D;}
 
 
 /// \short Number of vertex nodes in the element: One more
 /// than spatial dimension
 unsigned nvertex_node() const {return 4;}

 /// \short Public access function for Node_on_face.
 unsigned get_bulk_node_number(const int& face_index,
                               const unsigned& i) const
  {
   return Node_on_face[face_index][i];
  }
 
 /// \short Pointer to the j-th vertex node in the element
 Node* vertex_node_pt(const unsigned& j) const
  {
   // Vertex nodes come first:
#ifdef PARANOID
   if (j>3)
    {
     std::ostringstream error_message;
     error_message 
      << "Element only has four vertex nodes; called with node number " 
      << j << std::endl;     
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return node_pt(j);
  }
 
 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {TElementShape<3,NNODE_1D>::shape(s,psi);}
 
 /// \short Compute the  geometric shape functions and
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi,
                          DShape &dpsids) const
  {TElementShape<3,NNODE_1D>::dshape_local(s,psi,dpsids);}
 
  /// \short Compute the geometric shape functions, derivatives and
  /// second derivatives w.r.t local coordinates at local coordinate s. 
  /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
  /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
  /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ 
  /// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
  /// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ 
  /// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ 
  inline void d2shape_local(const Vector<double> &s, Shape &psi,
                            DShape &dpsids, DShape &d2psids) const
   {TElementShape<3,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);}
  
  /// \short Overload the template-free interface for the calculation of
  /// inverse jacobian matrix. This is a three dimensional element, so use
  /// the 3D version.
  double invert_jacobian_mapping(const DenseMatrix<double>&jacobian,
                                 DenseMatrix<double>&inverse_jacobian) const
  {return FiniteElement::invert_jacobian<3>(jacobian,inverse_jacobian);}
    
  /// Min. value of local coordinate
  double s_min() const {return 0.0;}
  
  /// Max. value of local coordinate
  double s_max() const {return 1.0;}
  
  /// Return local coordinates of node j
  inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s) const
   {TElementShape<3,NNODE_1D>::local_coordinate_of_node(j,s);}

 /// \short Return the number of actual plot points for paraview
 /// plot with parameter nplot.
 unsigned nplot_points_paraview(const unsigned& nplot) const
  {
   unsigned node_sum=0;
   for(unsigned j=1;j<=nplot;j++)
    {
     for(unsigned i=1;i<=j;i++)
      {
       node_sum+=i;
      }
    }
   return node_sum;
  }

  /// \short Return the number of local sub-elements for paraview plot with 
 /// parameter nplot.
 unsigned nsub_elements_paraview(const unsigned& nplot) const
  {
   return (nplot-1)*(nplot-1)*(nplot-1);
  }

  /// \short Fill in the offset information for paraview plot.
 /// Needs to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_output_offset_information(std::ofstream& file_out,
                                               const unsigned& nplot,
                                               unsigned& counter) const
  { 
    //Output node lists for sub elements for Paraview (node index
    //must start at 0, fixed with magical counter-1)

   unsigned paraview_fix=counter-1;
    unsigned nod_count=1;

    for(unsigned i=0;i<nplot;i++)
     {
      for(unsigned j=0;j<nplot-i;j++)
       {
        for(unsigned k=0;k<nplot-i-j;k++)
         {
          if(k<nplot-i-j-1)
           {
            file_out<< nod_count+paraview_fix << " " 
                    << nod_count+1+paraview_fix << " " 
                    << nod_count+nplot-i-j+paraview_fix <<" "
                    <<nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)
             +paraview_fix
                    << std::endl;
            if(k<nplot-i-j-2)
             {
              file_out << nod_count+1+paraview_fix << " " 
                       << nod_count+nplot-i-j+paraview_fix << " " 
                       << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix << " "
                       << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix
                       << std::endl;
              file_out << nod_count+1+paraview_fix << " "
                       << nod_count+nplot-i-j+paraview_fix << " " 
                       << nod_count+nplot-i-j+1+paraview_fix << " " 
                       << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix
                       << std::endl;
              file_out << nod_count+1+paraview_fix << " " 
                       << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix << " "
                       << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)+1
               +paraview_fix << " "
                       << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix
                       << std::endl;
              file_out << nod_count+1+paraview_fix << " "
                       << nod_count+nplot-i-j+1+paraview_fix << " " 
                       << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)+1
               +paraview_fix
                       << " " 
                       << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix
                       << std::endl;
             }
            if(k>1)
             {
              file_out << nod_count+nplot-i-j-1+paraview_fix << " " 
                       << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)-1
               +paraview_fix
                       << " "
                       << nod_count+2*(nplot-i-j-1)+((nplot-1-i)*(nplot-i)/2)-1
               +paraview_fix
                       <<" "
                       << nod_count+2*(nplot-i-j-1)+((nplot-1-i)*(nplot-i)/2)
               +paraview_fix
                       << std::endl;
             }
           }//end if(k<nplot-i-j-1)
          ++nod_count;
         }
       }
     }

    //increment the counter to keep track of global connectivity
    counter+=nplot_points_paraview(nplot);

   } //end of write Paraview_element...

 /// \short Return the paraview element type.
 /// Needs to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_type(std::ofstream& file_out,
                          const unsigned& nplot) const
  {
   unsigned local_loop=nsub_elements_paraview(nplot);
   for(unsigned i=0;i<local_loop;i++)
    {
     file_out << "10" << std::endl;
    }
  }

 /// \short Return the offsets for the paraview sub-elements. Needs 
 /// to be implemented for each new geometric element type; see
 /// http://www.vtk.org/VTK/img/file-formats.pdf
 void write_paraview_offsets(std::ofstream& file_out,
                             const unsigned& nplot,
                             unsigned& offset_sum) const
  {
   unsigned local_loop=nsub_elements_paraview(nplot);
   for(unsigned i=0;i<local_loop;i++)
    {
     offset_sum+=4;
     file_out << offset_sum << std::endl;
    }
  }

  /// Output
  void output(std::ostream &output);
  
  /// Output at specified number of plot points
  void output(std::ostream &outfile, const unsigned &nplot);
  
  /// C-style output
  void output(FILE* file_pt);
  
  /// C_style output at n_plot points
  void output(FILE* file_pt, const unsigned &n_plot);
  
  /// \short  Get vector of local coordinates of plot point i (when plotting
  /// nplot points in each "coordinate direction).
  void get_s_plot(
   const unsigned& iplot, 
   const unsigned& nplot,
   Vector<double>& s,
   const bool& use_equally_spaced_interior_sample_points=false) const
  {
   if (nplot>1)
    {
     unsigned np=0;
     for(unsigned i=0;i<nplot;++i)
      {
       for(unsigned j=0;j<nplot-i;++j)
        {
         for(unsigned k=0;k<nplot-i-j;++k)
          {
           if(np==iplot)
            {
             {
              s[0] = double(j)/double(nplot-1);
              s[1] = double(i)/double(nplot-1);
              s[2] = double(k)/double(nplot-1);
              if (use_equally_spaced_interior_sample_points)
               {
                double range=1.0;
                double dx_new=range/double(nplot+1);       
                double range_new=double(nplot-1)*dx_new;
                s[0]=0.5*dx_new+range_new*s[0]/range;
                s[1]=0.5*dx_new+range_new*s[1]/range;
                s[2]=0.5*dx_new+range_new*s[2]/range;
               }
              return;
             }
            }
           np++;
          }
        }
      }
    }
   else
    {
     s[0] = 1.0/4.0;
     s[1] = 1.0/4.0;
     s[2] = 1.0/4.0;
    }
  }

  /// \short Return string for tecplot zone header (when plotting
  /// nplot points in each "coordinate direction)
  std::string tecplot_zone_string(const unsigned& nplot) const
  {
   std::ostringstream header;
   unsigned nel=0;
   nel=(nplot-1)*(nplot-1)*(nplot-1);
   header << "ZONE N=" << nplot_points(nplot) << ", E="
          << nel << ", F=FEPOINT, ET=TETRAHEDRON\n";
   return header.str();
  }
  
  /// \short Add tecplot zone "footer" to output stream (when plotting
  /// nplot points in each "coordinate direction).
  /// Empty by default -- can be used, e.g., to add FE connectivity
  /// lists to elements that need it.
  void write_tecplot_zone_footer(std::ostream& outfile,
                                 const unsigned& nplot) const
   {
    
    //Output node lists for sub elements for Tecplot (node index
    //must start at 1)
    unsigned nod_count=1;
    for(unsigned i=0;i<nplot;i++)
     {
      for(unsigned j=0;j<nplot-i;j++)
       {
        for(unsigned k=0;k<nplot-i-j;k++)
         {
          if(k<nplot-i-j-1)
           {
            outfile<< nod_count << " " 
                   << nod_count+1 << " " 
                   << nod_count+nplot-i-j <<" "
                   <<nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)
                   << std::endl;
            if(k<nplot-i-j-2)
             {
              outfile << nod_count+1<< " " 
                      << nod_count+nplot-i-j << " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2) << " "
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
              outfile << nod_count+1 << " "
                      << nod_count+nplot-i-j << " " 
                      << nod_count+nplot-i-j+1<< " " 
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
              outfile << nod_count+1<< " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)<< " "
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)+1<< " "
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
              outfile << nod_count+1<< " "
                      << nod_count+nplot-i-j+1<< " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)+1
                      << " " 
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
             }
            if(k>1)
             {
              outfile << nod_count+nplot-i-j-1<< " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)-1 
                      << " "
                      << nod_count+2*(nplot-i-j-1)+((nplot-1-i)*(nplot-i)/2)-1
                      <<" "
                      << nod_count+2*(nplot-i-j-1)+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
             }
           }//end if(k<nplot-i-j-1)
          ++nod_count;
         }
       }
     }
   } //end of write tecplot...
  

 /// \short Add tecplot zone "footer" to C-style output. (when plotting
 /// nplot points in each "coordinate direction).
 /// Empty by default -- can be used, e.g., to add FE connectivity
 /// lists to elements that need it.
  void write_tecplot_zone_footer(FILE* file_pt,
                                 const unsigned& nplot) const
   {
    //Output node lists for sub elements for Tecplot (node index
    //must start at 1)
    unsigned nod_count=1;
    for(unsigned i=0;i<nplot;i++)
     {
      for(unsigned j=0;j<nplot-i;j++)
       {
        for(unsigned k=0;k<nplot-i-j;k++)
         {
          if(j<nplot-i-1)
           {
            fprintf(file_pt,"%i %i %i \n",nod_count,
                    nod_count+1,nod_count+nplot-i);
            if(j<nplot-i-2)
             {
              fprintf(file_pt,"%i %i %i \n",nod_count+1,nod_count+nplot-i+1,
                      nod_count+nplot-i);
             }
           }
          ++nod_count;
         }
       }
     }
   }
      
 /// \short Return total number of plot points (when plotting
 /// nplot points in each "coordinate direction)
 unsigned nplot_points(const unsigned& nplot) const
  { 
   unsigned res=0;
   if(nplot>1)
    {
     res=4;
     for(unsigned i=3;i<=nplot;i++)
      {
       res+=(i*(i+1)/2);
      }
     return res;
    }
   //Otherwise we return 1(?)
   return 1;
  }

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// TElement<2,NNODE_1D>). The face index can take one of four values
 /// corresponding to the four possible faces:
 /// 0: (left)           s[0] = 0.0
 /// 1: (bottom)         s[1] = 0.0
 /// 2: (back)           s[2] = 0.0
 /// 3: (sloping face)   s[0] + s[1] + s[2] = 1
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);
 
};


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



//=======================================================================
/// TElement class for which the shape functions have been enriched
/// by a single bubble function of the next order
///
/// Empty, just establishes the template parameters
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class TBubbleEnrichedElement
{
};			 

//=====================================================================
/// Define integration schemes that are required to exactly integrate
/// the mass matrices of the bubble-enriched elements. The enrichement
/// increases the polynomial order which means that higher-order Gauss
/// rules must be used.
//====================================================================
template<unsigned DIM, unsigned NPTS_1D>
 class TBubbleEnrichedGauss
{
};

//====================================================================
///Specialisation for two-dimensional elements, in which the highest
///order polynomial is cubic, so we need the integration scheme
///for the unenriched cubic element
//====================================================================== 
template<>
class TBubbleEnrichedGauss<2,3> : public TGauss<2,4>
{
  public:
  TBubbleEnrichedGauss() : TGauss<2,4>() {}
};

//====================================================================
///Specialisation for three-dimensional elements, in which the highest
///order polynomial is quartic, so we need the integration scheme
///for the unenriched quartic element
//====================================================================== 
template<>
class TBubbleEnrichedGauss<3,3> : public TGauss<3,5>
{
  public:
  TBubbleEnrichedGauss() : TGauss<3,5>() {}
};



//=======================================================================
/// Enriched TElement class specialised to two spatial dimensions
/// and three nodes per side (quadratic element)
/// Ordering of nodes as in Zienkiwizc sketches: vertex nodes
/// 0 - 1 - 2 anticlockwise. Midside nodes filled in progressing
/// along the consecutive edges. Central node(s) come(s) last.
/// The idea is that we inherit from the existing TElement<2,3>, add
/// the single extra node at the centroid and 
/// overload the shape functions to be those corresponding to the
/// enriched element.
//=======================================================================
template<unsigned DIM>
class TBubbleEnrichedElement<DIM,3> : public virtual TElement<DIM,3>, 
 public TBubbleEnrichedElementShape<DIM,3>
{
  private:
 
 //Static storage for a new integration scheme
 static TBubbleEnrichedGauss<DIM,3> Default_enriched_integration_scheme;

 //Static storage for central node
 static const unsigned Central_node_on_face[DIM+1];

public:

 ///Constructor
 TBubbleEnrichedElement() : TElement<DIM,3>(), 
  TBubbleEnrichedElementShape<DIM,3>()
  {
   //Add the additional enrichment nodes
   unsigned n_node = this->nnode();
   this->set_n_node(n_node+
                    TBubbleEnrichedElementShape<DIM,3>::n_enriched_nodes());
   //Set the new integration scheme
   this->set_integration_scheme(&Default_enriched_integration_scheme);
 }

 /// Broken copy constructor
 TBubbleEnrichedElement(const TBubbleEnrichedElement&) 
  { 
   BrokenCopy::broken_copy("TBubbleEnrichedElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const TBubbleEnrichedElement&) 
  {
   BrokenCopy::broken_assign("TBubbleEnrichedElement");
   }*/

 /// Destructor
 ~TBubbleEnrichedElement() {}
 
 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {TBubbleEnrichedElementShape<DIM,3>::shape(s,psi);}
 
 /// \short Compute the  geometric shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {TBubbleEnrichedElementShape<DIM,3>::dshape_local(s,psi,dpsids);}

 
 /// \short Compute the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s 
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ 
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ 
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ 
 inline void d2shape_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {TBubbleEnrichedElementShape<DIM,3>::d2shape_local(s,psi,dpsids,d2psids);}
 
 /// Return local coordinates of node j
 inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s) const
  {TBubbleEnrichedElementShape<DIM,3>::local_coordinate_of_node(j,s);}

 /// \short Build the lower-dimensional FaceElement 
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);

};


//========================================================================
/// Base class for Solid Telements 
//========================================================================
class TSolidElementBase : public virtual TElementBase,
                          public virtual SolidFiniteElement
{


  public:

 /// Constructor: Empty
 TSolidElementBase(){};

 /// Broken copy constructor
 TSolidElementBase(const TSolidElementBase&) 
  { 
   BrokenCopy::broken_copy("TSolidElementBase");
  } 
 
 /// Broken assignment operator
 /*void operator=(const TSolidElementBase&) 
  {
   BrokenCopy::broken_assign("TSolidElementBase");
   }*/

};




//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


//=======================================================================
/// SolidTElement elements are triangular/tet elements whose 
/// derivatives also include those based upon the lagrangian 
/// positions of the nodes.
/// They are the basis for solid mechanics elements.
//=======================================================================
template <unsigned DIM, unsigned NNODE_1D> 
class SolidTElement
{};


//=======================================================================
///SolidTElement elements, specialised to one spatial dimension
//=======================================================================
template <unsigned NNODE_1D>
class SolidTElement<1,NNODE_1D> : public virtual TElement<1,NNODE_1D>, 
 public virtual TSolidElementBase
{
  public:

 /// Constructor
 SolidTElement() : TElement<1,NNODE_1D>(), SolidFiniteElement() 
  {
   //Set the Lagrangian dimension of the element
   set_lagrangian_dimension(1);
  }
 
 /// Broken copy constructor
 SolidTElement(const SolidTElement&) 
  { 
   BrokenCopy::broken_copy("SolidTElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const SolidTElement&) 
  {
   BrokenCopy::broken_assign("SolidTElement");
   }*/

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidPointElement).  The face index takes two values
 /// corresponding to the two possible faces:
 /// -1 (Left)  s[0] = -1.0
 /// +1 (Right) s[0] =  1.0
 inline void build_face_element(const int &face_index, 
                                FaceElement* face_element_pt);
 

};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// SolidTElements
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// 1D SolidTElements
///////////////////////////////////////////////////////////////////////////


//===========================================================
/// Function to setup geometrical information for lower-dimensional 
/// FaceElements (which are of type SolidTElement<0,1>).
//===========================================================
template<unsigned NNODE_1D>
void SolidTElement<1,NNODE_1D>::
build_face_element(const int &face_index,
                   FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<1,NNODE_1D>::build_face_element(face_index,face_element_pt);

 //Set the Lagrangian dimension from the first node of the present element
 dynamic_cast<SolidFiniteElement*>(face_element_pt)->
  set_lagrangian_dimension(static_cast<SolidNode*>(node_pt(0))->nlagrangian());
}
 


//=======================================================================
/// SolidTElement elements, specialised to two spatial dimensions
//=======================================================================
template <unsigned NNODE_1D>
class SolidTElement<2,NNODE_1D> : public virtual TElement<2,NNODE_1D>, 
 public virtual TSolidElementBase
{
  public:

 /// Constructor
 SolidTElement() : TElementBase(), TElement<2,NNODE_1D>(),
  SolidFiniteElement(), TSolidElementBase()
  {
   //Set the Lagrangian dimension of the element
   set_lagrangian_dimension(2);
  }

 /// Broken copy constructor
 SolidTElement(const SolidTElement&) 
  { 
   BrokenCopy::broken_copy("SolidTElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const SolidTElement&) 
  {
   BrokenCopy::broken_assign("SolidTElement");
   }*/

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidTElement<1,NNODE_1D>). The face index takes three possible values:
 /// 0 (Left)         s[0] = 0.0
 /// 1 (Bottom)       s[1] = 0.0
 /// 2 (Sloping face) s[0] = 1.0 - s[1]
 inline void build_face_element(const int &face_index,
                                FaceElement* face_element_pt);
 
};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// 2D SolidTElements
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//===========================================================
/// Function to setup geometrical information for lower-dimensional 
/// FaceElements (which are of type SolidTElement<1,NNODE_1D>).
//===========================================================
template<unsigned NNODE_1D>
void SolidTElement<2,NNODE_1D>::
build_face_element(const int &face_index, FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<2,NNODE_1D>::build_face_element(face_index,face_element_pt);
 
 //Set the Lagrangian dimension from the first node of the present element
 dynamic_cast<SolidFiniteElement*>(face_element_pt)->
  set_lagrangian_dimension(static_cast<SolidNode*>(node_pt(0))->nlagrangian());
}



//=======================================================================
/// SolidTElement elements, specialised to three spatial dimensions
//=======================================================================
template <unsigned NNODE_1D>
class SolidTElement<3,NNODE_1D> : public virtual TElement<3,NNODE_1D>, 
 public virtual TSolidElementBase
{
  public:

 /// Constructor
 SolidTElement() : TElementBase(), TElement<3,NNODE_1D>(),
  SolidFiniteElement(), TSolidElementBase()
  {
   //Set the Lagrangian dimension of the element
   set_lagrangian_dimension(3);
  }

 /// Broken copy constructor
 SolidTElement(const SolidTElement&) 
  { 
   BrokenCopy::broken_copy("SolidTElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const SolidTElement&) 
  {
   BrokenCopy::broken_assign("SolidTElement");
   }*/


 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidTElement<2,NNODE_1D>). The face index can take one of four values
 /// corresponding to the four possible faces:
 /// 0: (left)           s[0] = 0.0
 /// 1: (bottom)         s[1] = 0.0
 /// 2: (back)           s[2] = 0.0
 /// 3: (sloping face)   s[0] + s[1] + s[2] = 1
 inline void build_face_element(const int &face_index,
                                FaceElement* face_element_pt);

};



///////////////////////////////////////////////////////////////////////////
// 3D SolidTElements
///////////////////////////////////////////////////////////////////////////


//===========================================================
/// Function to setup geometrical information for lower-dimensional 
/// FaceElements (which are of type SolidTElement<1,NNODE_1D>).
//===========================================================
template<unsigned NNODE_1D>
void SolidTElement<3,NNODE_1D>::
 build_face_element(const int &face_index,
                    FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<3,NNODE_1D>::build_face_element(face_index,face_element_pt);
 
 //Set the Lagrangian dimension from the first node of the present element
 dynamic_cast<SolidFiniteElement*>(face_element_pt)->
  set_lagrangian_dimension(static_cast<SolidNode*>(node_pt(0))->nlagrangian());
}




///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//=======================================================================
/// SolidTBubbleEnrichedElement elements are the enriched version 
/// of the SolidTElements. They will simply inherit from the appropriate
/// SolidTElement and TBubblEnrichedElement.
/// They are the basis for solid mechanics elements.
//=======================================================================
template <unsigned DIM, unsigned NNODE_1D> 
class SolidTBubbleEnrichedElement
{};

//===================================================================
///Specify the SolidTBubbleEnrichedElement corresponding to the 
///quadratic triangle
//===================================================================
template<unsigned DIM>
class SolidTBubbleEnrichedElement<DIM,3>  : 
public virtual SolidTElement<DIM,3>,
public virtual TBubbleEnrichedElement<DIM,3>
{

public:

 ///Constructor
 SolidTBubbleEnrichedElement() : SolidTElement<DIM,3>(), 
  TBubbleEnrichedElement<DIM,3>() {}

 /// Broken copy constructor
 SolidTBubbleEnrichedElement(const SolidTBubbleEnrichedElement&) 
  { 
   BrokenCopy::broken_copy("SolidTBubbleEnrichedElement");
  } 
 
 /// Broken assignment operator
 /*void operator=(const SolidTBubbleEnrichedElement&) 
  {
   BrokenCopy::broken_assign("SolidTBubbleEnrichedElement");
   }*/

 /// Destructor
 ~SolidTBubbleEnrichedElement() {}

 /// \short Build the lower-dimensional FaceElement 
 /// Need to put in a final override here
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);

};


//=======================================================================
/// Face geometry for the TElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<TElement<DIM,NNODE_1D> >: 
 public virtual TElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : TElement<DIM-1,NNODE_1D>() {}

};



//=======================================================================
/// Face geometry for the 1D TElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<TElement<1,NNODE_1D> >: 
 public virtual PointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional TElement
 FaceGeometry() : PointElement() {}

};




///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 2D TBubbleEnrichedElement elements is exactly
/// the same as for the corresponding TElement. The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<TBubbleEnrichedElement<2,NNODE_1D> >: 
 public virtual TElement<1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : TElement<1,NNODE_1D>() {}

};


//=======================================================================
/// Face geometry for the 3D TBubbleEnrichedElement elements is the 
/// 2D TBubbleEnrichedElement. The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<TBubbleEnrichedElement<3,NNODE_1D> >: 
 public virtual TBubbleEnrichedElement<2,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : TBubbleEnrichedElement<2,NNODE_1D>() {}

};


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////




//=======================================================================
/// Face geometry for the TElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<SolidTElement<DIM,NNODE_1D> >: 
 public virtual SolidTElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : SolidTElement<DIM-1,NNODE_1D>() {}

};



//=======================================================================
/// Face geometry for the 1D TElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<SolidTElement<1,NNODE_1D> >: 
 public virtual SolidPointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional TElement
 FaceGeometry() : SolidPointElement() {}

};


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 2D SolidTBubbleEnrichedElement elements is exactly
/// the same as for the corresponding 2D SolidTElement. The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<SolidTBubbleEnrichedElement<2,NNODE_1D> >: 
 public virtual SolidTElement<1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : SolidTElement<1,NNODE_1D>() {}

};



//=======================================================================
/// Face geometry for the 3D SolidTBubbleEnrichedElement elements is
/// the 2D SolidTBubbleEnrichedElement. The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<SolidTBubbleEnrichedElement<3,NNODE_1D> >: 
 public virtual SolidTBubbleEnrichedElement<2,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : SolidTBubbleEnrichedElement<2,NNODE_1D>() {}

};

}




#endif
