// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2022 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header functions for classes that define Telements
#ifndef OOMPH_TELEMENT_HEADER
#define OOMPH_TELEMENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

// oomph-lib headers
#include "Vector.h"
#include "shape.h"
#include "integral.h"
#include "elements.h"

namespace oomph
{
  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////


  //===================================================
  /// Triangular Face class
  //===================================================
  class TFace
  {
  public:
    /// Constructor: Pass in the three vertex nodes
    TFace(Node* node1_pt, Node* node2_pt, Node* node3_pt)
    {
      if ((node1_pt == node2_pt) || (node2_pt == node3_pt) ||
          (node1_pt == node3_pt))
      {
#ifdef PARANOID
        std::ostringstream error_stream;
        error_stream << "TFace cannot have two identical vertex nodes\n";
        throw OomphLibError(
          error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
#endif
      }

      // Sort lexicographically based on pointer address of nodes
      std::set<Node*> nodes;
      nodes.insert(node1_pt);
      nodes.insert(node2_pt);
      nodes.insert(node3_pt);
      std::set<Node*>::iterator it = nodes.begin();
      Node1_pt = (*it);
      it++;
      Node2_pt = (*it);
      it++;
      Node3_pt = (*it);
      it++;
    }


    /// Access to the first vertex node
    Node* node1_pt() const
    {
      return Node1_pt;
    }

    /// Access to the second vertex node
    Node* node2_pt() const
    {
      return Node2_pt;
    }

    /// Access to the third vertex node
    Node* node3_pt() const
    {
      return Node3_pt;
    }

    /// Comparison operator
    bool operator==(const TFace& other) const
    {
      if ((Node1_pt == other.node1_pt()) && (Node2_pt == other.node2_pt()) &&
          (Node3_pt == other.node3_pt()))
      {
        return true;
      }
      else
      {
        return false;
      }
    }


    /// Less-than operator
    bool operator<(const TFace& other) const
    {
      if (Node1_pt < other.node1_pt())
      {
        return true;
      }
      else if (Node1_pt == other.node1_pt())
      {
        if (Node2_pt < other.node2_pt())
        {
          return true;
        }
        else if (Node2_pt == other.node2_pt())
        {
          if (Node3_pt < other.node3_pt())
          {
            return true;
          }
          else
          {
            return false;
          }
        }
        else
        {
          return false;
        }
      }
      else
      {
        return false;
      }
    }


    /// Test whether the face lies on a boundary. Relatively simple
    /// test, based on all vertices lying on (some) boundary.
    bool is_on_boundary() const
    {
      return (Node1_pt->is_on_boundary() && Node2_pt->is_on_boundary() &&
              Node3_pt->is_on_boundary());
    }


    /// Test whether the face is a boundary face, i.e. does it
    /// connnect three boundary nodes?
    bool is_boundary_face() const
    {
      return ((dynamic_cast<BoundaryNodeBase*>(Node1_pt) != 0) &&
              (dynamic_cast<BoundaryNodeBase*>(Node2_pt) != 0) &&
              (dynamic_cast<BoundaryNodeBase*>(Node3_pt) != 0));
    }

    /// Access to pointer to set of mesh boundaries that this
    /// face occupies; NULL if the node is not on any boundary.
    /// Construct via set intersection of the boundary sets for the
    /// associated vertex nodes
    void get_boundaries_pt(std::set<unsigned>*& boundaries_pt)
    {
      std::set<unsigned> set1;
      std::set<unsigned>* set1_pt = &set1;
      Node1_pt->get_boundaries_pt(set1_pt);
      std::set<unsigned> set2;
      std::set<unsigned>* set2_pt = &set2;
      Node2_pt->get_boundaries_pt(set2_pt);
      std::set<unsigned> set3;
      std::set<unsigned>* set3_pt = &set3;
      Node3_pt->get_boundaries_pt(set3_pt);
      std::set<unsigned> aux_set;
      set_intersection((*set1_pt).begin(),
                       (*set1_pt).end(),
                       (*set2_pt).begin(),
                       (*set2_pt).end(),
                       inserter(aux_set, aux_set.begin()));
      set_intersection(aux_set.begin(),
                       aux_set.end(),
                       (*set3_pt).begin(),
                       (*set3_pt).end(),
                       inserter((*boundaries_pt), (*boundaries_pt).begin()));
    }


  private:
    /// First vertex node
    Node* Node1_pt;

    /// Second vertex node
    Node* Node2_pt;

    /// Third vertex node
    Node* Node3_pt;
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //========================================================================
  /// A class for those member functions that must be fully specialised
  /// for the Telements. The fact that member functions of partially
  /// specialised classes cannot necessarily be fully specialised
  /// means that we must either fully specialise every class, or use this
  /// base class to fully specialize only those functions that are required.
  //========================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class TElementShape
  {
  };

  /// //////////////////////////////////////////////////////////////////////
  /// TElementShape inline functions:
  /// //////////////////////////////////////////////////////////////////////
  template<>
  class TElementShape<1, 2>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(1);
      switch (j)
      {
        case 0:
          s[0] = 0.0;
          break;

        case 1:
          s[0] = 1.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has two nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<1,2>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = 1.0 - s[0];
      psi[1] = s[0];
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<2,2>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      this->shape(s, psi);

      // Derivatives
      dpsids(0, 0) = -1.0;
      dpsids(1, 0) = 1.0;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<1,2>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      this->dshape_local(s, psi, dpsids);

      d2psids(0, 0) = 0.0;
      d2psids(1, 0) = 0.0;
    }
  };


  template<>
  class TElementShape<1, 3>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(1);
      switch (j)
      {
        case 0:
          s[0] = 0.0;
          break;

        case 1:
          s[0] = 0.5;
          break;

        case 2:
          s[0] = 1.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has three nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<1,3>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = 2.0 * (s[0] - 1.0) * (s[0] - 0.5);
      psi[1] = 4.0 * (1.0 - s[0]) * s[0];
      psi[2] = 2.0 * (s[0] - 0.5) * s[0];
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<1,3>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      dpsids(0, 0) = 4.0 * s[0] - 3.0;
      dpsids(1, 0) = 4.0 - 8.0 * s[0];
      dpsids(2, 0) = 4.0 * s[0] - 1.0;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<1,3>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      d2psids(0, 0) = 4.0;
      d2psids(1, 0) = -8.0;
      d2psids(2, 0) = 4.0;
    }
  };

  template<>
  class TElementShape<1, 4>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(1);
      switch (j)
      {
        case 0:
          s[0] = 0.0;
          break;

        case 1:
          s[0] = (1.0 / 3.0);
          break;

        case 2:
          s[0] = (2.0 / 3.0);
          break;

        case 3:
          s[0] = 1.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has four nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<1,4>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = 0.5 * (1.0 - s[0]) * (3.0 * s[0] - 2.0) * (3.0 * s[0] - 1.0);
      psi[1] = -4.5 * s[0] * (1.0 - s[0]) * (3.0 * s[0] - 2.0);
      psi[2] = 4.5 * s[0] * (1.0 - s[0]) * (3.0 * s[0] - 1.0);
      psi[3] = 0.5 * s[0] * (3.0 * s[0] - 2.0) * (3.0 * s[0] - 1.0);
    }

    //=======================================================================
    /// Derivatives of shape functions for specific TElement<1,4>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      dpsids(0, 0) = -13.5 * s[0] * s[0] + 18.0 * s[0] - 5.5;
      dpsids(1, 0) = 40.5 * s[0] * s[0] - 45.0 * s[0] + 9.0;
      dpsids(2, 0) = -40.5 * s[0] * s[0] + 36.0 * s[0] - 4.5;
      dpsids(3, 0) = 13.5 * s[0] * s[0] - 9.0 * s[0] + 1.0;
    }

    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<2,4>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      throw OomphLibError(
        "Not checked yet", OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);

      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      d2psids(0, 0) = 0.0;
      d2psids(1, 0) = 0.0;
      d2psids(2, 0) = 0.0;
      d2psids(3, 0) = 0.0;
    }
  };


  template<>
  class TElementShape<2, 2>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(2);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has three nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<2,2>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = s[0];
      psi[1] = s[1];
      psi[2] = 1.0 - s[0] - s[1];
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<2,2>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      this->shape(s, psi);

      // Derivatives
      dpsids(0, 0) = 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 1.0;
      dpsids(2, 0) = -1.0;
      dpsids(2, 1) = -1.0;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<2,2>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      this->dshape_local(s, psi, dpsids);

      for (unsigned i = 0; i < 3; i++)
      {
        d2psids(i, 0) = 0.0;
        d2psids(i, 1) = 0.0;
        d2psids(i, 2) = 0.0;
      }
    }
  };

  template<>
  class TElementShape<2, 3>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(2);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        case 3:
          s[0] = 0.5;
          s[1] = 0.5;
          break;

        case 4:
          s[0] = 0.0;
          s[1] = 0.5;
          break;

        case 5:
          s[0] = 0.5;
          s[1] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has six nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<2,3>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      // Reconstruct the third area coordinate
      double s_2 = 1.0 - s[0] - s[1];

      // note that s[2] needs replacing by s_2 everywhere since only
      // two independent variables s[0],s[1] and s_2 is expressed in terms of
      // those later.
      psi[0] = 2.0 * s[0] * (s[0] - 0.5);
      psi[1] = 2.0 * s[1] * (s[1] - 0.5);
      psi[2] = 2.0 * s_2 * (s_2 - 0.5);
      psi[3] = 4.0 * s[0] * s[1];
      psi[4] = 4.0 * s[1] * s_2;
      psi[5] = 4.0 * s_2 * s[0];
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<2,3>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      dpsids(0, 0) = 4.0 * s[0] - 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 4.0 * s[1] - 1.0;
      dpsids(2, 0) = 2.0 * (2.0 * s[0] - 1.5 + 2.0 * s[1]);
      dpsids(2, 1) = 2.0 * (2.0 * s[0] - 1.5 + 2.0 * s[1]);
      dpsids(3, 0) = 4.0 * s[1];
      dpsids(3, 1) = 4.0 * s[0];
      dpsids(4, 0) = -4.0 * s[1];
      dpsids(4, 1) = 4.0 * (1.0 - s[0] - 2.0 * s[1]);
      dpsids(5, 0) = 4.0 * (1.0 - 2.0 * s[0] - s[1]);
      dpsids(5, 1) = -4.0 * s[0];
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<2,3>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      d2psids(0, 0) = 4.0;
      d2psids(0, 1) = 0.0;
      d2psids(0, 2) = 0.0;

      d2psids(1, 0) = 0.0;
      d2psids(1, 1) = 4.0;
      d2psids(1, 2) = 0.0;

      d2psids(2, 0) = 4.0;
      d2psids(2, 1) = 4.0;
      d2psids(2, 2) = 4.0;

      d2psids(3, 0) = 0.0;
      d2psids(3, 1) = 0.0;
      d2psids(3, 2) = 4.0;

      d2psids(4, 0) = 0.0;
      d2psids(4, 1) = -8.0;
      d2psids(4, 2) = -4.0;

      d2psids(5, 0) = -8.0;
      d2psids(5, 1) = 0.0;
      d2psids(5, 2) = -4.0;
    }
  };

  template<>
  class TElementShape<2, 4>
  {
  public:
    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(2);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        case 3:
          s[0] = 2.0 / 3.0;
          s[1] = 1.0 / 3.0;
          break;

        case 4:
          s[0] = 1.0 / 3.0;
          s[1] = 2.0 / 3.0;
          break;

        case 5:
          s[0] = 0.0;
          s[1] = 2.0 / 3.0;
          break;

        case 6:
          s[0] = 0.0;
          s[1] = 1.0 / 3.0;
          break;

        case 8:
          s[0] = 2.0 / 3.0;
          s[1] = 0.0;
          break;

        case 7:
          s[0] = 1.0 / 3.0;
          s[1] = 0.0;
          break;

        case 9:
          s[0] = 1.0 / 3.0;
          s[1] = 1.0 / 3.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has ten nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<2,4>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = 0.5 * s[0] * (3.0 * s[0] - 2.0) * (3.0 * s[0] - 1.0);
      psi[1] = 0.5 * s[1] * (3.0 * s[1] - 2.0) * (3.0 * s[1] - 1.0);
      psi[2] = 0.5 * (1.0 - s[0] - s[1]) * (1.0 - 3.0 * s[0] - 3.0 * s[1]) *
               (2.0 - 3.0 * s[0] - 3.0 * s[1]);
      psi[3] = 4.5 * s[0] * s[1] * (3.0 * s[0] - 1.0);
      psi[4] = 4.5 * s[0] * s[1] * (3.0 * s[1] - 1.0);
      psi[5] = 4.5 * s[1] * (1.0 - s[0] - s[1]) * (3.0 * s[1] - 1.0);
      psi[6] =
        4.5 * s[1] * (1.0 - s[0] - s[1]) * (3.0 * (1.0 - s[0] - s[1]) - 1.0);
      psi[7] = 4.5 * s[0] * (1.0 - s[0] - s[1]) * (2.0 - 3 * s[0] - 3 * s[1]);
      psi[8] = 4.5 * s[0] * (1.0 - s[0] - s[1]) * (3.0 * s[0] - 1.0);
      psi[9] = 27.0 * s[0] * s[1] * (1.0 - s[0] - s[1]);
    }

    //=======================================================================
    /// Derivatives of shape functions for specific TElement<2,4>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      dpsids(0, 0) = 13.5 * s[0] * s[0] - 9.0 * s[0] + 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 13.5 * s[1] * s[1] - 9.0 * s[1] + 1.0;
      dpsids(2, 0) = 0.5 * (36.0 * s[0] + 36.0 * s[1] - 27.0 * s[0] * s[0] -
                            27.0 * s[1] * s[1] - 54.0 * s[0] * s[1] - 11.0);
      dpsids(2, 1) = 0.5 * (36.0 * s[0] + 36.0 * s[1] - 27.0 * s[0] * s[0] -
                            27.0 * s[1] * s[1] - 54.0 * s[0] * s[1] - 11.0);
      dpsids(3, 0) = 27.0 * s[0] * s[1] - 4.5 * s[1];
      dpsids(3, 1) = 4.5 * s[0] * (3.0 * s[0] - 1.0);
      dpsids(4, 0) = 4.5 * s[1] * (3.0 * s[1] - 1.0);
      dpsids(4, 1) = 27.0 * s[0] * s[1] - 4.5 * s[0];
      dpsids(5, 0) = 4.5 * (s[1] - 3.0 * s[1] * s[1]);
      dpsids(5, 1) =
        4.5 * (s[0] - 6.0 * s[0] * s[1] - 9.0 * s[1] * s[1] + 8 * s[1] - 1.0);
      dpsids(6, 0) = 4.5 * (6.0 * s[0] * s[1] - 5.0 * s[1] + 6.0 * s[1] * s[1]);
      dpsids(6, 1) =
        4.5 * (2.0 - 5.0 * s[0] + 3.0 * s[0] * s[0] + 12.0 * s[0] * s[1] -
               10.0 * s[1] + 9.0 * s[1] * s[1]);
      dpsids(7, 0) =
        4.5 * (2.0 - 10.0 * s[0] + 9.0 * s[0] * s[0] + 12.0 * s[0] * s[1] -
               5.0 * s[1] + 3.0 * s[1] * s[1]);
      dpsids(7, 1) = 4.5 * (6.0 * s[0] * s[0] - 5.0 * s[0] + 6.0 * s[0] * s[1]);
      dpsids(8, 0) =
        4.5 * (s[1] - 6.0 * s[0] * s[1] - 9.0 * s[0] * s[0] + 8 * s[0] - 1.0);
      dpsids(8, 1) = 4.5 * (s[0] - 3.0 * s[0] * s[0]);
      dpsids(9, 0) = 27.0 * s[1] - 54.0 * s[0] * s[1] - 27.0 * s[1] * s[1];
      dpsids(9, 1) = 27.0 * s[0] - 54.0 * s[0] * s[1] - 27.0 * s[0] * s[0];
    }

    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<2,4>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      throw OomphLibError(
        "Not checked yet", OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);

      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      d2psids(0, 0) = 9.0 * (3.0 * s[0] - 1.0);
      d2psids(0, 1) = 0.0;
      d2psids(0, 2) = 0.0;
      d2psids(1, 0) = 0.0;
      d2psids(1, 1) = 0.0;
      d2psids(1, 2) = 9.0 * (3.0 * s[1] - 1.0);
      d2psids(2, 0) = 9.0 * (2.0 - 3.0 * s[0] - 3.0 * s[1]);
      d2psids(2, 1) = 9.0 * (2.0 - 3.0 * s[0] - 3.0 * s[1]);
      d2psids(2, 2) = 9.0 * (2.0 - 3.0 * s[0] - 3.0 * s[1]);
      d2psids(3, 0) = 27.0 * s[1];
      d2psids(3, 1) = 0.0;
      d2psids(3, 2) = 27.0 * s[0] - 4.5;
      d2psids(4, 0) = 0.0;
      d2psids(4, 1) = 27.0 * s[0];
      d2psids(4, 2) = 27.0 * s[1] - 4.5;
      d2psids(5, 0) = 0.0;
      d2psids(5, 1) = 9.0 * (4.0 - 3.0 * s[0] - 9.0 * s[1]);
      d2psids(5, 2) = 4.5 * (1.0 - 6.0 * s[1]);
      d2psids(6, 0) = 27.0 * s[1];
      d2psids(6, 1) = 9.0 * (6.0 * s[0] + 9.0 * s[1] - 5.0);
      d2psids(6, 2) = 4.5 * (6.0 * s[0] + 12.0 * s[1] - 5.0);
      d2psids(8, 0) = 9.0 * (4.0 - 9.0 * s[0] - 3.0 * s[1]);
      d2psids(8, 1) = 0.0;
      d2psids(8, 2) = 4.5 * (1.0 - 6.0 * s[0]);
      d2psids(7, 0) = 9.0 * (9.0 * s[0] + 6.0 * s[1] - 5.0);
      d2psids(7, 1) = 27.0 * s[0];
      d2psids(7, 2) = 4.5 * (12.0 * s[0] + 6.0 * s[1] - 5.0);
      d2psids(9, 0) = -54.0 * s[1];
      d2psids(9, 1) = -54.0 * s[0];
      d2psids(9, 2) = 27.0 - 54.0 * s[0] - 54.0 * s[1];
    }
  };


  //========================================================================
  /// A class for those member functions that must be fully specialised
  /// for Telements that are enriched by bubbble functions.
  /// The fact that member functions of partially
  /// specialised classes cannot necessarily be fully specialised
  /// means that we must either fully specialise every class, or use this
  /// base class to fully specialize only those functions that are required.
  //========================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class TBubbleEnrichedElementShape
  {
  };


  /// ////////////////////////////////////////////////////////////////////
  /// Specific Enriched TElementShape inline functions
  /// ///////////////////////////////////////////////////////////////////

  //===============================================================
  /// Standard quadratic shape functions enriched by the addition
  /// of a cubic bubble, which consists of adding a single node
  /// at the centroid
  //=============================================================
  template<>
  class TBubbleEnrichedElementShape<2, 3>
  {
  public:
    //=====================================================================
    /// Return the number of nodes required for enrichement
    //====================================================================
    unsigned n_enriched_nodes()
    {
      return 1;
    }

    //=======================================================================
    /// Return local coordinates of node j
    //=======================================================================
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(2);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          break;

        case 3:
          s[0] = 0.5;
          s[1] = 0.5;
          break;

        case 4:
          s[0] = 0.0;
          s[1] = 0.5;
          break;

        case 5:
          s[0] = 0.5;
          s[1] = 0.0;
          break;

          // Add the centroid as the enriched node
        case 6:
          s[0] = 1.0 / 3.0;
          s[1] = 1.0 / 3.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has seven nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TBubbleEnrichedElement<2,3>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      // Reconstruct the third area coordinate
      const double s_2 = 1.0 - s[0] - s[1];

      // Calculate the enrichment function
      const double cubic_bubble = s[0] * s[1] * s_2;
      // The appropriate amount of the cubic bubble function is
      // added/subtracted to each original quadratic shape function to ensure
      // that it is zero at the centroid (1/3,1/3).

      // note that s[2] needs replacing by s_2 everywhere since only
      // two independent variables s[0],s[1] and s_2 is expressed in terms of
      // those later.
      psi[0] = 2.0 * s[0] * (s[0] - 0.5) + 3.0 * cubic_bubble;
      psi[1] = 2.0 * s[1] * (s[1] - 0.5) + 3.0 * cubic_bubble;
      psi[2] = 2.0 * s_2 * (s_2 - 0.5) + 3.0 * cubic_bubble;
      psi[3] = 4.0 * s[0] * s[1] - 12.0 * cubic_bubble;
      psi[4] = 4.0 * s[1] * s_2 - 12.0 * cubic_bubble;
      psi[5] = 4.0 * s_2 * s[0] - 12.0 * cubic_bubble;
      // The bubble function scaled to have magnitude one at (1/3,1/3)
      psi[6] = 27.0 * cubic_bubble;
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TBubbleElement<2,3>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      // Calculate derivatives of bubble functions
      const double d_bubble_ds0 = s[1] * (1.0 - s[1] - 2.0 * s[0]);
      const double d_bubble_ds1 = s[0] * (1.0 - s[0] - 2.0 * s[1]);

      // Add the appropriate derivatives to the shape functions
      dpsids(0, 0) = 4.0 * s[0] - 1.0 + 3.0 * d_bubble_ds0;
      dpsids(0, 1) = 0.0 + 3.0 * d_bubble_ds1;
      dpsids(1, 0) = 0.0 + 3.0 * d_bubble_ds0;
      dpsids(1, 1) = 4.0 * s[1] - 1.0 + 3.0 * d_bubble_ds1;
      dpsids(2, 0) = 2.0 * (2.0 * s[0] - 1.5 + 2.0 * s[1]) + 3.0 * d_bubble_ds0;
      dpsids(2, 1) = 2.0 * (2.0 * s[0] - 1.5 + 2.0 * s[1]) + 3.0 * d_bubble_ds1;
      dpsids(3, 0) = 4.0 * s[1] - 12.0 * d_bubble_ds0;
      dpsids(3, 1) = 4.0 * s[0] - 12.0 * d_bubble_ds1;
      dpsids(4, 0) = -4.0 * s[1] - 12.0 * d_bubble_ds0;
      dpsids(4, 1) = 4.0 * (1.0 - s[0] - 2.0 * s[1]) - 12.0 * d_bubble_ds1;
      dpsids(5, 0) = 4.0 * (1.0 - 2.0 * s[0] - s[1]) - 12.0 * d_bubble_ds0;
      dpsids(5, 1) = -4.0 * s[0] - 12.0 * d_bubble_ds1;
      dpsids(6, 0) = 27.0 * d_bubble_ds0;
      dpsids(6, 1) = 27.0 * d_bubble_ds1;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific
    /// TBubbleElement<2,3>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      // Calculate derivatives of bubble functions
      const double d2_bubble_ds0 = -2.0 * s[1];
      const double d2_bubble_ds1 = -2.0 * s[0];
      const double d2_bubble_ds2 = 1.0 - 2.0 * s[0] - 2.0 * s[1];

      d2psids(0, 0) = 4.0 + 3.0 * d2_bubble_ds0;
      d2psids(0, 1) = 0.0 + 3.0 * d2_bubble_ds1;
      d2psids(0, 2) = 0.0 + 3.0 * d2_bubble_ds2;

      d2psids(1, 0) = 0.0 + 3.0 * d2_bubble_ds0;
      d2psids(1, 1) = 4.0 + 3.0 * d2_bubble_ds1;
      d2psids(1, 2) = 0.0 + 3.0 * d2_bubble_ds2;

      d2psids(2, 0) = 4.0 + 3.0 * d2_bubble_ds0;
      d2psids(2, 1) = 4.0 + 3.0 * d2_bubble_ds1;
      d2psids(2, 2) = 4.0 + 3.0 * d2_bubble_ds2;

      d2psids(3, 0) = 0.0 - 12.0 * d2_bubble_ds0;
      d2psids(3, 1) = 0.0 - 12.0 * d2_bubble_ds1;
      d2psids(3, 2) = 4.0 - 12.0 * d2_bubble_ds2;

      d2psids(4, 0) = 0.0 - 12.0 * d2_bubble_ds0;
      d2psids(4, 1) = -8.0 - 12.0 * d2_bubble_ds1;
      d2psids(4, 2) = -4.0 - 12.0 * d2_bubble_ds2;

      d2psids(5, 0) = -8.0 - 12.0 * d2_bubble_ds0;
      d2psids(5, 1) = 0.0 - 12.0 * d2_bubble_ds1;
      d2psids(5, 2) = -4.0 - 12.0 * d2_bubble_ds2;

      d2psids(6, 0) = 27.0 * d2_bubble_ds0;
      d2psids(6, 1) = 27.0 * d2_bubble_ds1;
      d2psids(6, 2) = 27.0 * d2_bubble_ds2;
    }
  };

  /// ///////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////

  //========================================================================
  /// Empty base class for Telements (created so that
  /// we can use dynamic_cast<>() to figure out if a an element
  /// is a Telement (from a purely geometric point of view).
  //========================================================================
  class TElementGeometricBase : public virtual FiniteElement
  {
  public:
    /// Empty default constructor
    TElementGeometricBase() {}

    /// Broken copy constructor
    TElementGeometricBase(const TElementGeometricBase&) = delete;

    /// Broken assignment operator
    // Commented out broken assignment operator because this can lead to a
    // conflict warning when used in the virtual inheritence hierarchy.
    // Essentially the compiler doesn't realise that two separate
    // implementations of the broken function are the same and so, quite
    // rightly, it shouts.
    /*void operator=(const TElementGeometricBase&) = delete;*/
  };


  /// ///////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////

  //========================================================================
  /// Empty base class for Telements (created so that
  /// we can use dynamic_cast<>() to figure out if a an element
  /// is a Telement).
  //========================================================================
  class TElementBase : public virtual TElementGeometricBase
  {
  public:
    /// Empty default constructor
    TElementBase() {}

    /// Broken copy constructor
    TElementBase(const TElementBase&) = delete;

    /// Broken assignment operator
    /*void operator=(const TElementBase&) = delete;*/

    /// It's a T element!
    ElementGeometry::ElementGeometry element_geometry() const
    {
      return ElementGeometry::T;
    }

    /// Check whether the local coordinates are valid or not
    bool local_coord_is_valid(const Vector<double>& s)
    {
      // Check coordinates
      unsigned ncoord = dim();
      double sum = 0.0;
      for (unsigned i = 0; i < ncoord; i++)
      {
        // Each local coordinate must be positive
        if (s[i] < 0.0)
        {
          return false;
        }
        sum += s[i];
      }

      // Sum must be less than 1
      if (sum <= 1.0)
      {
        return true;
      }

      // We're outside...
      return false;
    }

    /// Adjust local coordinates so that they're located inside
    /// the element
    void move_local_coord_back_into_element(Vector<double>& s) const
    {
      // Check coordinates
      unsigned ncoord = dim();
      double sum = 0.0;
      for (unsigned i = 0; i < ncoord; i++)
      {
        // Each coordinate must be positive individually
        if (s[i] < 0.0) s[i] = 0.0;
        sum += s[i];
      }

      // Sum must be less than 1
      double excess = sum - 1.0;
      if (excess > 0.0)
      {
        // Subtract excess equally from all coordinates
        double sub = excess / double(ncoord);
        for (unsigned i = 0; i < ncoord; i++)
        {
          s[i] -= sub;
        }
      }
    }
  };

  //=======================================================================
  /// General TElement class
  ///
  /// Empty, just establishes the template parameters
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class TElement
  {
  };


  //=======================================================================
  /// General TElement class specialised to one spatial dimensions
  /// Ordering of nodes is 0 at local coordinate s[0] = 0, 1 at local
  /// coordinate s[0] = 1 and then filling in the intermediate values
  /// from s[0]=0 to 1.
  //=======================================================================
  template<unsigned NNODE_1D>
  class TElement<1, NNODE_1D> : public virtual TElementBase,
                                public TElementShape<1, NNODE_1D>
  {
  private:
    /// Default integration rule: Gaussian integration of same 'order' as
    /// the element
    // This is sort of optimal, because it means that the integration is exact
    // for the shape functions. Can overwrite this in specific element
    // defintion.
    static TGauss<1, NNODE_1D> Default_integration_scheme;

  public:
    /// Constructor
    TElement()
    {
      // Number of nodes
      switch (NNODE_1D)
      {
        case 2:
        case 3:
        case 4:
          break;

        default:
          std::string error_message =
            "One-dimensional TElements are currently only implemented for\n";
          error_message += "three and six nodes, i.e. NNODE_1D=2 , 3 , 4\n";

          throw OomphLibError(
            error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }

      // Set the number of nodes
      unsigned n_node = NNODE_1D;
      this->set_n_node(n_node);

      // Set the elemental and nodal dimension
      set_dimension(1);

      // Assign default (full) spatial integration scheme
      set_integration_scheme(&Default_integration_scheme);
    }


    /// Broken copy constructor
    TElement(const TElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const TElement&) = delete;*/


    /// Destructor
    ~TElement() {}

    /// Number of nodes along each element edge
    unsigned nnode_1d() const
    {
      return NNODE_1D;
    }


    /// Number of vertex nodes in the element: One more
    /// than spatial dimension
    unsigned nvertex_node() const
    {
      return 2;
    }

    /// Pointer to the j-th vertex node in the element
    Node* vertex_node_pt(const unsigned& j) const
    {
      switch (j)
      {
        case 0:

          return node_pt(0);
          break;

        case 1:

          return node_pt(NNODE_1D - 1);
          break;

        default:

          std::ostringstream error_message;
          error_message
            << "Element only has two vertex nodes; called with node number "
            << j << std::endl;
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }

    /// Calculate the geometric shape functions at local coordinate s
    inline void shape(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<1, NNODE_1D>::shape(s, psi);
    }

    /// Compute the  geometric shape functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dshape_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids) const
    {
      TElementShape<1, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// Compute the geometric shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    inline void d2shape_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids,
                              DShape& d2psids) const
    {
      TElementShape<1, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }

    /// Overload the template-free interface for the calculation of
    /// inverse jacobian matrix. This is a one dimensional element, so use
    /// the 1D version.
    double invert_jacobian_mapping(const DenseMatrix<double>& jacobian,
                                   DenseMatrix<double>& inverse_jacobian) const
    {
      return FiniteElement::invert_jacobian<1>(jacobian, inverse_jacobian);
    }

    /// Min. value of local coordinate
    double s_min() const
    {
      return 0.0;
    }

    /// Max. value of local coordinate
    double s_max() const
    {
      return 1.0;
    }

    /// Return local coordinates of node j
    inline void local_coordinate_of_node(const unsigned& j,
                                         Vector<double>& s) const
    {
      TElementShape<1, NNODE_1D>::local_coordinate_of_node(j, s);
    }

    /// Return the number of actual plot points for paraview
    /// plot with parameter nplot.
    unsigned nplot_points_paraview(const unsigned& nplot) const
    {
      return nplot;
    }

    /// Return the number of local sub-elements for paraview plot with
    /// parameter nplot.
    unsigned nsub_elements_paraview(const unsigned& nplot) const
    {
      return (nplot - 1);
    }

    /// Fill in the offset information for paraview plot.
    /// Needs to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_output_offset_information(std::ofstream& file_out,
                                                  const unsigned& nplot,
                                                  unsigned& counter) const
    {
      // Number of local elements we want to plot over
      unsigned plot = nsub_elements_paraview(nplot);

      // loops over the i-th local element in parent element
      for (unsigned i = 0; i < plot; i++)
      {
        file_out << i + counter << " " << i + 1 + counter << std::endl;
      }
      counter += nplot_points_paraview(nplot);
    }

    /// Return the paraview element type.
    /// Needs to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_type(std::ofstream& file_out,
                             const unsigned& nplot) const
    {
      unsigned local_loop = nsub_elements_paraview(nplot);
      for (unsigned i = 0; i < local_loop; i++)
      {
        file_out << "3" << std::endl;
      }
    }

    /// Return the offsets for the paraview sub-elements. Needs
    /// to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_offsets(std::ofstream& file_out,
                                const unsigned& nplot,
                                unsigned& offset_sum) const
    {
      // Loop over all local elements and add its offset to the overall
      // offset_sum
      unsigned local_loop = nsub_elements_paraview(nplot);
      for (unsigned i = 0; i < local_loop; i++)
      {
        offset_sum += 2;
        file_out << offset_sum << std::endl;
      }
    }

    /// Output
    void output(std::ostream& output);

    /// Output at specified number of plot points
    void output(std::ostream& outfile, const unsigned& nplot);

    /// C-style output
    void output(FILE* file_pt);

    /// C_style output at n_plot points
    void output(FILE* file_pt, const unsigned& n_plot);

    ///  Get vector of local coordinates of plot point i (when plotting
    /// nplot points in each "coordinate direction").
    void get_s_plot(
      const unsigned& i,
      const unsigned& nplot,
      Vector<double>& s,
      const bool& use_equally_spaced_interior_sample_points = false) const
    {
      if (nplot > 1)
      {
        s[0] = double(i) / double(nplot - 1);

        if (use_equally_spaced_interior_sample_points)
        {
          double range = 1.0;
          double dx_new = range / double(nplot);
          double range_new = double(nplot - 1) * dx_new;
          s[0] = 0.5 * dx_new + range_new * s[0] / range;
        }
      }
      else
      {
        s[0] = 0.5;
      }
    }

    /// Return string for tecplot zone header (when plotting
    /// nplot points in each "coordinate direction)
    std::string tecplot_zone_string(const unsigned& nplot) const
    {
      std::ostringstream header;
      header << "ZONE I=" << nplot << "\n";
      return header.str();
    }

    /// Return total number of plot points (when plotting
    /// nplot points in each "coordinate direction)
    unsigned nplot_points(const unsigned& nplot) const
    {
      return nplot;
    }

    /// Build the lower-dimensional FaceElement (an element of type
    /// PointElement).  The face index takes two values
    /// corresponding to the two possible faces:
    /// -1 (Left)  s[0] = -1.0
    /// +1 (Right) s[0] =  1.0
    void build_face_element(const int& face_index,
                            FaceElement* face_element_pt);
  };


  //=======================================================================
  /// General TElement class specialised to two spatial dimensions
  /// Ordering of nodes as in Zienkiwizc sketches: vertex nodes
  /// 0 - 1 - 2 anticlockwise. Midside nodes filled in progressing
  /// along the consecutive edges. Central node(s) come(s) last.
  //=======================================================================
  template<unsigned NNODE_1D>
  class TElement<2, NNODE_1D> : public virtual TElementBase,
                                public TElementShape<2, NNODE_1D>
  {
  private:
    /// Nodal translation scheme for use when generating face elements
    static const unsigned Node_on_face[3][NNODE_1D];

    /// Default integration rule: Gaussian integration of same 'order' as
    /// the element
    // This is sort of optimal, because it means that the integration is exact
    // for the shape functions. Can overwrite this in specific element
    // defintion.
    static TGauss<2, NNODE_1D> Default_integration_scheme;


  public:
    /// Constructor
    TElement()
    {
      // Number of nodes
      switch (NNODE_1D)
      {
        case 2:
        case 3:
        case 4:
          break;

        default:
          std::string error_message =
            "Triangles are currently only implemented for\n";
          error_message += "three and six nodes, i.e. NNODE_1D=2 , 3 , 4\n";

          throw OomphLibError(
            error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }

      // Set the number of nodes
      unsigned n_node = (NNODE_1D * (NNODE_1D + 1)) / 2;
      this->set_n_node(n_node);

      // Set the elemental and nodal dimension
      set_dimension(2);

      // Assign default (full) spatial integration scheme
      set_integration_scheme(&Default_integration_scheme);
    }

    /// Alternative constructor
    TElement(const bool& allow_high_order)
    {
      // Check if we are overriding the restriction on NNODE_1D
      if (!allow_high_order)
      {
        // Call the default constructor
        TElement<2, NNODE_1D>();
      }
      else
      {
        // Set the number of nodes
        unsigned n_node = (NNODE_1D * (NNODE_1D + 1)) / 2;
        this->set_n_node(n_node);

        // Set the elemental and nodal dimension
        set_dimension(2);

        // Assign default (full) spatial integration scheme
        set_integration_scheme(&Default_integration_scheme);
      }
    }


    /// Broken copy constructor
    TElement(const TElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const TElement&) = delete;*/


    /// Destructor
    ~TElement() {}

    /// Number of nodes along each element edge
    unsigned nnode_1d() const
    {
      return NNODE_1D;
    }

    /// Number of vertex nodes in the element: One more
    /// than spatial dimension
    unsigned nvertex_node() const
    {
      return 3;
    }

    /// Public access function for Node_on_face.
    unsigned get_bulk_node_number(const int& face_index,
                                  const unsigned& i) const
    {
      return Node_on_face[face_index][i];
    }

    /// Pointer to the j-th vertex node in the element
    Node* vertex_node_pt(const unsigned& j) const
    {
      // Vertex nodes come first:
#ifdef PARANOID
      if (j > 2)
      {
        std::ostringstream error_message;
        error_message
          << "Element only has three vertex nodes; called with node number "
          << j << std::endl;
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
      return node_pt(j);
    }

    /// Calculate the geometric shape functions at local coordinate s
    inline void shape(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<2, NNODE_1D>::shape(s, psi);
    }

    /// Compute the  geometric shape functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dshape_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids) const
    {
      TElementShape<2, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// Compute the geometric shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    inline void d2shape_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids,
                              DShape& d2psids) const
    {
      TElementShape<2, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }

    /// Overload the template-free interface for the calculation of
    /// inverse jacobian matrix. This is a two dimensional element, so use
    /// the 2D version.
    double invert_jacobian_mapping(const DenseMatrix<double>& jacobian,
                                   DenseMatrix<double>& inverse_jacobian) const
    {
      return FiniteElement::invert_jacobian<2>(jacobian, inverse_jacobian);
    }

    /// Min. value of local coordinate
    double s_min() const
    {
      return 0.0;
    }

    /// Max. value of local coordinate
    double s_max() const
    {
      return 1.0;
    }

    /// Return local coordinates of node j
    inline void local_coordinate_of_node(const unsigned& j,
                                         Vector<double>& s) const
    {
      TElementShape<2, NNODE_1D>::local_coordinate_of_node(j, s);
    }

    /// Return the number of actual plot points for paraview
    /// plot with parameter nplot.
    unsigned nplot_points_paraview(const unsigned& nplot) const
    {
      unsigned node_sum = 0;
      for (unsigned i = 1; i <= nplot; i++)
      {
        node_sum += i;
      }
      return node_sum;
    }

    /// Return the number of local sub-elements for paraview plot with
    /// parameter nplot.
    unsigned nsub_elements_paraview(const unsigned& nplot) const
    {
      unsigned local_sum = 0;
      for (unsigned i = 1; i < nplot; i++)
      {
        local_sum += 2 * (nplot - i - 1) + 1;
      }
      return local_sum;
    }

    /// Fill in the offset information for paraview plot.
    /// Needs to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_output_offset_information(std::ofstream& file_out,
                                                  const unsigned& nplot,
                                                  unsigned& counter) const
    {
      // Outputs list of connectivity of Paraview elements,
      // whilst remembering the overall ordering

      unsigned node_count = 0;
      for (unsigned i = 0; i < nplot - 1; i++)
      {
        for (unsigned j = 0; j < nplot - i - 1; j++)
        {
          file_out << j + node_count + counter << " "
                   << j + node_count + 1 + counter << " "
                   << j + nplot + node_count - i + counter << std::endl;

          if (j < nplot - i - 2)
          {
            file_out << j + node_count + 1 + counter << " "
                     << j + nplot + node_count - i + 1 + counter << " "
                     << j + nplot + node_count - i + counter << std::endl;
          }
        }
        node_count += (nplot - i);
      }
      counter += nplot_points_paraview(nplot);
    }

    /// Return the paraview element type.
    /// Needs to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_type(std::ofstream& file_out,
                             const unsigned& nplot) const
    {
      unsigned local_loop = nsub_elements_paraview(nplot);

      // Loop over all the local elements and print its paraview type
      for (unsigned i = 0; i < local_loop; i++)
      {
        file_out << "5" << std::endl;
      }
    }

    /// Return the offsets for the paraview sub-elements. Needs
    /// to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_offsets(std::ofstream& file_out,
                                const unsigned& nplot,
                                unsigned& offset_sum) const
    {
      unsigned local_loop = nsub_elements_paraview(nplot);

      // Loop over all local elements and add its offset to the overall
      // offset_sum
      for (unsigned i = 0; i < local_loop; i++)
      {
        offset_sum += 3;
        file_out << offset_sum << std::endl;
      }
    }

    /// Output
    void output(std::ostream& output);

    /// Output at specified number of plot points
    void output(std::ostream& outfile, const unsigned& nplot);

    /// C-style output
    void output(FILE* file_pt);

    /// C_style output at n_plot points
    void output(FILE* file_pt, const unsigned& n_plot);

    ///  Get vector of local coordinates of plot point i (when plotting
    /// nplot points in each "coordinate direction").
    void get_s_plot(
      const unsigned& iplot,
      const unsigned& nplot,
      Vector<double>& s,
      const bool& use_equally_spaced_interior_sample_points = false) const
    {
      if (nplot > 1)
      {
        unsigned np = 0, i, j;
        for (i = 0; i < nplot; ++i)
        {
          for (j = 0; j < nplot - i; ++j)
          {
            if (np == iplot)
            {
              s[0] = double(j) / double(nplot - 1);
              s[1] = double(i) / double(nplot - 1);
              if (use_equally_spaced_interior_sample_points)
              {
                double range = 1.0;
                double dx_new = range / (double(nplot) + 0.5);
                double range_new = double(nplot - 1) * dx_new;
                s[0] = 0.5 * dx_new + range_new * s[0] / range;
                s[1] = 0.5 * dx_new + range_new * s[1] / range;
              }
              return;
            }
            ++np;
          }
        }
      }
      else
      {
        s[0] = 1.0 / 3.0;
        s[1] = 1.0 / 3.0;
      }
    }

    /// Return string for tecplot zone header (when plotting
    /// nplot points in each "coordinate direction)
    std::string tecplot_zone_string(const unsigned& nplot) const
    {
      std::ostringstream header;
      unsigned nel = 0;
      for (unsigned i = 1; i < nplot; i++)
      {
        nel += 2 * i - 1;
      }
      header << "ZONE N=" << nplot_points(nplot) << ", E=" << nel
             << ", F=FEPOINT, ET=TRIANGLE\n";
      return header.str();
    }

    /// Add tecplot zone "footer" to output stream (when plotting
    /// nplot points in each "coordinate direction).
    /// Empty by default -- can be used, e.g., to add FE connectivity
    /// lists to elements that need it.
    void write_tecplot_zone_footer(std::ostream& outfile,
                                   const unsigned& nplot) const
    {
      // Output node lists for sub elements for Tecplot (node index
      // must start at 1)
      unsigned nod_count = 1;
      for (unsigned i = 0; i < nplot; i++)
      {
        for (unsigned j = 0; j < nplot - i; j++)
        {
          if (j < nplot - i - 1)
          {
            outfile << nod_count << " " << nod_count + 1 << " "
                    << nod_count + nplot - i << std::endl;
            if (j < nplot - i - 2)
            {
              outfile << nod_count + 1 << " " << nod_count + nplot - i + 1
                      << " " << nod_count + nplot - i << std::endl;
            }
          }
          ++nod_count;
        }
      }
    }

    /// Add tecplot zone "footer" to C-style output. (when plotting
    /// nplot points in each "coordinate direction).
    /// Empty by default -- can be used, e.g., to add FE connectivity
    /// lists to elements that need it.
    void write_tecplot_zone_footer(FILE* file_pt, const unsigned& nplot) const
    {
      // Output node lists for sub elements for Tecplot (node index
      // must start at 1)
      unsigned nod_count = 1;
      for (unsigned i = 0; i < nplot; i++)
      {
        for (unsigned j = 0; j < nplot - i; j++)
        {
          if (j < nplot - i - 1)
          {
            fprintf(file_pt,
                    "%i %i %i \n",
                    nod_count,
                    nod_count + 1,
                    nod_count + nplot - i);
            if (j < nplot - i - 2)
            {
              fprintf(file_pt,
                      "%i %i %i \n",
                      nod_count + 1,
                      nod_count + nplot - i + 1,
                      nod_count + nplot - i);
            }
          }
          ++nod_count;
        }
      }
    }

    /// Return total number of plot points (when plotting
    /// nplot points in each "coordinate direction)
    unsigned nplot_points(const unsigned& nplot) const
    {
      unsigned np = 0;
      for (unsigned i = 1; i <= nplot; i++)
      {
        np += i;
      }
      return np;
    }


    /// Build the lower-dimensional FaceElement (an element of type
    /// TElement<1,NNODE_1D>). The face index takes three possible values:
    /// 0 (Left)         s[0] = 0.0
    /// 1 (Bottom)       s[1] = 0.0
    /// 2 (Sloping face) s[0] = 1.0 - s[1]
    void build_face_element(const int& face_index,
                            FaceElement* face_element_pt);
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Return local coordinates of node j
  //=======================================================================
  template<>
  class TElementShape<3, 2>
  {
  public:
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(3);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          s[2] = 0.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 1.0;
          break;

        case 3:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has four nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<3,2>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      psi[0] = s[0];
      psi[1] = s[1];
      psi[2] = s[2];
      psi[3] = 1.0 - s[0] - s[1] - s[2];
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<3,2>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      // Derivatives
      dpsids(0, 0) = 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(0, 2) = 0.0;

      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 1.0;
      dpsids(1, 2) = 0.0;

      dpsids(2, 0) = 0.0;
      dpsids(2, 1) = 0.0;
      dpsids(2, 2) = 1.0;

      dpsids(3, 0) = -1.0;
      dpsids(3, 1) = -1.0;
      dpsids(3, 2) = -1.0;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<3,2>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$
    /// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    /// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$
    /// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      for (unsigned i = 0; i < 4; i++)
      {
        d2psids(i, 0) = 0.0;
        d2psids(i, 1) = 0.0;
        d2psids(i, 2) = 0.0;
        d2psids(i, 3) = 0.0;
        d2psids(i, 4) = 0.0;
        d2psids(i, 5) = 0.0;
      }
    }
  };


  //=======================================================================
  /// Return local coordinates of node j
  //=======================================================================
  template<>
  class TElementShape<3, 3>
  {
  public:
    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(3);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          s[2] = 0.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 1.0;
          break;

        case 3:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 4:
          s[0] = 0.5;
          s[1] = 0.5;
          s[2] = 0.0;
          break;

        case 5:
          s[0] = 0.5;
          s[1] = 0.0;
          s[2] = 0.5;
          break;

        case 6:
          s[0] = 0.5;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 7:
          s[0] = 0.0;
          s[1] = 0.5;
          s[2] = 0.5;
          break;

        case 8:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 0.5;
          break;

        case 9:
          s[0] = 0.0;
          s[1] = 0.5;
          s[2] = 0.0;
          break;

        default:
          std::ostringstream error_message;
          error_message
            << "Element only has ten nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TElement<3,3>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      double s3 = 1.0 - s[0] - s[1] - s[2];
      psi[0] = (2.0 * s[0] - 1.0) * s[0];
      psi[1] = (2.0 * s[1] - 1.0) * s[1];
      psi[2] = (2.0 * s[2] - 1.0) * s[2];
      psi[3] = (2.0 * s3 - 1.0) * s3;
      psi[4] = 4.0 * s[0] * s[1];
      psi[5] = 4.0 * s[0] * s[2];
      psi[6] = 4.0 * s[0] * s3;
      psi[7] = 4.0 * s[1] * s[2];
      psi[8] = 4.0 * s[2] * s3;
      psi[9] = 4.0 * s[1] * s3;
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<3,3>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      // Derivatives
      double s3 = 1.0 - s[0] - s[1] - s[2];

      dpsids(0, 0) = 4.0 * s[0] - 1.0;
      dpsids(0, 1) = 0.0;
      dpsids(0, 2) = 0.0;

      dpsids(1, 0) = 0.0;
      dpsids(1, 1) = 4.0 * s[1] - 1.0;
      dpsids(1, 2) = 0.0;

      dpsids(2, 0) = 0.0;
      dpsids(2, 1) = 0.0;
      dpsids(2, 2) = 4.0 * s[2] - 1.0;

      dpsids(3, 0) = -4.0 * s3 + 1.0;
      dpsids(3, 1) = -4.0 * s3 + 1.0;
      dpsids(3, 2) = -4.0 * s3 + 1.0;

      dpsids(4, 0) = 4.0 * s[1];
      dpsids(4, 1) = 4.0 * s[0];
      dpsids(4, 2) = 0.0;

      dpsids(5, 0) = 4.0 * s[2];
      dpsids(5, 1) = 0.0;
      dpsids(5, 2) = 4.0 * s[0];

      dpsids(6, 0) = 4.0 * (s3 - s[0]);
      dpsids(6, 1) = -4.0 * s[0];
      dpsids(6, 2) = -4.0 * s[0];

      dpsids(7, 0) = 0.0;
      dpsids(7, 1) = 4.0 * s[2];
      dpsids(7, 2) = 4.0 * s[1];

      dpsids(8, 0) = -4.0 * s[2];
      dpsids(8, 1) = -4.0 * s[2];
      dpsids(8, 2) = 4.0 * (s3 - s[2]);

      dpsids(9, 0) = -4.0 * s[1];
      dpsids(9, 1) = 4.0 * (s3 - s[1]);
      dpsids(9, 2) = -4.0 * s[1];
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<3,3>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$
    /// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    /// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$
    /// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      //(.,3) for mixed derivative s[0]-s[1]
      //(.,4) for mixed derivative s[0]-s[2]
      //(.,5) for mixed derivative s[1]-s[2]

      d2psids(0, 0) = 4.0;
      d2psids(0, 1) = 0.0;
      d2psids(0, 2) = 0.0;
      d2psids(0, 3) = 0.0;
      d2psids(0, 4) = 0.0;
      d2psids(0, 5) = 0.0;


      d2psids(1, 0) = 0.0;
      d2psids(1, 1) = 4.0;
      d2psids(1, 2) = 0.0;
      d2psids(1, 3) = 0.0;
      d2psids(1, 4) = 0.0;
      d2psids(1, 5) = 0.0;

      d2psids(2, 0) = 0.0;
      d2psids(2, 1) = 0.0;
      d2psids(2, 2) = 4.0;
      d2psids(2, 3) = 0.0;
      d2psids(2, 4) = 0.0;
      d2psids(2, 5) = 0.0;

      d2psids(3, 0) = 4.0;
      d2psids(3, 1) = 4.0;
      d2psids(3, 2) = 4.0;
      d2psids(3, 3) = 4.0;
      d2psids(3, 4) = 4.0;
      d2psids(3, 5) = 4.0;

      d2psids(4, 0) = 0.0;
      d2psids(4, 1) = 0.0;
      d2psids(4, 2) = 0.0;
      d2psids(4, 3) = 4.0;
      d2psids(4, 4) = 0.0;
      d2psids(4, 5) = 0.0;

      d2psids(5, 0) = 0.0;
      d2psids(5, 1) = 0.0;
      d2psids(5, 2) = 0.0;
      d2psids(5, 3) = 0.0;
      d2psids(5, 4) = 4.0;
      d2psids(5, 5) = 0.0;

      d2psids(6, 0) = -8.0;
      d2psids(6, 1) = 0.0;
      d2psids(6, 2) = 0.0;
      d2psids(6, 3) = -4.0;
      d2psids(6, 4) = -4.0;
      d2psids(6, 5) = 0.0;

      d2psids(7, 0) = 0.0;
      d2psids(7, 1) = 0.0;
      d2psids(7, 2) = 0.0;
      d2psids(7, 3) = 0.0;
      d2psids(7, 4) = 0.0;
      d2psids(7, 5) = 4.0;

      d2psids(8, 0) = 0.0;
      d2psids(8, 1) = 0.0;
      d2psids(8, 2) = -8.0;
      d2psids(8, 3) = 0.0;
      d2psids(8, 4) = -4.0;
      d2psids(8, 5) = -4.0;

      d2psids(9, 0) = 0.0;
      d2psids(9, 1) = -8.0;
      d2psids(9, 2) = 0.0;
      d2psids(9, 3) = -4.0;
      d2psids(9, 4) = 0.0;
      d2psids(9, 5) = -4.0;
    }
  };

  /// ///////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////

  //====================================================================
  /// Standard quadratic shape functions enriched by the addition of
  /// three cubic "face" bubbles and quartic "volume" bubble,
  /// which consists of adding a node at the centroid of
  /// each face and a single node at the centroid
  /// of the tetrahedron
  //=========================================================================

  //=======================================================================
  /// Return local coordinates of node j
  //=======================================================================
  template<>
  class TBubbleEnrichedElementShape<3, 3>
  {
  public:
    unsigned n_enriched_nodes()
    {
      return 5;
    }

    void local_coordinate_of_node(const unsigned& j, Vector<double>& s) const
    {
      s.resize(3);

      switch (j)
      {
        case 0:
          s[0] = 1.0;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 1:
          s[0] = 0.0;
          s[1] = 1.0;
          s[2] = 0.0;
          break;

        case 2:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 1.0;
          break;

        case 3:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 4:
          s[0] = 0.5;
          s[1] = 0.5;
          s[2] = 0.0;
          break;

        case 5:
          s[0] = 0.5;
          s[1] = 0.0;
          s[2] = 0.5;
          break;

        case 6:
          s[0] = 0.5;
          s[1] = 0.0;
          s[2] = 0.0;
          break;

        case 7:
          s[0] = 0.0;
          s[1] = 0.5;
          s[2] = 0.5;
          break;

        case 8:
          s[0] = 0.0;
          s[1] = 0.0;
          s[2] = 0.5;
          break;

        case 9:
          s[0] = 0.0;
          s[1] = 0.5;
          s[2] = 0.0;
          break;

          // Node at centroid of face spanned by nodes 0, 1, 3
        case 10:
          s[0] = 1.0 / 3.0;
          s[1] = 1.0 / 3.0;
          s[2] = 0.0;
          break;

          // Node at centroid of face spanned by nodes 0, 1, 2
        case 11:
          s[0] = 1.0 / 3.0;
          s[1] = 1.0 / 3.0;
          s[2] = 1.0 / 3.0;
          break;

          // Node at centroid of face spanned by nodes 0, 2, 3
        case 12:
          s[0] = 1.0 / 3.0;
          s[1] = 0.0;
          s[2] = 1.0 / 3.0;
          break;

          // Node at centroid of face spannd by nodes 1, 2, 3
        case 13:
          s[0] = 0.0;
          s[1] = 1.0 / 3.0;
          s[2] = 1.0 / 3.0;
          break;

          // Node at centroid of volume
        case 14:
          s[0] = 0.25;
          s[1] = 0.25;
          s[2] = 0.25;
          break;


        default:
          std::ostringstream error_message;
          error_message
            << "Element only has fifteen nodes; called with node number " << j
            << std::endl;

          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
      }
    }


    //=======================================================================
    /// Shape function for specific TBubbleEnrichedElement<3,3>
    //=======================================================================
    void shape(const Vector<double>& s, Shape& psi) const
    {
      // Constructe the fourth volume coordinate
      const double s3 = 1.0 - s[0] - s[1] - s[2];
      // calculate the enrichment functions
      const double quartic_bubble = s[0] * s[1] * s[2] * s3;
      const double cubic_bubble012 = s[0] * s[1] * s[2];
      const double cubic_bubble013 = s[0] * s[1] * s3;
      const double cubic_bubble023 = s[0] * s[2] * s3;
      const double cubic_bubble123 = s[1] * s[2] * s3;

      // The appropriate "amount" of cubic and quartic bubble functions are
      // added/subtracted
      // to each original quadratic shape function to ensure that the new
      // shape function is zero at the centroid (0.25,0.25,0.25)
      // and at the face centroids
      psi[0] = (2.0 * s[0] - 1.0) * s[0] +
               3.0 * (cubic_bubble012 + cubic_bubble013 + cubic_bubble023) -
               4.0 * quartic_bubble;
      psi[1] = (2.0 * s[1] - 1.0) * s[1] +
               3.0 * (cubic_bubble012 + cubic_bubble013 + cubic_bubble123) -
               4.0 * quartic_bubble;
      psi[2] = (2.0 * s[2] - 1.0) * s[2] +
               3.0 * (cubic_bubble012 + cubic_bubble023 + cubic_bubble123) -
               4.0 * quartic_bubble;
      psi[3] = (2.0 * s3 - 1.0) * s3 +
               3.0 * (cubic_bubble013 + cubic_bubble023 + cubic_bubble123) -
               4.0 * quartic_bubble;
      psi[4] = 4.0 * s[0] * s[1] - 12.0 * (cubic_bubble012 + cubic_bubble013) +
               32.0 * quartic_bubble;
      psi[5] = 4.0 * s[0] * s[2] - 12.0 * (cubic_bubble012 + cubic_bubble023) +
               32.0 * quartic_bubble;
      psi[6] = 4.0 * s[0] * s3 - 12.0 * (cubic_bubble013 + cubic_bubble023) +
               32.0 * quartic_bubble;
      psi[7] = 4.0 * s[1] * s[2] - 12.0 * (cubic_bubble012 + cubic_bubble123) +
               32.0 * quartic_bubble;
      psi[8] = 4.0 * s[2] * s3 - 12.0 * (cubic_bubble023 + cubic_bubble123) +
               32.0 * quartic_bubble;
      psi[9] = 4.0 * s[1] * s3 - 12.0 * (cubic_bubble013 + cubic_bubble123) +
               32.0 * quartic_bubble;
      // Add the bubble function on the face spanned by 0 1 3
      psi[10] = 27.0 * cubic_bubble013 - 108.0 * quartic_bubble;
      // Add the bubble function on the face spanned by 0 1 2
      psi[11] = 27.0 * cubic_bubble012 - 108.0 * quartic_bubble;
      // Add the bubble function on the face spanned by 0 2 3
      psi[12] = 27.0 * cubic_bubble023 - 108.0 * quartic_bubble;
      // Add the bubble function on the face spanned by 1 2 3
      psi[13] = 27.0 * cubic_bubble123 - 108.0 * quartic_bubble;
      // Add the volume bubble function, scaled to have value one
      psi[14] = 256.0 * quartic_bubble;
    }


    //=======================================================================
    /// Derivatives of shape functions for specific TElement<3,3>
    //=======================================================================
    void dshape_local(const Vector<double>& s, Shape& psi, DShape& dpsids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->shape(s, psi);

      // Define s3 the fourth volume coordinate
      const double s3 = 1.0 - s[0] - s[1] - s[2];

      // Calculate derivatives of the bubble function
      const double d_quartic_bubble_ds0 =
        s[1] * s[2] * (1.0 - s[1] - s[2] - 2.0 * s[0]);
      const double d_quartic_bubble_ds1 =
        s[0] * s[2] * (1.0 - s[0] - s[2] - 2.0 * s[1]);
      const double d_quartic_bubble_ds2 =
        s[0] * s[1] * (1.0 - s[0] - s[1] - 2.0 * s[2]);

      const double d_cubic_bubble012_ds0 = s[1] * s[2];
      const double d_cubic_bubble012_ds1 = s[0] * s[2];
      const double d_cubic_bubble012_ds2 = s[0] * s[1];

      const double d_cubic_bubble013_ds0 = s[1] * (s3 - s[0]);
      const double d_cubic_bubble013_ds1 = s[0] * (s3 - s[1]);
      const double d_cubic_bubble013_ds2 = -s[0] * s[1];

      const double d_cubic_bubble023_ds0 = s[2] * (s3 - s[0]);
      const double d_cubic_bubble023_ds1 = -s[0] * s[2];
      const double d_cubic_bubble023_ds2 = s[0] * (s3 - s[2]);

      const double d_cubic_bubble123_ds0 = -s[1] * s[2];
      const double d_cubic_bubble123_ds1 = s[2] * (s3 - s[1]);
      const double d_cubic_bubble123_ds2 = s[1] * (s3 - s[2]);


      // Add the appropriate dervatives of the bubble function to the
      // shape function derivatives
      dpsids(0, 0) = 4.0 * s[0] - 1.0 +
                     3.0 * (d_cubic_bubble012_ds0 + d_cubic_bubble013_ds0 +
                            d_cubic_bubble023_ds0) -
                     4.0 * d_quartic_bubble_ds0;
      dpsids(0, 1) = 0.0 +
                     3.0 * (d_cubic_bubble012_ds1 + d_cubic_bubble013_ds1 +
                            d_cubic_bubble023_ds1) -
                     4.0 * d_quartic_bubble_ds1;
      dpsids(0, 2) = 0.0 +
                     3.0 * (d_cubic_bubble012_ds2 + d_cubic_bubble013_ds2 +
                            d_cubic_bubble023_ds2) -
                     4.0 * d_quartic_bubble_ds2;

      dpsids(1, 0) = 0.0 +
                     3.0 * (d_cubic_bubble012_ds0 + d_cubic_bubble013_ds0 +
                            d_cubic_bubble123_ds0) -
                     4.0 * d_quartic_bubble_ds0;
      dpsids(1, 1) = 4.0 * s[1] - 1.0 +
                     3.0 * (d_cubic_bubble012_ds1 + d_cubic_bubble013_ds1 +
                            d_cubic_bubble123_ds1) -
                     4.0 * d_quartic_bubble_ds1;
      dpsids(1, 2) = 0.0 +
                     3.0 * (d_cubic_bubble012_ds2 + d_cubic_bubble013_ds2 +
                            d_cubic_bubble123_ds2) -
                     4.0 * d_quartic_bubble_ds2;

      dpsids(2, 0) = 0.0 +
                     3.0 * (d_cubic_bubble012_ds0 + d_cubic_bubble023_ds0 +
                            d_cubic_bubble123_ds0) -
                     4.0 * d_quartic_bubble_ds0;
      dpsids(2, 1) = 0.0 +
                     3.0 * (d_cubic_bubble012_ds1 + d_cubic_bubble023_ds1 +
                            d_cubic_bubble123_ds1) -
                     4.0 * d_quartic_bubble_ds1;
      dpsids(2, 2) = 4.0 * s[2] - 1.0 +
                     3.0 * (d_cubic_bubble012_ds2 + d_cubic_bubble023_ds2 +
                            d_cubic_bubble123_ds2) -
                     4.0 * d_quartic_bubble_ds2;

      dpsids(3, 0) = -4.0 * s3 + 1.0 +
                     3.0 * (d_cubic_bubble013_ds0 + d_cubic_bubble023_ds0 +
                            d_cubic_bubble123_ds0) -
                     4.0 * d_quartic_bubble_ds0;
      dpsids(3, 1) = -4.0 * s3 + 1.0 +
                     3.0 * (d_cubic_bubble013_ds1 + d_cubic_bubble023_ds1 +
                            d_cubic_bubble123_ds1) -
                     4.0 * d_quartic_bubble_ds1;
      dpsids(3, 2) = -4.0 * s3 + 1.0 +
                     3.0 * (d_cubic_bubble013_ds2 + d_cubic_bubble023_ds2 +
                            d_cubic_bubble123_ds2) -
                     4.0 * d_quartic_bubble_ds2;

      dpsids(4, 0) = 4.0 * s[1] -
                     12.0 * (d_cubic_bubble012_ds0 + d_cubic_bubble013_ds0) +
                     32.0 * d_quartic_bubble_ds0;
      dpsids(4, 1) = 4.0 * s[0] -
                     12.0 * (d_cubic_bubble012_ds1 + d_cubic_bubble013_ds1) +
                     32.0 * d_quartic_bubble_ds1;
      dpsids(4, 2) = 0.0 -
                     12.0 * (d_cubic_bubble012_ds2 + d_cubic_bubble013_ds2) +
                     32.0 * d_quartic_bubble_ds2;

      dpsids(5, 0) = 4.0 * s[2] -
                     12.0 * (d_cubic_bubble012_ds0 + d_cubic_bubble023_ds0) +
                     32.0 * d_quartic_bubble_ds0;
      dpsids(5, 1) = 0.0 -
                     12.0 * (d_cubic_bubble012_ds1 + d_cubic_bubble023_ds1) +
                     32.0 * d_quartic_bubble_ds1;
      dpsids(5, 2) = 4.0 * s[0] -
                     12.0 * (d_cubic_bubble012_ds2 + d_cubic_bubble023_ds2) +
                     32.0 * d_quartic_bubble_ds2;

      dpsids(6, 0) = 4.0 * (s3 - s[0]) -
                     12.0 * (d_cubic_bubble013_ds0 + d_cubic_bubble023_ds0) +
                     32.0 * d_quartic_bubble_ds0;
      dpsids(6, 1) = -4.0 * s[0] -
                     12.0 * (d_cubic_bubble013_ds1 + d_cubic_bubble023_ds1) +
                     32.0 * d_quartic_bubble_ds1;
      dpsids(6, 2) = -4.0 * s[0] -
                     12.0 * (d_cubic_bubble013_ds2 + d_cubic_bubble023_ds2) +
                     32.0 * d_quartic_bubble_ds2;

      dpsids(7, 0) = 0.0 -
                     12.0 * (d_cubic_bubble012_ds0 + d_cubic_bubble123_ds0) +
                     32.0 * d_quartic_bubble_ds0;
      dpsids(7, 1) = 4.0 * s[2] -
                     12.0 * (d_cubic_bubble012_ds1 + d_cubic_bubble123_ds1) +
                     32.0 * d_quartic_bubble_ds1;
      dpsids(7, 2) = 4.0 * s[1] -
                     12.0 * (d_cubic_bubble012_ds2 + d_cubic_bubble123_ds2) +
                     32.0 * d_quartic_bubble_ds2;

      dpsids(8, 0) = -4.0 * s[2] -
                     12.0 * (d_cubic_bubble023_ds0 + d_cubic_bubble123_ds0) +
                     32.0 * d_quartic_bubble_ds0;
      dpsids(8, 1) = -4.0 * s[2] -
                     12.0 * (d_cubic_bubble023_ds1 + d_cubic_bubble123_ds1) +
                     32.0 * d_quartic_bubble_ds1;
      dpsids(8, 2) = 4.0 * (s3 - s[2]) -
                     12.0 * (d_cubic_bubble023_ds2 + d_cubic_bubble123_ds2) +
                     32.0 * d_quartic_bubble_ds2;

      dpsids(9, 0) = -4.0 * s[1] -
                     12.0 * (d_cubic_bubble013_ds0 + d_cubic_bubble123_ds0) +
                     32.0 * d_quartic_bubble_ds0;
      dpsids(9, 1) = 4.0 * (s3 - s[1]) -
                     12.0 * (d_cubic_bubble013_ds1 + d_cubic_bubble123_ds1) +
                     32.0 * d_quartic_bubble_ds1;
      dpsids(9, 2) = -4.0 * s[1] -
                     12.0 * (d_cubic_bubble013_ds2 + d_cubic_bubble123_ds2) +
                     32.0 * d_quartic_bubble_ds2;

      // Add the bubble function on the face spanned by 0 1 3
      dpsids(10, 0) =
        27.0 * d_cubic_bubble013_ds0 - 108.0 * d_quartic_bubble_ds0;
      dpsids(10, 1) =
        27.0 * d_cubic_bubble013_ds1 - 108.0 * d_quartic_bubble_ds1;
      dpsids(10, 2) =
        27.0 * d_cubic_bubble013_ds2 - 108.0 * d_quartic_bubble_ds2;

      // Add the bubble function on the face spanned by 0 1 2
      dpsids(11, 0) =
        27.0 * d_cubic_bubble012_ds0 - 108.0 * d_quartic_bubble_ds0;
      dpsids(11, 1) =
        27.0 * d_cubic_bubble012_ds1 - 108.0 * d_quartic_bubble_ds1;
      dpsids(11, 2) =
        27.0 * d_cubic_bubble012_ds2 - 108.0 * d_quartic_bubble_ds2;

      // Add the bubble function on the face spanned by 0 2 3
      dpsids(12, 0) =
        27.0 * d_cubic_bubble023_ds0 - 108.0 * d_quartic_bubble_ds0;
      dpsids(12, 1) =
        27.0 * d_cubic_bubble023_ds1 - 108.0 * d_quartic_bubble_ds1;
      dpsids(12, 2) =
        27.0 * d_cubic_bubble023_ds2 - 108.0 * d_quartic_bubble_ds2;

      // Add the bubble function on the face spanned by 1 2 3
      dpsids(13, 0) =
        27.0 * d_cubic_bubble123_ds0 - 108.0 * d_quartic_bubble_ds0;
      dpsids(13, 1) =
        27.0 * d_cubic_bubble123_ds1 - 108.0 * d_quartic_bubble_ds1;
      dpsids(13, 2) =
        27.0 * d_cubic_bubble123_ds2 - 108.0 * d_quartic_bubble_ds2;

      // Add the volumetric bubble function derivatives
      dpsids(14, 0) = 256.0 * d_quartic_bubble_ds0;
      dpsids(14, 1) = 256.0 * d_quartic_bubble_ds1;
      dpsids(14, 2) = 256.0 * d_quartic_bubble_ds2;
    }


    //=======================================================================
    /// Second derivatives of shape functions for specific TElement<3,3>:
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$
    /// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    /// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$
    /// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$
    //=======================================================================
    void d2shape_local(const Vector<double>& s,
                       Shape& psi,
                       DShape& dpsids,
                       DShape& d2psids) const
    {
      // ALH: Don't know why object qualifier is needed
      this->dshape_local(s, psi, dpsids);

      // Define s3
      const double s3 = 1.0 - s[0] - s[1] - s[2];

      // Calculate second derivatives of the bubble functions
      //(.,3) for mixed derivative s[0]-s[1]
      //(.,4) for mixed derivative s[0]-s[2]
      //(.,5) for mixed derivative s[1]-s[2]


      const double d2_quartic_bubble_ds0 = -2.0 * s[1] * s[2];
      const double d2_quartic_bubble_ds1 = -2.0 * s[0] * s[2];
      const double d2_quartic_bubble_ds2 = -2.0 * s[0] * s[1];
      const double d2_quartic_bubble_ds3 =
        s[2] * (1.0 - 2.0 * s[0] - 2.0 * s[1] - s[2]);
      const double d2_quartic_bubble_ds4 =
        s[1] * (1.0 - 2.0 * s[0] - 2.0 * s[2] - s[1]);
      const double d2_quartic_bubble_ds5 =
        s[0] * (1.0 - 2.0 * s[1] - 2.0 * s[2] - s[0]);

      const double d2_cubic_bubble012_ds0 = 0.0;
      const double d2_cubic_bubble012_ds1 = 0.0;
      const double d2_cubic_bubble012_ds2 = 0.0;
      const double d2_cubic_bubble012_ds3 = s[2];
      const double d2_cubic_bubble012_ds4 = s[1];
      const double d2_cubic_bubble012_ds5 = s[0];

      const double d2_cubic_bubble013_ds0 = -2.0 * s[1];
      const double d2_cubic_bubble013_ds1 = -2.0 * s[0];
      const double d2_cubic_bubble013_ds2 = 0.0;
      const double d2_cubic_bubble013_ds3 = s3 - s[0] - s[1];
      const double d2_cubic_bubble013_ds4 = -s[1];
      const double d2_cubic_bubble013_ds5 = -s[0];

      const double d2_cubic_bubble023_ds0 = -2.0 * s[2];
      const double d2_cubic_bubble023_ds1 = 0.0;
      const double d2_cubic_bubble023_ds2 = -2.0 * s[0];
      const double d2_cubic_bubble023_ds3 = -s[2];
      const double d2_cubic_bubble023_ds4 = s3 - s[0] - s[2];
      const double d2_cubic_bubble023_ds5 = -s[0];

      const double d2_cubic_bubble123_ds0 = 0.0;
      const double d2_cubic_bubble123_ds1 = -2.0 * s[2];
      const double d2_cubic_bubble123_ds2 = -2.0 * s[1];
      const double d2_cubic_bubble123_ds3 = -s[2];
      const double d2_cubic_bubble123_ds4 = -s[1];
      const double d2_cubic_bubble123_ds5 = s3 - s[1] - s[2];


      d2psids(0, 0) = 4.0 +
                      3.0 * (d2_cubic_bubble012_ds0 + d2_cubic_bubble013_ds0 +
                             d2_cubic_bubble023_ds0) -
                      4.0 * d2_quartic_bubble_ds0;
      d2psids(0, 1) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds1 + d2_cubic_bubble013_ds1 +
                             d2_cubic_bubble023_ds1) -
                      4.0 * d2_quartic_bubble_ds1;
      d2psids(0, 2) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds2 + d2_cubic_bubble013_ds2 +
                             d2_cubic_bubble023_ds2) -
                      4.0 * d2_quartic_bubble_ds2;
      d2psids(0, 3) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds3 + d2_cubic_bubble013_ds3 +
                             d2_cubic_bubble023_ds3) -
                      4.0 * d2_quartic_bubble_ds3;
      d2psids(0, 4) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds4 + d2_cubic_bubble013_ds4 +
                             d2_cubic_bubble023_ds4) -
                      4.0 * d2_quartic_bubble_ds4;
      d2psids(0, 5) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds5 + d2_cubic_bubble013_ds5 +
                             d2_cubic_bubble023_ds5) -
                      4.0 * d2_quartic_bubble_ds5;


      d2psids(1, 0) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds0 + d2_cubic_bubble013_ds0 +
                             d2_cubic_bubble123_ds0) -
                      4.0 * d2_quartic_bubble_ds0;
      d2psids(1, 1) = 4.0 +
                      3.0 * (d2_cubic_bubble012_ds1 + d2_cubic_bubble013_ds1 +
                             d2_cubic_bubble123_ds1) -
                      4.0 * d2_quartic_bubble_ds1;
      d2psids(1, 2) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds2 + d2_cubic_bubble013_ds2 +
                             d2_cubic_bubble123_ds2) -
                      4.0 * d2_quartic_bubble_ds2;
      d2psids(1, 3) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds3 + d2_cubic_bubble013_ds3 +
                             d2_cubic_bubble123_ds3) -
                      4.0 * d2_quartic_bubble_ds3;
      d2psids(1, 4) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds4 + d2_cubic_bubble013_ds4 +
                             d2_cubic_bubble123_ds4) -
                      4.0 * d2_quartic_bubble_ds4;
      d2psids(1, 5) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds5 + d2_cubic_bubble013_ds5 +
                             d2_cubic_bubble123_ds5) -
                      4.0 * d2_quartic_bubble_ds5;


      d2psids(2, 0) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds0 + d2_cubic_bubble023_ds0 +
                             d2_cubic_bubble123_ds0) -
                      4.0 * d2_quartic_bubble_ds0;
      d2psids(2, 1) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds1 + d2_cubic_bubble023_ds1 +
                             d2_cubic_bubble123_ds1) -
                      4.0 * d2_quartic_bubble_ds1;
      d2psids(2, 2) = 4.0 +
                      3.0 * (d2_cubic_bubble012_ds2 + d2_cubic_bubble023_ds2 +
                             d2_cubic_bubble123_ds2) -
                      4.0 * d2_quartic_bubble_ds2;
      d2psids(2, 3) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds3 + d2_cubic_bubble023_ds3 +
                             d2_cubic_bubble123_ds3) -
                      4.0 * d2_quartic_bubble_ds3;
      d2psids(2, 4) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds4 + d2_cubic_bubble023_ds4 +
                             d2_cubic_bubble123_ds4) -
                      4.0 * d2_quartic_bubble_ds4;
      d2psids(2, 5) = 0.0 +
                      3.0 * (d2_cubic_bubble012_ds5 + d2_cubic_bubble023_ds5 +
                             d2_cubic_bubble123_ds5) -
                      4.0 * d2_quartic_bubble_ds5;


      d2psids(3, 0) = 4.0 +
                      3.0 * (d2_cubic_bubble013_ds0 + d2_cubic_bubble023_ds0 +
                             d2_cubic_bubble123_ds0) -
                      4.0 * d2_quartic_bubble_ds0;
      d2psids(3, 1) = 4.0 +
                      3.0 * (d2_cubic_bubble013_ds1 + d2_cubic_bubble023_ds1 +
                             d2_cubic_bubble123_ds1) -
                      4.0 * d2_quartic_bubble_ds1;
      d2psids(3, 2) = 4.0 +
                      3.0 * (d2_cubic_bubble013_ds2 + d2_cubic_bubble023_ds2 +
                             d2_cubic_bubble123_ds2) -
                      4.0 * d2_quartic_bubble_ds2;
      d2psids(3, 3) = 4.0 +
                      3.0 * (d2_cubic_bubble013_ds3 + d2_cubic_bubble023_ds3 +
                             d2_cubic_bubble123_ds3) -
                      4.0 * d2_quartic_bubble_ds3;
      d2psids(3, 4) = 4.0 +
                      3.0 * (d2_cubic_bubble013_ds4 + d2_cubic_bubble023_ds4 +
                             d2_cubic_bubble123_ds4) -
                      4.0 * d2_quartic_bubble_ds4;
      d2psids(3, 5) = 4.0 +
                      3.0 * (d2_cubic_bubble013_ds5 + d2_cubic_bubble023_ds5 +
                             d2_cubic_bubble123_ds5) -
                      4.0 * d2_quartic_bubble_ds5;


      d2psids(4, 0) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds0 + d2_cubic_bubble013_ds0) +
                      32.0 * d2_quartic_bubble_ds0;
      d2psids(4, 1) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds1 + d2_cubic_bubble013_ds1) +
                      32.0 * d2_quartic_bubble_ds1;
      d2psids(4, 2) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds2 + d2_cubic_bubble013_ds2) +
                      32.0 * d2_quartic_bubble_ds2;
      d2psids(4, 3) = 4.0 -
                      12.0 * (d2_cubic_bubble012_ds3 + d2_cubic_bubble013_ds3) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(4, 4) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds4 + d2_cubic_bubble013_ds4) +
                      32.0 * d2_quartic_bubble_ds4;
      d2psids(4, 5) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds5 + d2_cubic_bubble013_ds5) +
                      32.0 * d2_quartic_bubble_ds5;


      d2psids(5, 0) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds0 + d2_cubic_bubble023_ds0) +
                      32.0 * d2_quartic_bubble_ds0;
      d2psids(5, 1) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds1 + d2_cubic_bubble023_ds1) +
                      32.0 * d2_quartic_bubble_ds1;
      d2psids(5, 2) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds2 + d2_cubic_bubble023_ds2) +
                      32.0 * d2_quartic_bubble_ds2;
      d2psids(5, 3) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds3 + d2_cubic_bubble023_ds3) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(5, 4) = 4.0 -
                      12.0 * (d2_cubic_bubble012_ds4 + d2_cubic_bubble023_ds4) +
                      32.0 * d2_quartic_bubble_ds4;
      d2psids(5, 5) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds5 + d2_cubic_bubble023_ds5) +
                      32.0 * d2_quartic_bubble_ds5;


      d2psids(6, 0) = -8.0 -
                      12.0 * (d2_cubic_bubble013_ds0 + d2_cubic_bubble023_ds0) +
                      32.0 * d2_quartic_bubble_ds0;
      d2psids(6, 1) = 0.0 -
                      12.0 * (d2_cubic_bubble013_ds1 + d2_cubic_bubble023_ds1) +
                      32.0 * d2_quartic_bubble_ds1;
      d2psids(6, 2) = 0.0 -
                      12.0 * (d2_cubic_bubble013_ds2 + d2_cubic_bubble023_ds2) +
                      32.0 * d2_quartic_bubble_ds2;
      d2psids(6, 3) = -4.0 -
                      12.0 * (d2_cubic_bubble013_ds3 + d2_cubic_bubble023_ds3) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(6, 4) = -4.0 -
                      12.0 * (d2_cubic_bubble013_ds4 + d2_cubic_bubble023_ds4) +
                      32.0 * d2_quartic_bubble_ds4;
      d2psids(6, 5) = 0.0 -
                      12.0 * (d2_cubic_bubble013_ds5 + d2_cubic_bubble023_ds5) +
                      32.0 * d2_quartic_bubble_ds5;

      d2psids(7, 0) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds0 + d2_cubic_bubble123_ds0) +
                      32.0 * d2_quartic_bubble_ds0;
      d2psids(7, 1) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds1 + d2_cubic_bubble123_ds1) +
                      32.0 * d2_quartic_bubble_ds1;
      d2psids(7, 2) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds2 + d2_cubic_bubble123_ds2) +
                      32.0 * d2_quartic_bubble_ds2;
      d2psids(7, 3) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds3 + d2_cubic_bubble123_ds3) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(7, 4) = 0.0 -
                      12.0 * (d2_cubic_bubble012_ds4 + d2_cubic_bubble123_ds4) +
                      32.0 * d2_quartic_bubble_ds4;
      d2psids(7, 5) = 4.0 -
                      12.0 * (d2_cubic_bubble012_ds5 + d2_cubic_bubble123_ds5) +
                      32.0 * d2_quartic_bubble_ds5;

      d2psids(8, 0) = 0.0 -
                      12.0 * (d2_cubic_bubble023_ds0 + d2_cubic_bubble123_ds0) +
                      32.0 * d2_quartic_bubble_ds0;
      d2psids(8, 1) = 0.0 -
                      12.0 * (d2_cubic_bubble023_ds1 + d2_cubic_bubble123_ds1) +
                      32.0 * d2_quartic_bubble_ds1;
      d2psids(8, 2) = -8.0 -
                      12.0 * (d2_cubic_bubble023_ds2 + d2_cubic_bubble123_ds2) +
                      32.0 * d2_quartic_bubble_ds2;
      d2psids(8, 3) = 0.0 -
                      12.0 * (d2_cubic_bubble023_ds3 + d2_cubic_bubble123_ds3) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(8, 4) = -4.0 -
                      12.0 * (d2_cubic_bubble023_ds4 + d2_cubic_bubble123_ds4) +
                      32.0 * d2_quartic_bubble_ds4;
      d2psids(8, 5) = -4.0 -
                      12.0 * (d2_cubic_bubble023_ds5 + d2_cubic_bubble123_ds5) +
                      32.0 * d2_quartic_bubble_ds5;

      d2psids(9, 0) = 0.0 -
                      12.0 * (d2_cubic_bubble013_ds0 + d2_cubic_bubble123_ds0) +
                      32.0 * d2_quartic_bubble_ds0;
      d2psids(9, 1) = -8.0 -
                      12.0 * (d2_cubic_bubble013_ds1 + d2_cubic_bubble123_ds1) +
                      32.0 * d2_quartic_bubble_ds1;
      d2psids(9, 2) = 0.0 -
                      12.0 * (d2_cubic_bubble013_ds2 + d2_cubic_bubble123_ds2) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(9, 3) = -4.0 -
                      12.0 * (d2_cubic_bubble013_ds3 + d2_cubic_bubble123_ds3) +
                      32.0 * d2_quartic_bubble_ds3;
      d2psids(9, 4) = 0.0 -
                      12.0 * (d2_cubic_bubble013_ds4 + d2_cubic_bubble123_ds4) +
                      32.0 * d2_quartic_bubble_ds4;
      d2psids(9, 5) = -4.0 -
                      12.0 * (d2_cubic_bubble013_ds5 + d2_cubic_bubble123_ds5) +
                      32.0 * d2_quartic_bubble_ds5;

      // Add the bubble function on the face spanned by 0 1 3
      d2psids(10, 0) =
        27.0 * d2_cubic_bubble013_ds0 - 108.0 * d2_quartic_bubble_ds0;
      d2psids(10, 1) =
        27.0 * d2_cubic_bubble013_ds1 - 108.0 * d2_quartic_bubble_ds1;
      d2psids(10, 2) =
        27.0 * d2_cubic_bubble013_ds2 - 108.0 * d2_quartic_bubble_ds2;
      d2psids(10, 3) =
        27.0 * d2_cubic_bubble013_ds3 - 108.0 * d2_quartic_bubble_ds3;
      d2psids(10, 4) =
        27.0 * d2_cubic_bubble013_ds4 - 108.0 * d2_quartic_bubble_ds4;
      d2psids(10, 5) =
        27.0 * d2_cubic_bubble013_ds5 - 108.0 * d2_quartic_bubble_ds5;

      // Add the bubble function on the face spanned by 0 1 2
      d2psids(11, 0) =
        27.0 * d2_cubic_bubble012_ds0 - 108.0 * d2_quartic_bubble_ds0;
      d2psids(11, 1) =
        27.0 * d2_cubic_bubble012_ds1 - 108.0 * d2_quartic_bubble_ds1;
      d2psids(11, 2) =
        27.0 * d2_cubic_bubble012_ds2 - 108.0 * d2_quartic_bubble_ds2;
      d2psids(11, 3) =
        27.0 * d2_cubic_bubble012_ds3 - 108.0 * d2_quartic_bubble_ds3;
      d2psids(11, 4) =
        27.0 * d2_cubic_bubble012_ds4 - 108.0 * d2_quartic_bubble_ds4;
      d2psids(11, 5) =
        27.0 * d2_cubic_bubble012_ds5 - 108.0 * d2_quartic_bubble_ds5;

      // Add the bubble function on the face spanned by 0 2 3
      d2psids(12, 0) =
        27.0 * d2_cubic_bubble023_ds0 - 108.0 * d2_quartic_bubble_ds0;
      d2psids(12, 1) =
        27.0 * d2_cubic_bubble023_ds1 - 108.0 * d2_quartic_bubble_ds1;
      d2psids(12, 2) =
        27.0 * d2_cubic_bubble023_ds2 - 108.0 * d2_quartic_bubble_ds2;
      d2psids(12, 3) =
        27.0 * d2_cubic_bubble023_ds3 - 108.0 * d2_quartic_bubble_ds3;
      d2psids(12, 4) =
        27.0 * d2_cubic_bubble023_ds4 - 108.0 * d2_quartic_bubble_ds4;
      d2psids(12, 5) =
        27.0 * d2_cubic_bubble023_ds5 - 108.0 * d2_quartic_bubble_ds5;

      // Add the bubble function on the face spanned by 1 2 3
      d2psids(13, 0) =
        27.0 * d2_cubic_bubble123_ds0 - 108.0 * d2_quartic_bubble_ds0;
      d2psids(13, 1) =
        27.0 * d2_cubic_bubble123_ds1 - 108.0 * d2_quartic_bubble_ds1;
      d2psids(13, 2) =
        27.0 * d2_cubic_bubble123_ds2 - 108.0 * d2_quartic_bubble_ds2;
      d2psids(13, 3) =
        27.0 * d2_cubic_bubble123_ds3 - 108.0 * d2_quartic_bubble_ds3;
      d2psids(13, 4) =
        27.0 * d2_cubic_bubble123_ds4 - 108.0 * d2_quartic_bubble_ds4;
      d2psids(13, 5) =
        27.0 * d2_cubic_bubble123_ds5 - 108.0 * d2_quartic_bubble_ds5;

      // Add the volumetric bubble function derivatives
      d2psids(14, 0) = 256.0 * d2_quartic_bubble_ds0;
      d2psids(14, 1) = 256.0 * d2_quartic_bubble_ds1;
      d2psids(14, 2) = 256.0 * d2_quartic_bubble_ds2;
      d2psids(14, 3) = 256.0 * d2_quartic_bubble_ds3;
      d2psids(14, 4) = 256.0 * d2_quartic_bubble_ds4;
      d2psids(14, 5) = 256.0 * d2_quartic_bubble_ds5;
    }
  };


  //=======================================================================
  /// General TElement class specialised to three spatial dimensions (tet)
  /// Ordering of nodes inverted from Zienkiewizc sketches: When looking into
  /// the tet from vertex node 0. The vertex nodes on the opposite face are 1 -
  /// 2 - 3 in anticlockwise direction. Other nodes filled in edge by edge, then
  /// the face ones, then the internal ones.
  //=======================================================================
  template<unsigned NNODE_1D>
  class TElement<3, NNODE_1D> : public virtual TElementBase,
                                public TElementShape<3, NNODE_1D>
  {
  private:
    /// Nodal translation scheme for use when generating face elements
    static const unsigned Node_on_face[4][(NNODE_1D * (NNODE_1D + 1)) / 2];

    /// Default integration rule: Gaussian integration of same 'order' as
    /// the element
    // This is sort of optimal, because it means that the integration is exact
    // for the shape functions. Can overwrite this in specific element
    // defintion.
    static TGauss<3, NNODE_1D> Default_integration_scheme;

  public:
    /// Constructor
    TElement()
    {
      switch (NNODE_1D)
      {
        case 2:
        case 3:
          break;

          /*     case 4: */
          /*      n_node = 20; */
          /*      break; */

        default:
          std::string error_message =
            "Tets are currently only implemented for\n";
          error_message += "four and ten nodes, i.e. NNODE_1D=2 , 3 \n";

          throw OomphLibError(
            error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }


      // Set the number of nodes
      unsigned n_node =
        (NNODE_1D * (NNODE_1D + 1)) / 2 + 1 + 3 * (NNODE_1D - 2);
      this->set_n_node(n_node);

      // Set the elemental and nodal dimensions
      set_dimension(3);

      // Assign default (full) spatial integration scheme
      set_integration_scheme(&Default_integration_scheme);
    }


    /// Broken copy constructor
    TElement(const TElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const TElement&) = delete;*/


    /// Destructor
    ~TElement() {}

    /// Number of nodes along each element edge
    unsigned nnode_1d() const
    {
      return NNODE_1D;
    }


    /// Number of vertex nodes in the element: One more
    /// than spatial dimension
    unsigned nvertex_node() const
    {
      return 4;
    }

    /// Public access function for Node_on_face.
    unsigned get_bulk_node_number(const int& face_index,
                                  const unsigned& i) const
    {
      return Node_on_face[face_index][i];
    }

    /// Pointer to the j-th vertex node in the element
    Node* vertex_node_pt(const unsigned& j) const
    {
      // Vertex nodes come first:
#ifdef PARANOID
      if (j > 3)
      {
        std::ostringstream error_message;
        error_message
          << "Element only has four vertex nodes; called with node number " << j
          << std::endl;
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
      return node_pt(j);
    }

    /// Calculate the geometric shape functions at local coordinate s
    inline void shape(const Vector<double>& s, Shape& psi) const
    {
      TElementShape<3, NNODE_1D>::shape(s, psi);
    }

    /// Compute the  geometric shape functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dshape_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids) const
    {
      TElementShape<3, NNODE_1D>::dshape_local(s, psi, dpsids);
    }

    /// Compute the geometric shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s.
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$
    /// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    /// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$
    /// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$
    inline void d2shape_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids,
                              DShape& d2psids) const
    {
      TElementShape<3, NNODE_1D>::d2shape_local(s, psi, dpsids, d2psids);
    }

    /// Overload the template-free interface for the calculation of
    /// inverse jacobian matrix. This is a three dimensional element, so use
    /// the 3D version.
    double invert_jacobian_mapping(const DenseMatrix<double>& jacobian,
                                   DenseMatrix<double>& inverse_jacobian) const
    {
      return FiniteElement::invert_jacobian<3>(jacobian, inverse_jacobian);
    }

    /// Min. value of local coordinate
    double s_min() const
    {
      return 0.0;
    }

    /// Max. value of local coordinate
    double s_max() const
    {
      return 1.0;
    }

    /// Return local coordinates of node j
    inline void local_coordinate_of_node(const unsigned& j,
                                         Vector<double>& s) const
    {
      TElementShape<3, NNODE_1D>::local_coordinate_of_node(j, s);
    }

    /// Return the number of actual plot points for paraview
    /// plot with parameter nplot.
    unsigned nplot_points_paraview(const unsigned& nplot) const
    {
      unsigned node_sum = 0;
      for (unsigned j = 1; j <= nplot; j++)
      {
        for (unsigned i = 1; i <= j; i++)
        {
          node_sum += i;
        }
      }
      return node_sum;
    }

    /// Return the number of local sub-elements for paraview plot with
    /// parameter nplot.
    unsigned nsub_elements_paraview(const unsigned& nplot) const
    {
      return (nplot - 1) * (nplot - 1) * (nplot - 1);
    }

    /// Fill in the offset information for paraview plot.
    /// Needs to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_output_offset_information(std::ofstream& file_out,
                                                  const unsigned& nplot,
                                                  unsigned& counter) const
    {
      // Output node lists for sub elements for Paraview (node index
      // must start at 0, fixed with magical counter-1)

      unsigned paraview_fix = counter - 1;
      unsigned nod_count = 1;

      for (unsigned i = 0; i < nplot; i++)
      {
        for (unsigned j = 0; j < nplot - i; j++)
        {
          for (unsigned k = 0; k < nplot - i - j; k++)
          {
            if (k < nplot - i - j - 1)
            {
              file_out << nod_count + paraview_fix << " "
                       << nod_count + 1 + paraview_fix << " "
                       << nod_count + nplot - i - j + paraview_fix << " "
                       << nod_count + nplot - i - j +
                            ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                       << std::endl;
              if (k < nplot - i - j - 2)
              {
                file_out << nod_count + 1 + paraview_fix << " "
                         << nod_count + nplot - i - j + paraview_fix << " "
                         << nod_count + nplot - i - j +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << " "
                         << nod_count + 2 * (nplot - i - j) - 1 +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << std::endl;
                file_out << nod_count + 1 + paraview_fix << " "
                         << nod_count + nplot - i - j + paraview_fix << " "
                         << nod_count + nplot - i - j + 1 + paraview_fix << " "
                         << nod_count + 2 * (nplot - i - j) - 1 +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << std::endl;
                file_out << nod_count + 1 + paraview_fix << " "
                         << nod_count + nplot - i - j +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << " "
                         << nod_count + nplot - i - j +
                              ((nplot - 1 - i) * (nplot - i) / 2) + 1 +
                              paraview_fix
                         << " "
                         << nod_count + 2 * (nplot - i - j) - 1 +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << std::endl;
                file_out << nod_count + 1 + paraview_fix << " "
                         << nod_count + nplot - i - j + 1 + paraview_fix << " "
                         << nod_count + nplot - i - j +
                              ((nplot - 1 - i) * (nplot - i) / 2) + 1 +
                              paraview_fix
                         << " "
                         << nod_count + 2 * (nplot - i - j) - 1 +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << std::endl;
              }
              if (k > 1)
              {
                file_out << nod_count + nplot - i - j - 1 + paraview_fix << " "
                         << nod_count + nplot - i - j +
                              ((nplot - 1 - i) * (nplot - i) / 2) - 1 +
                              paraview_fix
                         << " "
                         << nod_count + 2 * (nplot - i - j - 1) +
                              ((nplot - 1 - i) * (nplot - i) / 2) - 1 +
                              paraview_fix
                         << " "
                         << nod_count + 2 * (nplot - i - j - 1) +
                              ((nplot - 1 - i) * (nplot - i) / 2) + paraview_fix
                         << std::endl;
              }
            } // end if(k<nplot-i-j-1)
            ++nod_count;
          }
        }
      }

      // increment the counter to keep track of global connectivity
      counter += nplot_points_paraview(nplot);

    } // end of write Paraview_element...

    /// Return the paraview element type.
    /// Needs to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_type(std::ofstream& file_out,
                             const unsigned& nplot) const
    {
      unsigned local_loop = nsub_elements_paraview(nplot);
      for (unsigned i = 0; i < local_loop; i++)
      {
        file_out << "10" << std::endl;
      }
    }

    /// Return the offsets for the paraview sub-elements. Needs
    /// to be implemented for each new geometric element type; see
    /// http://www.vtk.org/VTK/img/file-formats.pdf
    void write_paraview_offsets(std::ofstream& file_out,
                                const unsigned& nplot,
                                unsigned& offset_sum) const
    {
      unsigned local_loop = nsub_elements_paraview(nplot);
      for (unsigned i = 0; i < local_loop; i++)
      {
        offset_sum += 4;
        file_out << offset_sum << std::endl;
      }
    }

    /// Output
    void output(std::ostream& output);

    /// Output at specified number of plot points
    void output(std::ostream& outfile, const unsigned& nplot);

    /// C-style output
    void output(FILE* file_pt);

    /// C_style output at n_plot points
    void output(FILE* file_pt, const unsigned& n_plot);

    ///  Get vector of local coordinates of plot point i (when plotting
    /// nplot points in each "coordinate direction).
    void get_s_plot(
      const unsigned& iplot,
      const unsigned& nplot,
      Vector<double>& s,
      const bool& use_equally_spaced_interior_sample_points = false) const
    {
      if (nplot > 1)
      {
        unsigned np = 0;
        for (unsigned i = 0; i < nplot; ++i)
        {
          for (unsigned j = 0; j < nplot - i; ++j)
          {
            for (unsigned k = 0; k < nplot - i - j; ++k)
            {
              if (np == iplot)
              {
                {
                  s[0] = double(j) / double(nplot - 1);
                  s[1] = double(i) / double(nplot - 1);
                  s[2] = double(k) / double(nplot - 1);
                  if (use_equally_spaced_interior_sample_points)
                  {
                    double range = 1.0;
                    double dx_new = range / double(nplot + 1);
                    double range_new = double(nplot - 1) * dx_new;
                    s[0] = 0.5 * dx_new + range_new * s[0] / range;
                    s[1] = 0.5 * dx_new + range_new * s[1] / range;
                    s[2] = 0.5 * dx_new + range_new * s[2] / range;
                  }
                  return;
                }
              }
              np++;
            }
          }
        }
      }
      else
      {
        s[0] = 1.0 / 4.0;
        s[1] = 1.0 / 4.0;
        s[2] = 1.0 / 4.0;
      }
    }

    /// Return string for tecplot zone header (when plotting
    /// nplot points in each "coordinate direction)
    std::string tecplot_zone_string(const unsigned& nplot) const
    {
      std::ostringstream header;
      unsigned nel = 0;
      nel = (nplot - 1) * (nplot - 1) * (nplot - 1);
      header << "ZONE N=" << nplot_points(nplot) << ", E=" << nel
             << ", F=FEPOINT, ET=TETRAHEDRON\n";
      return header.str();
    }

    /// Add tecplot zone "footer" to output stream (when plotting
    /// nplot points in each "coordinate direction).
    /// Empty by default -- can be used, e.g., to add FE connectivity
    /// lists to elements that need it.
    void write_tecplot_zone_footer(std::ostream& outfile,
                                   const unsigned& nplot) const
    {
      // Output node lists for sub elements for Tecplot (node index
      // must start at 1)
      unsigned nod_count = 1;
      for (unsigned i = 0; i < nplot; i++)
      {
        for (unsigned j = 0; j < nplot - i; j++)
        {
          for (unsigned k = 0; k < nplot - i - j; k++)
          {
            if (k < nplot - i - j - 1)
            {
              outfile << nod_count << " " << nod_count + 1 << " "
                      << nod_count + nplot - i - j << " "
                      << nod_count + nplot - i - j +
                           ((nplot - 1 - i) * (nplot - i) / 2)
                      << std::endl;
              if (k < nplot - i - j - 2)
              {
                outfile << nod_count + 1 << " " << nod_count + nplot - i - j
                        << " "
                        << nod_count + nplot - i - j +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << " "
                        << nod_count + 2 * (nplot - i - j) - 1 +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << std::endl;
                outfile << nod_count + 1 << " " << nod_count + nplot - i - j
                        << " " << nod_count + nplot - i - j + 1 << " "
                        << nod_count + 2 * (nplot - i - j) - 1 +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << std::endl;
                outfile << nod_count + 1 << " "
                        << nod_count + nplot - i - j +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << " "
                        << nod_count + nplot - i - j +
                             ((nplot - 1 - i) * (nplot - i) / 2) + 1
                        << " "
                        << nod_count + 2 * (nplot - i - j) - 1 +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << std::endl;
                outfile << nod_count + 1 << " " << nod_count + nplot - i - j + 1
                        << " "
                        << nod_count + nplot - i - j +
                             ((nplot - 1 - i) * (nplot - i) / 2) + 1
                        << " "
                        << nod_count + 2 * (nplot - i - j) - 1 +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << std::endl;
              }
              if (k > 1)
              {
                outfile << nod_count + nplot - i - j - 1 << " "
                        << nod_count + nplot - i - j +
                             ((nplot - 1 - i) * (nplot - i) / 2) - 1
                        << " "
                        << nod_count + 2 * (nplot - i - j - 1) +
                             ((nplot - 1 - i) * (nplot - i) / 2) - 1
                        << " "
                        << nod_count + 2 * (nplot - i - j - 1) +
                             ((nplot - 1 - i) * (nplot - i) / 2)
                        << std::endl;
              }
            } // end if(k<nplot-i-j-1)
            ++nod_count;
          }
        }
      }
    } // end of write tecplot...


    /// Add tecplot zone "footer" to C-style output. (when plotting
    /// nplot points in each "coordinate direction).
    /// Empty by default -- can be used, e.g., to add FE connectivity
    /// lists to elements that need it.
    void write_tecplot_zone_footer(FILE* file_pt, const unsigned& nplot) const
    {
      // Output node lists for sub elements for Tecplot (node index
      // must start at 1)
      unsigned nod_count = 1;
      for (unsigned i = 0; i < nplot; i++)
      {
        for (unsigned j = 0; j < nplot - i; j++)
        {
          for (unsigned k = 0; k < nplot - i - j; k++)
          {
            if (j < nplot - i - 1)
            {
              fprintf(file_pt,
                      "%i %i %i \n",
                      nod_count,
                      nod_count + 1,
                      nod_count + nplot - i);
              if (j < nplot - i - 2)
              {
                fprintf(file_pt,
                        "%i %i %i \n",
                        nod_count + 1,
                        nod_count + nplot - i + 1,
                        nod_count + nplot - i);
              }
            }
            ++nod_count;
          }
        }
      }
    }

    /// Return total number of plot points (when plotting
    /// nplot points in each "coordinate direction)
    unsigned nplot_points(const unsigned& nplot) const
    {
      unsigned res = 0;
      if (nplot > 1)
      {
        res = 4;
        for (unsigned i = 3; i <= nplot; i++)
        {
          res += (i * (i + 1) / 2);
        }
        return res;
      }
      // Otherwise we return 1(?)
      return 1;
    }

    /// Build the lower-dimensional FaceElement (an element of type
    /// TElement<2,NNODE_1D>). The face index can take one of four values
    /// corresponding to the four possible faces:
    /// 0: (left)           s[0] = 0.0
    /// 1: (bottom)         s[1] = 0.0
    /// 2: (back)           s[2] = 0.0
    /// 3: (sloping face)   s[0] + s[1] + s[2] = 1
    void build_face_element(const int& face_index,
                            FaceElement* face_element_pt);
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// TElement class for which the shape functions have been enriched
  /// by a single bubble function of the next order
  ///
  /// Empty, just establishes the template parameters
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class TBubbleEnrichedElement
  {
  };

  //=====================================================================
  /// Define integration schemes that are required to exactly integrate
  /// the mass matrices of the bubble-enriched elements. The enrichement
  /// increases the polynomial order which means that higher-order Gauss
  /// rules must be used.
  //====================================================================
  template<unsigned DIM, unsigned NPTS_1D>
  class TBubbleEnrichedGauss
  {
  };

  //====================================================================
  /// Specialisation for two-dimensional elements, in which the highest
  /// order polynomial is cubic, so we need the integration scheme
  /// for the unenriched cubic element
  //======================================================================
  template<>
  class TBubbleEnrichedGauss<2, 3> : public TGauss<2, 4>
  {
  public:
    TBubbleEnrichedGauss() : TGauss<2, 4>() {}
  };

  //====================================================================
  /// Specialisation for three-dimensional elements, in which the highest
  /// order polynomial is quartic, so we need the integration scheme
  /// for the unenriched quartic element
  //======================================================================
  template<>
  class TBubbleEnrichedGauss<3, 3> : public TGauss<3, 5>
  {
  public:
    TBubbleEnrichedGauss() : TGauss<3, 5>() {}
  };


  //=======================================================================
  /// Enriched TElement class specialised to two spatial dimensions
  /// and three nodes per side (quadratic element)
  /// Ordering of nodes as in Zienkiwizc sketches: vertex nodes
  /// 0 - 1 - 2 anticlockwise. Midside nodes filled in progressing
  /// along the consecutive edges. Central node(s) come(s) last.
  /// The idea is that we inherit from the existing TElement<2,3>, add
  /// the single extra node at the centroid and
  /// overload the shape functions to be those corresponding to the
  /// enriched element.
  //=======================================================================
  template<unsigned DIM>
  class TBubbleEnrichedElement<DIM, 3>
    : public virtual TElement<DIM, 3>,
      public TBubbleEnrichedElementShape<DIM, 3>
  {
  private:
    // Static storage for a new integration scheme
    static TBubbleEnrichedGauss<DIM, 3> Default_enriched_integration_scheme;

    // Static storage for central node
    static const unsigned Central_node_on_face[DIM + 1];

  public:
    /// Constructor
    TBubbleEnrichedElement()
      : TElement<DIM, 3>(), TBubbleEnrichedElementShape<DIM, 3>()
    {
      // Add the additional enrichment nodes
      unsigned n_node = this->nnode();
      this->set_n_node(n_node +
                       TBubbleEnrichedElementShape<DIM, 3>::n_enriched_nodes());
      // Set the new integration scheme
      this->set_integration_scheme(&Default_enriched_integration_scheme);
    }

    /// Broken copy constructor
    TBubbleEnrichedElement(const TBubbleEnrichedElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const TBubbleEnrichedElement&) = delete;*/

    /// Destructor
    ~TBubbleEnrichedElement() {}

    /// Calculate the geometric shape functions at local coordinate s
    inline void shape(const Vector<double>& s, Shape& psi) const
    {
      TBubbleEnrichedElementShape<DIM, 3>::shape(s, psi);
    }

    /// Compute the  geometric shape functions and
    /// derivatives w.r.t. local coordinates at local coordinate s
    inline void dshape_local(const Vector<double>& s,
                             Shape& psi,
                             DShape& dpsids) const
    {
      TBubbleEnrichedElementShape<DIM, 3>::dshape_local(s, psi, dpsids);
    }


    /// Compute the geometric shape functions, derivatives and
    /// second derivatives w.r.t local coordinates at local coordinate s
    /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$
    /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$
    /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$
    inline void d2shape_local(const Vector<double>& s,
                              Shape& psi,
                              DShape& dpsids,
                              DShape& d2psids) const
    {
      TBubbleEnrichedElementShape<DIM, 3>::d2shape_local(
        s, psi, dpsids, d2psids);
    }

    /// Return local coordinates of node j
    inline void local_coordinate_of_node(const unsigned& j,
                                         Vector<double>& s) const
    {
      TBubbleEnrichedElementShape<DIM, 3>::local_coordinate_of_node(j, s);
    }

    /// Build the lower-dimensional FaceElement
    void build_face_element(const int& face_index,
                            FaceElement* face_element_pt);
  };


  //========================================================================
  /// Base class for Solid Telements
  //========================================================================
  class TSolidElementBase : public virtual TElementBase,
                            public virtual SolidFiniteElement
  {
  public:
    /// Constructor: Empty
    TSolidElementBase(){};

    /// Broken copy constructor
    TSolidElementBase(const TSolidElementBase&) = delete;

    /// Broken assignment operator
    /*void operator=(const TSolidElementBase&) = delete;*/
  };


  /// ///////////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////////
  /// ///////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// SolidTElement elements are triangular/tet elements whose
  /// derivatives also include those based upon the lagrangian
  /// positions of the nodes.
  /// They are the basis for solid mechanics elements.
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class SolidTElement
  {
  };


  //=======================================================================
  /// SolidTElement elements, specialised to one spatial dimension
  //=======================================================================
  template<unsigned NNODE_1D>
  class SolidTElement<1, NNODE_1D> : public virtual TElement<1, NNODE_1D>,
                                     public virtual TSolidElementBase
  {
  public:
    /// Constructor
    SolidTElement() : TElement<1, NNODE_1D>(), SolidFiniteElement()
    {
      // Set the Lagrangian dimension of the element
      set_lagrangian_dimension(1);
    }

    /// Broken copy constructor
    SolidTElement(const SolidTElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const SolidTElement&) = delete;*/

    /// Build the lower-dimensional FaceElement (an element of type
    /// SolidPointElement).  The face index takes two values
    /// corresponding to the two possible faces:
    /// -1 (Left)  s[0] = -1.0
    /// +1 (Right) s[0] =  1.0
    inline void build_face_element(const int& face_index,
                                   FaceElement* face_element_pt);
  };


  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////
  // SolidTElements
  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////


  /// ////////////////////////////////////////////////////////////////////////
  // 1D SolidTElements
  /// ////////////////////////////////////////////////////////////////////////


  //===========================================================
  /// Function to setup geometrical information for lower-dimensional
  /// FaceElements (which are of type SolidTElement<0,1>).
  //===========================================================
  template<unsigned NNODE_1D>
  void SolidTElement<1, NNODE_1D>::build_face_element(
    const int& face_index, FaceElement* face_element_pt)
  {
    // Build the standard non-solid FaceElement
    TElement<1, NNODE_1D>::build_face_element(face_index, face_element_pt);

    // Set the Lagrangian dimension from the first node of the present element
    dynamic_cast<SolidFiniteElement*>(face_element_pt)
      ->set_lagrangian_dimension(
        static_cast<SolidNode*>(node_pt(0))->nlagrangian());
  }


  //=======================================================================
  /// SolidTElement elements, specialised to two spatial dimensions
  //=======================================================================
  template<unsigned NNODE_1D>
  class SolidTElement<2, NNODE_1D> : public virtual TElement<2, NNODE_1D>,
                                     public virtual TSolidElementBase
  {
  public:
    /// Constructor
    SolidTElement()
      : TElementBase(),
        TElement<2, NNODE_1D>(),
        SolidFiniteElement(),
        TSolidElementBase()
    {
      // Set the Lagrangian dimension of the element
      set_lagrangian_dimension(2);
    }

    /// Broken copy constructor
    SolidTElement(const SolidTElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const SolidTElement&) = delete;*/

    /// Build the lower-dimensional FaceElement (an element of type
    /// SolidTElement<1,NNODE_1D>). The face index takes three possible values:
    /// 0 (Left)         s[0] = 0.0
    /// 1 (Bottom)       s[1] = 0.0
    /// 2 (Sloping face) s[0] = 1.0 - s[1]
    inline void build_face_element(const int& face_index,
                                   FaceElement* face_element_pt);
  };


  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////
  // 2D SolidTElements
  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////


  //===========================================================
  /// Function to setup geometrical information for lower-dimensional
  /// FaceElements (which are of type SolidTElement<1,NNODE_1D>).
  //===========================================================
  template<unsigned NNODE_1D>
  void SolidTElement<2, NNODE_1D>::build_face_element(
    const int& face_index, FaceElement* face_element_pt)
  {
    // Build the standard non-solid FaceElement
    TElement<2, NNODE_1D>::build_face_element(face_index, face_element_pt);

    // Set the Lagrangian dimension from the first node of the present element
    dynamic_cast<SolidFiniteElement*>(face_element_pt)
      ->set_lagrangian_dimension(
        static_cast<SolidNode*>(node_pt(0))->nlagrangian());
  }


  //=======================================================================
  /// SolidTElement elements, specialised to three spatial dimensions
  //=======================================================================
  template<unsigned NNODE_1D>
  class SolidTElement<3, NNODE_1D> : public virtual TElement<3, NNODE_1D>,
                                     public virtual TSolidElementBase
  {
  public:
    /// Constructor
    SolidTElement()
      : TElementBase(),
        TElement<3, NNODE_1D>(),
        SolidFiniteElement(),
        TSolidElementBase()
    {
      // Set the Lagrangian dimension of the element
      set_lagrangian_dimension(3);
    }

    /// Broken copy constructor
    SolidTElement(const SolidTElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const SolidTElement&) = delete;*/


    /// Build the lower-dimensional FaceElement (an element of type
    /// SolidTElement<2,NNODE_1D>). The face index can take one of four values
    /// corresponding to the four possible faces:
    /// 0: (left)           s[0] = 0.0
    /// 1: (bottom)         s[1] = 0.0
    /// 2: (back)           s[2] = 0.0
    /// 3: (sloping face)   s[0] + s[1] + s[2] = 1
    inline void build_face_element(const int& face_index,
                                   FaceElement* face_element_pt);
  };


  /// ////////////////////////////////////////////////////////////////////////
  // 3D SolidTElements
  /// ////////////////////////////////////////////////////////////////////////


  //===========================================================
  /// Function to setup geometrical information for lower-dimensional
  /// FaceElements (which are of type SolidTElement<1,NNODE_1D>).
  //===========================================================
  template<unsigned NNODE_1D>
  void SolidTElement<3, NNODE_1D>::build_face_element(
    const int& face_index, FaceElement* face_element_pt)
  {
    // Build the standard non-solid FaceElement
    TElement<3, NNODE_1D>::build_face_element(face_index, face_element_pt);

    // Set the Lagrangian dimension from the first node of the present element
    dynamic_cast<SolidFiniteElement*>(face_element_pt)
      ->set_lagrangian_dimension(
        static_cast<SolidNode*>(node_pt(0))->nlagrangian());
  }


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////

  //=======================================================================
  /// SolidTBubbleEnrichedElement elements are the enriched version
  /// of the SolidTElements. They will simply inherit from the appropriate
  /// SolidTElement and TBubblEnrichedElement.
  /// They are the basis for solid mechanics elements.
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class SolidTBubbleEnrichedElement
  {
  };

  //===================================================================
  /// Specify the SolidTBubbleEnrichedElement corresponding to the
  /// quadratic triangle
  //===================================================================
  template<unsigned DIM>
  class SolidTBubbleEnrichedElement<DIM, 3>
    : public virtual SolidTElement<DIM, 3>,
      public virtual TBubbleEnrichedElement<DIM, 3>
  {
  public:
    /// Constructor
    SolidTBubbleEnrichedElement()
      : SolidTElement<DIM, 3>(), TBubbleEnrichedElement<DIM, 3>()
    {
    }

    /// Broken copy constructor
    SolidTBubbleEnrichedElement(const SolidTBubbleEnrichedElement&) = delete;

    /// Broken assignment operator
    /*void operator=(const SolidTBubbleEnrichedElement&) = delete;*/

    /// Destructor
    ~SolidTBubbleEnrichedElement() {}

    /// Build the lower-dimensional FaceElement
    /// Need to put in a final override here
    void build_face_element(const int& face_index,
                            FaceElement* face_element_pt);
  };


  //=======================================================================
  /// Face geometry for the TElement elements: The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class FaceGeometry<TElement<DIM, NNODE_1D>>
    : public virtual TElement<DIM - 1, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : TElement<DIM - 1, NNODE_1D>() {}
  };


  //=======================================================================
  /// Face geometry for the 1D TElement elements: Point elements
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<TElement<1, NNODE_1D>> : public virtual PointElement
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional TElement
    FaceGeometry() : PointElement() {}
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Face geometry for the 2D TBubbleEnrichedElement elements is exactly
  /// the same as for the corresponding TElement. The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<TBubbleEnrichedElement<2, NNODE_1D>>
    : public virtual TElement<1, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : TElement<1, NNODE_1D>() {}
  };


  //=======================================================================
  /// Face geometry for the 3D TBubbleEnrichedElement elements is the
  /// 2D TBubbleEnrichedElement. The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<TBubbleEnrichedElement<3, NNODE_1D>>
    : public virtual TBubbleEnrichedElement<2, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : TBubbleEnrichedElement<2, NNODE_1D>() {}
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Face geometry for the TElement elements: The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class FaceGeometry<SolidTElement<DIM, NNODE_1D>>
    : public virtual SolidTElement<DIM - 1, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : SolidTElement<DIM - 1, NNODE_1D>() {}
  };


  //=======================================================================
  /// Face geometry for the 1D TElement elements: Point elements
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<SolidTElement<1, NNODE_1D>>
    : public virtual SolidPointElement
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional TElement
    FaceGeometry() : SolidPointElement() {}
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Face geometry for the 2D SolidTBubbleEnrichedElement elements is exactly
  /// the same as for the corresponding 2D SolidTElement. The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<SolidTBubbleEnrichedElement<2, NNODE_1D>>
    : public virtual SolidTElement<1, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : SolidTElement<1, NNODE_1D>() {}
  };


  //=======================================================================
  /// Face geometry for the 3D SolidTBubbleEnrichedElement elements is
  /// the 2D SolidTBubbleEnrichedElement. The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<SolidTBubbleEnrichedElement<3, NNODE_1D>>
    : public virtual SolidTBubbleEnrichedElement<2, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : SolidTBubbleEnrichedElement<2, NNODE_1D>() {}
  };

} // namespace oomph


#endif
