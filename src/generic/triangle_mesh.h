// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2024 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Common base class for all Triangle Meshes
#ifndef OOMPH_GENERIC_TRIANGLE_MESH_HEADER
#define OOMPH_GENERIC_TRIANGLE_MESH_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// Oomph-lib includes
#include "Vector.h"
#include "nodes.h"
#include "matrices.h"
#include "mesh.h"
#include "unstructured_two_d_mesh_geometry_base.h"

namespace oomph
{
  //================================================================
  /// Base class for triangle meshes (meshes made of 2D triangle elements).
  /// Note: we choose to template TriangleMeshBase here because certain
  /// functions in UnstructuredTwoDMeshGeometryBase need template parameters
  /// and it's much cleaner simply to template the entire class
  //================================================================
  class TriangleMeshBase : public virtual UnstructuredTwoDMeshGeometryBase,
                           public virtual Mesh
  {
  public:
    /// Constructor
    TriangleMeshBase()
    {
#ifdef OOMPH_HAS_TRIANGLE_LIB
      // Initialise the TriangulateIO Data structure
      TriangleHelper::initialise_triangulateio(Triangulateio);

      // Enable triangulateio specific parts for dump/restart by default.
      Use_triangulateio_restart = true;
#endif
    }

    /// Broken copy constructor
    TriangleMeshBase(const TriangleMeshBase& node) = delete;

    /// Broken assignment operator
    // Commented out broken assignment operator because this can lead to a
    // conflict warning when used in the virtual inheritence hierarchy.
    // Essentially the compiler doesn't realise that two separate
    // implementations of the broken function are the same and so, quite
    // rightly, it shouts.
    /*void operator=(const TriangleMeshBase&) = delete;*/

    /// Destructor (empty)
    virtual ~TriangleMeshBase()
    {
#ifdef OOMPH_HAS_TRIANGLE_LIB
      // Clear the triangulate data structure
      TriangleHelper::clear_triangulateio(Triangulateio);
#endif
    }

    /// Setup lookup schemes which establish whic elements are located
    /// next to mesh's boundaries (wrapper to suppress doc).
    void setup_boundary_element_info()
    {
      std::ofstream outfile;
      setup_boundary_element_info(outfile);
    }

    // [zdec] work in progress
    /// Divide an element into three by creating edges from the centroid to
    /// each of the vertex nodes. Take the old element pointer and fill out
    /// vectors containing pointers to the new three elements and all the
    /// nodes. Optionally takes a pointer to a timestepper to pass on to the
    /// new elements and nodes.
    template<class ELEMENT>
    void split_element_through_centroid(
      FiniteElement* const& el_pt,
      Vector<FiniteElement*>& new_el_pt,
      Vector<Node*>& new_nod_pt,
      TimeStepper* const& time_stepper_pt = &Mesh::Default_TimeStepper);

    /// Make sure no elements have two boundary edges by splitting them through
    /// their centroid (e.g. no corner elements straddling two boundaries).
    template<class ELEMENT>
    void split_elements_with_multiple_boundary_edges(
      TimeStepper* const& time_stepper_pt = &Mesh::Default_TimeStepper);

    /// Setup lookup schemes which establish which elements are located
    /// next to mesh's boundaries. Doc in outfile (if it's open).
    void setup_boundary_element_info(std::ostream& outfile);

#ifdef OOMPH_HAS_TRIANGLE_LIB
    /// const access for Use_triangulateio_restart.
    bool use_triangulateio_restart() const
    {
      return Use_triangulateio_restart;
    }

    /// write access for Use_triangulateio_restart.
    void enable_triangulateio_restart()
    {
      Use_triangulateio_restart = true;
    }

    /// write access for Use_triangulateio_restart.
    void disable_triangulateio_restart()
    {
      Use_triangulateio_restart = false;
    }

    /// Access to the triangulateio representation of the mesh
    TriangulateIO& triangulateio_representation()
    {
      return Triangulateio;
    }

    /// Helper function. Write a TriangulateIO object file with all the
    /// triangulateio fields. String s is add to assign a different value for
    /// the input and/or output structure
    void write_triangulateio(TriangulateIO& triangulate_io, std::string& s);

    /// Helper function. Clean up the memory associated with the
    /// TriangulateIO object. This should really only be used to save
    /// memory in extremely tight situations.
    void clear_triangulateio()
    {
      TriangleHelper::clear_triangulateio(Triangulateio);
    }

    /// Dump the triangulateio structure to a dump file and
    /// record boundary coordinates of boundary nodes
    void dump_triangulateio(std::ostream& dump_file);

#ifdef OOMPH_HAS_MPI
    /// Virtual function that is used to dump info. related with
    /// distributed triangle meshes
    virtual void dump_distributed_info_for_restart(std::ostream& dump_file)
    {
      std::ostringstream error_stream;
      error_stream << "Empty default dump disributed info. method called.\n";
      error_stream << "This should be overloaded in a specific TriangleMesh\n";
      throw OomphLibError(
        error_stream.str(),
        "TriangleMeshBase::dump_distributed_info_for_restart()",
        OOMPH_EXCEPTION_LOCATION);
    }

    /// Virtual function that is used to dump info. related with
    /// distributed triangle meshes
    virtual void dump_info_to_reset_halo_haloed_scheme(std::ostream& dump_file)
    {
      std::ostringstream error_stream;
      error_stream << "Empty default dump info. to reset halo haloed scheme.\n";
      error_stream << "This should be overloaded in a specific TriangleMesh\n";
      throw OomphLibError(
        error_stream.str(),
        "TriangleMeshBase::dump_info_to_reset_halo_haloed_scheme()",
        OOMPH_EXCEPTION_LOCATION);
    }

    /// Virtual function that is used to read info. related with
    /// distributed triangle meshes
    virtual void read_distributed_info_for_restart(std::istream& restart_file)
    {
      std::ostringstream error_stream;
      error_stream << "Empty default read disributed info. method called.\n";
      error_stream << "This should be overloaded in a specific TriangleMesh\n";
      throw OomphLibError(
        error_stream.str(),
        "TriangleMeshBase::read_distributed_info_for_restart()",
        OOMPH_EXCEPTION_LOCATION);
    }

    /// Virtual function used to re-establish any additional info. related with
    /// the distribution after a re-starting for triangle meshes
    virtual void reestablish_distribution_info_for_restart(
      OomphCommunicator* comm_pt, std::istream& restart_file)
    {
      std::ostringstream error_stream;
      error_stream << "Empty default reestablish disributed info method "
                   << "called.\n";
      error_stream << "This should be overloaded in a specific "
                   << "RefineableTriangleMesh\n";
      throw OomphLibError(
        error_stream.str(),
        "TriangleMeshBase::reestablish_distribution_info_for_restart()",
        OOMPH_EXCEPTION_LOCATION);
    }
#endif

    /// Virtual function used to update the polylines representation after
    /// restart
    virtual void update_polyline_representation_from_restart()
    {
      std::ostringstream error_stream;
      error_stream << "Empty default update polylines representation from "
                   << "restart method called.\n";
      error_stream << "This should be overloaded in a specific "
                   << "RefineableTriangleMesh\n";
      throw OomphLibError(
        error_stream.str(),
        "TriangleMeshBase::update_polyline_representation_from_restart()",
        OOMPH_EXCEPTION_LOCATION);
    }

    /// Regenerate the mesh from a dumped triangulateio file
    /// and dumped boundary coordinates of boundary nodes
    void remesh_from_triangulateio(std::istream& restart_file);

    /// Virtual function that is used for specific remeshing from the
    /// triangulateio
    virtual void remesh_from_internal_triangulateio()
    {
      std::ostringstream error_stream;
      error_stream << "Empty default remesh function called.\n";
      error_stream << "This should be overloaded in a specific TriangleMesh\n";
      throw OomphLibError(
        error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
    }

#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB

    /// Virtual function to perform the load balance rutines
    virtual void load_balance(
      const Vector<unsigned>& target_domain_for_local_non_halo_element)
    {
      std::ostringstream error_stream;
      error_stream << "Empty default load balancing function called.\n";
      error_stream << "This should be overloaded in a specific TriangleMesh\n";
      throw OomphLibError(error_stream.str(),
                          "TriangleMeshBase::load_balance()",
                          OOMPH_EXCEPTION_LOCATION);
    }

    /// Virtual function to perform the reset boundary elements info rutines
    virtual void reset_boundary_element_info(
      Vector<unsigned>& ntmp_boundary_elements,
      Vector<Vector<unsigned>>& ntmp_boundary_elements_in_region,
      Vector<FiniteElement*>& deleted_elements)
    {
      std::ostringstream error_stream;
      error_stream << "Empty default reset boundary element info function"
                   << "called.\n";
      error_stream << "This should be overloaded in a specific "
                   << "TriangleMesh\n";
      throw OomphLibError(error_stream.str(),
                          "TriangleMeshBase::reset_boundary_element_info()",
                          OOMPH_EXCEPTION_LOCATION);
    }

  protected:
#ifdef OOMPH_HAS_TRIANGLE_LIB

    /// TriangulateIO representation of the mesh
    TriangulateIO Triangulateio;

    /// Should we use triangulateio specific parts for dump/restart? (Doesn't
    /// work with some elements and isn't needed if not using adaptivity).
    bool Use_triangulateio_restart;

#endif // OOMPH_HAS_TRIANGLE
  };


  //==========================================================================
  /// Divide an element into three by creating edges from the centroid to
  /// each of the vertex nodes. Takes an element pointer
  //==========================================================================
  template<class ELEMENT>
  void TriangleMeshBase::split_element_through_centroid(
    FiniteElement* const& el_pt,
    Vector<FiniteElement*>& new_el_pt,
    Vector<Node*>& new_nod_pt,
    TimeStepper* const& time_stepper_pt)
  {
#ifdef PARANOID
    // Maybe check that the element belongs to this mesh?
    // (this seems like a good idea)
#endif

    // Get the type of triangle element we are using
    unsigned n_node_1d = el_pt->nnode_1d();
    unsigned dim = el_pt->dim();

    // We split the element depending on the number of nodes
    switch (n_node_1d)
    {
      case 2:
      {
        // In this case, we need to add one new node c at the centroid of the
        // original element. This becomes node i of the ith element.
        //
        //  o2                          o2              //
        //  | \                         |\\             //
        //  |   \                       | \ \           //
        //  |     \          becomes:   |  \  \         //
        //  |       \                   |   c_  \       //
        //  |         \                 | /    - _\     //
        //  o0----------o1              o0----------o1  //

        //-----------------------------------------------------------------------
        // We start by creating the new elements
        FiniteElement* el0_pt = new ELEMENT;
        FiniteElement* el1_pt = new ELEMENT;
        FiniteElement* el2_pt = new ELEMENT;

        // Store the old node pointers
        Node* o0_pt = el_pt->node_pt(0);
        Node* o1_pt = el_pt->node_pt(1);
        Node* o2_pt = el_pt->node_pt(2);

        // Next, we create the new node (using the construct node function
        // ensures that dof memory is properly allocated for us)
        Node* c_pt = el0_pt->construct_node(0, time_stepper_pt);

        // We have three elements, fill the vector of new elements
        new_el_pt.resize(3);
        new_el_pt[0] = el0_pt;
        new_el_pt[1] = el1_pt;
        new_el_pt[2] = el2_pt;

        // We have four nodes, fill the vector of new nodes
        new_nod_pt.resize(4);
        new_nod_pt[0] = o0_pt;
        new_nod_pt[1] = o1_pt;
        new_nod_pt[2] = o2_pt;
        new_nod_pt[3] = c_pt;

        // Set the locations of the new node
        for (unsigned i = 0; i < dim; i++)
        {
          // c is the centroid of the original element
          c_pt->x(i) = (o0_pt->x(i) + o1_pt->x(i) + o2_pt->x(i)) / 3.0;
        }

        // And assign the nodes to the new elements
        // (el0, node 0 is already assigned due to its construction but we leave
        //  it commented here for completeness)

        // Element 0
        // el0_pt->node_pt(0) = c_pt;
        el0_pt->node_pt(1) = o1_pt;
        el0_pt->node_pt(2) = o2_pt;

        // Element 1
        el1_pt->node_pt(0) = o0_pt;
        el1_pt->node_pt(1) = c_pt;
        el1_pt->node_pt(2) = o2_pt;

        // Element 2
        el2_pt->node_pt(0) = o0_pt;
        el2_pt->node_pt(1) = o1_pt;
        el2_pt->node_pt(2) = c_pt;

        return;
      }

      case 3:
      {
        // In this case, we need to add one new node at the original centroid c,
        // and one new node for the midside of each of the new edges a_i where
        // i=0,1,2.
        //
        //  o2                          //
        //  | \                         //
        //  |   \                       //
        //  |     \                     //
        //  |       \                   //
        //  |         \                 //
        //  o5          o4              //
        //  |             \             //
        //  |               \           //
        //  |                 \         //
        //  |                   \       //
        //  |                     \     //
        //  o0----------o3----------o1  //
        //
        // becomes three new elements with nodes o_j, a_i and c with i=0,1,2
        // and j=0,..,5:
        //
        //  o2                          //
        //  |\\                         //
        //  | \ \                       //
        //  |  \  \                     //
        //  |   a2  \                   //
        //  |    \    \                 //
        //  o5    \     o4              //
        //  |      \(el 0)\             //
        //  |(el 1) c_      \           //
        //  |     /    - _    \         //
        //  |   a0         a1_  \       //
        //  | /    (el 2)      - _\     //
        //  o0----------o3----------o1  //

        //---------------------------------------------------------------------
        // We start by creating the new elements
        FiniteElement* el0_pt = new ELEMENT;
        FiniteElement* el1_pt = new ELEMENT;
        FiniteElement* el2_pt = new ELEMENT;

        // Store the old node pointers
        Node* o0_pt = el_pt->node_pt(0);
        Node* o1_pt = el_pt->node_pt(1);
        Node* o2_pt = el_pt->node_pt(2);
        Node* o3_pt = el_pt->node_pt(3);
        Node* o4_pt = el_pt->node_pt(4);
        Node* o5_pt = el_pt->node_pt(5);

        // Next, we create the new nodes (using the construct node function
        // ensures that dof memory is properly allocated for us)
        Node* c_pt = el0_pt->construct_node(0, time_stepper_pt);
        Node* a0_pt = el1_pt->construct_node(3, time_stepper_pt);
        Node* a1_pt = el0_pt->construct_node(3, time_stepper_pt);
        Node* a2_pt = el0_pt->construct_node(5, time_stepper_pt);

        // We have three elements, fill the vector of new elements
        new_el_pt.resize(3);
        new_el_pt[0] = el0_pt;
        new_el_pt[1] = el1_pt;
        new_el_pt[2] = el2_pt;

        // We have ten nodes, fill the vector of new nodes
        new_nod_pt.resize(10);
        new_nod_pt[0] = o0_pt;
        new_nod_pt[1] = o1_pt;
        new_nod_pt[2] = o2_pt;
        new_nod_pt[3] = o3_pt;
        new_nod_pt[4] = o4_pt;
        new_nod_pt[5] = o5_pt;
        new_nod_pt[6] = a0_pt;
        new_nod_pt[7] = a1_pt;
        new_nod_pt[8] = a2_pt;
        new_nod_pt[9] = c_pt;

        // Set the locations of the new nodes
        for (unsigned i = 0; i < dim; i++)
        {
          // First c, which is the centroid of the old element
          c_pt->x(i) = (o0_pt->x(i) + o1_pt->x(i) + o2_pt->x(i)) / 3.0;
          // Next a_i, which are half way between o_i and c
          a0_pt->x(i) = (o0_pt->x(i) + c_pt->x(i)) / 2.0;
          a1_pt->x(i) = (o1_pt->x(i) + c_pt->x(i)) / 2.0;
          a2_pt->x(i) = (o2_pt->x(i) + c_pt->x(i)) / 2.0;
        }

        // And assign the nodes to the new elements
        // (some are already assigned due to their construction but we leave
        //  them commented here for completeness)

        // Element 0
        // el0_pt->node_pt(0) = c_pt;
        el0_pt->node_pt(1) = o1_pt;
        el0_pt->node_pt(2) = o2_pt;
        // el0_pt->node_pt(3) = a1_pt;
        el0_pt->node_pt(4) = o4_pt;
        // el0_pt->node_pt(5) = a2_pt;

        // Element 1
        el1_pt->node_pt(0) = o0_pt;
        el1_pt->node_pt(1) = c_pt;
        el1_pt->node_pt(2) = o2_pt;
        // el1_pt->node_pt(3) = a0_pt;
        el1_pt->node_pt(4) = o2_pt;
        el1_pt->node_pt(5) = o5_pt;

        // Element 2
        el2_pt->node_pt(0) = o0_pt;
        el2_pt->node_pt(1) = o1_pt;
        el2_pt->node_pt(2) = c_pt;
        el2_pt->node_pt(3) = o3_pt;
        el2_pt->node_pt(4) = a1_pt;
        el2_pt->node_pt(5) = a0_pt;

        return;
      }

      case 4:
      {
        // In this case, we retain the original 10 nodes o_j and  need to
        // create 9 new nodes: two for each of the three new edges that join
        // the new elements a_i and b_i, and three mode at the centroids of
        // each new element c_i for i=0,1,2.
        //
        // [zdec] IMPORTANT: o9 may need resizing as it is the only node to go
        // from a centre node to a vertex node (changing type). To account for
        // this, we reconstruct it.
        //
        // The original element:
        //
        //  o2                                     //
        //  | \                                    //
        //  |   \                                  //
        //  |     \                                //
        //  |       \                              //
        //  |         \                            //
        //  o7          o6                         //
        //  |             \                        //
        //  |               \                      //
        //  |                 \                    //
        //  |                   \                  //
        //  |                     \                //
        //  o8          o9          o5             //
        //  |                         \            //
        //  |                           \          //
        //  |                             \        //
        //  |                               \      //
        //  |                                 \    //
        //  o0----------o3----------o4----------o1 //
        //                                         //
        //
        // becomes three new elements with nodes o_j, a_i, b_i, and c_i
        // for i=0,1,2, j=0,..,9:
        //
        //                                         //
        //  o2                                     //
        //  |\\                                    //
        //  | \ \                                  //
        //  |  \  \                                //
        //  |   a2  \                              //
        //  |    \    \                            //
        //  o7    \     o6                         //
        //  |      \      \                        //
        //  |       b2      \                      //
        //  |        \        \                    //
        //  |   c1    \    c0   \                  //
        //  |          \  (el 0)  \                //
        //  o8 (el 1)   o9_         o5             //
        //  |         /     - _       \            //
        //  |       b0          b1_     \          //
        //  |     /       c2        - _   \        //
        //  |   a0         (el 2)       a1_ \      //
        //  | /                             - \    //
        //  o0----------o3----------o4----------o1 //

        //---------------------------------------------------------------------
        // We start by creating the new elements
        FiniteElement* el0_pt = new ELEMENT;
        FiniteElement* el1_pt = new ELEMENT;
        FiniteElement* el2_pt = new ELEMENT;

        // Store the old node pointers
        Node* o0_pt = el_pt->node_pt(0);
        Node* o1_pt = el_pt->node_pt(1);
        Node* o2_pt = el_pt->node_pt(2);
        Node* o3_pt = el_pt->node_pt(3);
        Node* o4_pt = el_pt->node_pt(4);
        Node* o5_pt = el_pt->node_pt(5);
        Node* o6_pt = el_pt->node_pt(6);
        Node* o7_pt = el_pt->node_pt(7);
        Node* o8_pt = el_pt->node_pt(8);
        Node* o9_pt = el_pt->node_pt(9);

        // Reconstruct o9 as it changes from centroid node to vertex node, it
        // may have different storage requirements
        // Temp pointer to delete o9
        Node* o9_temp_pt = o9_pt;
        // Reconstruct
        o9_pt = el0_pt->construct_node(0, time_stepper_pt);
        // Copy the position
        o9_pt->x(0) = o9_temp_pt->x(0);
        o9_pt->x(1) = o9_temp_pt->x(1);
        // Delete the original centre node
        delete o9_temp_pt;
        o9_temp_pt = 0;

        // Next, we create the new nodes (using the construct node function
        // ensures that dof memory is properly allocated for us)
        Node* a0_pt = el1_pt->construct_node(3, time_stepper_pt);
        Node* a1_pt = el0_pt->construct_node(4, time_stepper_pt);
        Node* a2_pt = el0_pt->construct_node(7, time_stepper_pt);
        Node* b0_pt = el1_pt->construct_node(4, time_stepper_pt);
        Node* b1_pt = el0_pt->construct_node(3, time_stepper_pt);
        Node* b2_pt = el0_pt->construct_node(8, time_stepper_pt);
        Node* c0_pt = el0_pt->construct_node(9, time_stepper_pt);
        Node* c1_pt = el1_pt->construct_node(9, time_stepper_pt);
        Node* c2_pt = el2_pt->construct_node(9, time_stepper_pt);

        // We have three elements, fill the vector of new elements
        new_el_pt.resize(3);
        new_el_pt[0] = el0_pt;
        new_el_pt[1] = el1_pt;
        new_el_pt[2] = el2_pt;

        // We have nineteen nodes, fill the vector of new nodes
        new_nod_pt.resize(19);
        new_nod_pt[0] = o0_pt;
        new_nod_pt[1] = o1_pt;
        new_nod_pt[2] = o2_pt;
        new_nod_pt[3] = o3_pt;
        new_nod_pt[4] = o4_pt;
        new_nod_pt[5] = o5_pt;
        new_nod_pt[6] = o6_pt;
        new_nod_pt[7] = o7_pt;
        new_nod_pt[8] = o8_pt;
        new_nod_pt[9] = o9_pt;
        new_nod_pt[10] = a0_pt;
        new_nod_pt[11] = a1_pt;
        new_nod_pt[12] = a2_pt;
        new_nod_pt[13] = b0_pt;
        new_nod_pt[14] = b1_pt;
        new_nod_pt[15] = b2_pt;
        new_nod_pt[16] = c0_pt;
        new_nod_pt[17] = c1_pt;
        new_nod_pt[18] = c2_pt;

        // Set the locations of the new nodes
        for (unsigned i = 0; i < dim; i++)
        {
          // First a_i, which are one third of the way from o_i to o_9
          a0_pt->x(i) = (2.0 * o0_pt->x(i) + o9_pt->x(i)) / 3.0;
          a1_pt->x(i) = (2.0 * o1_pt->x(i) + o9_pt->x(i)) / 3.0;
          a2_pt->x(i) = (2.0 * o2_pt->x(i) + o9_pt->x(i)) / 3.0;
          // Next b_i, which are two thirds of the way from o_i to o_9
          b0_pt->x(i) = (2.0 * o9_pt->x(i) + o0_pt->x(i)) / 3.0;
          b1_pt->x(i) = (2.0 * o9_pt->x(i) + o1_pt->x(i)) / 3.0;
          b2_pt->x(i) = (2.0 * o9_pt->x(i) + o2_pt->x(i)) / 3.0;
          // Lastly c_i, which are the centroids of the new elements
          c0_pt->x(i) = (o1_pt->x(i) + o2_pt->x(i) + o9_pt->x(i)) / 3.0;
          c1_pt->x(i) = (o2_pt->x(i) + o0_pt->x(i) + o9_pt->x(i)) / 3.0;
          c2_pt->x(i) = (o0_pt->x(i) + o1_pt->x(i) + o9_pt->x(i)) / 3.0;
        }

        // And assign the nodes to the new elements
        // (some are already assigned due to their construction but we leave
        //  them commented here for completeness)

        // Element 0
        el0_pt->node_pt(0) = o9_pt;
        el0_pt->node_pt(1) = o1_pt;
        el0_pt->node_pt(2) = o2_pt;
        // el0_pt->node_pt(3) = b1_pt;
        // el0_pt->node_pt(4) = a1_pt;
        el0_pt->node_pt(5) = o5_pt;
        el0_pt->node_pt(6) = o6_pt;
        // el0_pt->node_pt(7) = a2_pt;
        // el0_pt->node_pt(8) = b2_pt;
        // el0_pt->node_pt(9) = c0_pt;

        // Element 1
        el1_pt->node_pt(0) = o0_pt;
        el1_pt->node_pt(1) = o9_pt;
        el1_pt->node_pt(2) = o2_pt;
        // el1_pt->node_pt(3) = a0_pt;
        // el1_pt->node_pt(4) = b0_pt;
        el1_pt->node_pt(5) = b2_pt;
        el1_pt->node_pt(6) = a2_pt;
        el1_pt->node_pt(7) = o7_pt;
        el1_pt->node_pt(8) = o8_pt;
        // el1_pt->node_pt(9) = c1_pt;

        // Element 2
        el2_pt->node_pt(0) = o0_pt;
        el2_pt->node_pt(1) = o1_pt;
        el2_pt->node_pt(2) = o9_pt;
        el2_pt->node_pt(3) = o3_pt;
        el2_pt->node_pt(4) = o4_pt;
        el2_pt->node_pt(5) = a1_pt;
        el2_pt->node_pt(6) = b1_pt;
        el2_pt->node_pt(7) = b0_pt;
        el2_pt->node_pt(8) = a0_pt;
        // el2_pt->node_pt(9) = c2_pt;

        return;
      }

      default:
      {
        std::string error_message =
          (std::string)("Triangle elements must have nnode_1d = 2,3 or 4.\n"
                        "This element returned nnode_1d() = ") +
          std::to_string(n_node_1d);
        throw OomphLibError(
          error_message, OOMPH_EXCEPTION_LOCATION, OOMPH_CURRENT_FUNCTION);
      }

    } // end switch statement
  }


  //==========================================================================
  /// Make sure no elements have two boundary edges by splitting them through
  /// their centroid (e.g. corner elements straddling both boundaries)
  //==========================================================================
  template<class ELEMENT>
  void TriangleMeshBase::split_elements_with_multiple_boundary_edges(
    TimeStepper* const& time_stepper_pt)
  {
    // Setup boundary lookup scheme if required
    if (!Lookup_for_elements_next_boundary_is_setup)
    {
      setup_boundary_element_info();
    }

    // Map to store how many boundaries elements are located on
    std::map<FiniteElement*, unsigned> count;

    // [zdec] debug
    std::string filename_old = "element_debug_file_orig.dat";
    std::ofstream element_debug_old;
    element_debug_old.open(filename_old,
                           std::ofstream::out | std::ofstream::trunc);
    element_debug_old.close();
    std::string filename_n_old = "node_debug_file_orig.dat";
    element_debug_old.open(filename_n_old,
                           std::ofstream::out | std::ofstream::trunc);
    element_debug_old.close();
    for (unsigned e = 0; e < nelement(); e++)
    {
      // [zdec] debug: doc all the elements to see the mesh patches
      oomph_info << "Adding element " << e << " at " << finite_element_pt(e)
                 << " nodes to debug file" << std::endl;
      element_debug_old.open(filename_old, std::ios_base::app);
      // loop over the vertex nodes
      for (unsigned i = 0; i < 3; i++)
      {
        element_debug_old << finite_element_pt(e)->node_pt(i)->x(0) << " ";
        element_debug_old << finite_element_pt(e)->node_pt(i)->x(1) << " ";
        element_debug_old << std::endl;
      }
      element_debug_old << finite_element_pt(e)->node_pt(0)->x(0) << " ";
      element_debug_old << finite_element_pt(e)->node_pt(0)->x(1) << " ";
      element_debug_old << std::endl;
      element_debug_old << std::endl << std::endl;
      element_debug_old.close();
      // Loop over all nodes
      element_debug_old.open(filename_n_old, std::ios_base::app);
      for (unsigned i = 0; i < finite_element_pt(e)->nnode(); i++)
      {
        element_debug_old << finite_element_pt(e)->node_pt(i)->x(0) << " ";
        element_debug_old << finite_element_pt(e)->node_pt(i)->x(1) << " ";
        element_debug_old << std::endl;
      }
      element_debug_old << std::endl << std::endl;
      element_debug_old.close();
    }

    // Count the number of boundaries each element is on
    unsigned nb = this->nboundary();
    for (unsigned b = 0; b < nb; b++)
    {
      // Loop over elements next to that boundary
      unsigned nel = this->nboundary_element(b);
      for (unsigned e = 0; e < nel; e++)
      {
        // Get pointer to element
        FiniteElement* el_pt = boundary_element_pt(b, e);
        // Bump up counter
        count[el_pt]++;

        // [zdec] debug
        oomph_info << "Element at " << el_pt << " has " << count[el_pt]
                   << " boundaries" << std::endl;
      }
    }

    // To avoid having to check the map for all elements (which will
    // inflate it to the size of all elements!), move offending elements
    // into set
    std::set<FiniteElement*> elements_to_be_split;
    for (std::map<FiniteElement*, unsigned>::iterator it = count.begin();
         it != count.end();
         it++)
    {
      // Get pointer to element: Key
      FiniteElement* el_pt = it->first;
      // Does it have to be split?
      if (it->second > 1)
      {
        elements_to_be_split.insert(el_pt);
      }
    }

    // Vector for retained or newly built elements
    unsigned n_el = this->nelement();
    Vector<FiniteElement*> new_or_retained_el_pt;
    new_or_retained_el_pt.reserve(n_el);

    //  Set for retained or newly built nodes
    // (we use a set to prevent node pointer repetition which is hard to track)
    std::set<Node*> new_or_retained_nod_pt;

    // Map which returns the 3 newly created elements for each old corner
    // element
    std::map<FiniteElement*, Vector<FiniteElement*>> old_to_new_element_map;


    // Loop over the elements
    for (unsigned e = 0; e < n_el; e++)
    {
      // Get pointer to the element
      FiniteElement* el_pt = this->finite_element_pt(e);

      // [zdec] is this the best way??
      // Does it have to be split? I.e. is it in the set?
      std::set<FiniteElement*>::iterator it = std::find(
        elements_to_be_split.begin(), elements_to_be_split.end(), el_pt);

      // It's not in the set, so iterator has reached end
      if (it == elements_to_be_split.end())
      {
        // Carry it across
        new_or_retained_el_pt.push_back(el_pt);
        // Carry across its nodes
        unsigned n_el_nod = el_pt->nnode();
        for (unsigned i_el_nod = 0; i_el_nod < n_el_nod; i_el_nod++)
        {
          Node* nod_pt = el_pt->node_pt(i_el_nod);
          new_or_retained_nod_pt.insert(nod_pt);
        }
      }
      // It's in the set of elements to be split
      else
      {
        // [zdec] debug
        oomph_info << "Splitting element " << e << " at " << el_pt
                   << " into: " << std::endl;
        // Vector to get the pointers to the new elements
        Vector<FiniteElement*> new_el_pt(3, 0);
        Vector<Node*> new_nod_pt;

        // Split the element
        split_element_through_centroid<ELEMENT>(
          time_stepper_pt, el_pt, new_el_pt, new_nod_pt);

        // Add the new elements to new the Vector of pointers
        new_or_retained_el_pt.push_back(new_el_pt[0]);
        new_or_retained_el_pt.push_back(new_el_pt[1]);
        new_or_retained_el_pt.push_back(new_el_pt[2]);

        // Add the nodes to the new Vector of pointers
        unsigned n_new_nod = new_nod_pt.size();
        for (unsigned i_new_nod = 0; i_new_nod < n_new_nod; i_new_nod++)
        {
          new_or_retained_nod_pt.insert(new_nod_pt[i_new_nod]);
        }

        // Add the vector to the map
        old_to_new_element_map.insert(
          std::pair<FiniteElement*, Vector<FiniteElement*>>(el_pt, new_el_pt));

        // Delete the old element
        delete el_pt;
      }
    } // End loop over elements [e]

    // Update mesh storage and lookup schemes for new Vector of elements
    //--------------------------------------------------------------------------

    // Copy new vector of finite elements to meshes storage
    // Flush element storage
    Element_pt.clear();

    // Copy across elements
    n_el = new_or_retained_el_pt.size();
    Element_pt.resize(n_el);
    // [zdec] debug
    std::string filename = "element_debug_file.dat";
    std::string filename_n = "node_debug_file.dat";
    std::ofstream element_debug;
    element_debug.open(filename, std::ofstream::out | std::ofstream::trunc);
    element_debug.close();
    element_debug.open(filename_n, std::ofstream::out | std::ofstream::trunc);
    element_debug.close();
    for (unsigned e = 0; e < n_el; e++)
    {
      // [zdec] debug: doc all the elements to see the mesh patches
      oomph_info << "Adding element " << e << " at " << new_or_retained_el_pt[e]
                 << " nodes to debug file" << std::endl;
      element_debug.open(filename, std::ios_base::app);
      // loop over the vertex nodes
      for (unsigned i = 0; i < 3; i++)
      {
        element_debug << new_or_retained_el_pt[e]->node_pt(i)->x(0) << " "
                      << new_or_retained_el_pt[e]->node_pt(i)->x(1) << " "
                      << std::endl;
      }
      element_debug << new_or_retained_el_pt[e]->node_pt(0)->x(0) << " "
                    << new_or_retained_el_pt[e]->node_pt(0)->x(1) << " "
                    << std::endl
                    << std::endl
                    << std::endl;
      element_debug.close();
      // Loop over all nodes
      element_debug.open(filename_n, std::ios_base::app);
      for (unsigned i = 0; i < new_or_retained_el_pt[e]->nnode(); i++)
      {
        element_debug << new_or_retained_el_pt[e]->node_pt(i)->x(0) << " "
                      << new_or_retained_el_pt[e]->node_pt(i)->x(1) << " "
                      << std::endl;
      }
      element_debug << std::endl << std::endl;
      element_debug.close();
      Element_pt[e] = new_or_retained_el_pt[e];
    }

    // Copy across nodes
    Node_pt.clear();
    Node_pt.insert(Node_pt.end(),
                   new_or_retained_nod_pt.begin(),
                   new_or_retained_nod_pt.end());

    // Setup boundary lookup scheme again
    setup_boundary_element_info();


    // [zdec] THIS WAS JUST COPIED AND NEEDS CHECKING
    // -------------------------------------------------------------------------
    // The various boundary/region lookups now need updating to account for the
    // newly added/removed elements. This will be done in two stages:
    // Step 1: Add the new elements to the vector of elements in the same region
    //         as the original corner element, and then delete the originals.
    //         Updating this lookup makes things easier in the following step.
    // Step 2: Regenerate the two more specific lookups: One which gives the
    //         elements on a given boundary in a given region, and the other
    //         which maps elements on a given boundary in a given region to the
    //         element's face index on that boundary.
    //
    // N.B. the lookup Triangular_facet_vertex_boundary_coordinate is setup in
    // the call to setup_boundary_element_info() above so doesn't need
    // additional work.

    // if we have no regions then we have no lookups to update so we're done
    // here
    if (Region_attribute.size() == 0)
    {
      return;
    }
    // if we haven't had to split any elements then don't need to fiddle
    // with the lookups
    if (old_to_new_element_map.size() == 0)
    {
      oomph_info << "\nNo elements need splitting\n\n";
      return;
    }
  }


} // namespace oomph

#endif
