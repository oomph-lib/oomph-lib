//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_LAGRANGE_ENFORCED_FLOW_PRECONDITIONERS_HEADER
#define OOMPH_LAGRANGE_ENFORCED_FLOW_PRECONDITIONERS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


// oomphlib headers
#include "../generic/matrices.h"
#include "../generic/assembly_handler.h"
#include "../generic/problem.h"
#include "../generic/block_preconditioner.h"
#include "../generic/preconditioner.h"
#include "../generic/SuperLU_preconditioner.h"
#include "../generic/matrix_vector_product.h"
#include "navier_stokes_elements.h"
#include "refineable_navier_stokes_elements.h"
#include "navier_stokes_preconditioners.h"
//#include <algorithm>


namespace oomph
{
//=============================================================================
/// \short The preconditioner for the Lagrange multiplier constrained
/// Navier-Stokes equations. The velocity components are constrained by
/// Lagrange multiplier, which are applied via OOMPH-LIB's FACE elements.
/// 
/// A Vector of meshes is taken, each mesh contains a different type of
/// block preconditionable element. Each element must not only classify it's 
/// own degrees of freedom but also the associated dof from the 'bulk' element.
/// 
/// The first mesh in the Vector Mesh_pt is assumed to be the 'bulk' mesh.
/// The rest are assumed to contain FACEELMENTS applying the required 
/// constraint.
/// 
/// Thus the most general block structure (in 3D) is: 
/// 
///  0 1 2 3   4 5 6 7  8  ..x   x+0 x+1 x+2 x+3 x+4 
/// [u v w p] [u v w l1 l2 ...] [u   v   w   l1  l2 ...] ... 
///   Bulk       Surface 1             Surface 2         ... 
/// 
/// where the dof types in [] are the dof types in each mesh.
/// It is assumed that in all surface mesh (after the bulk mesh), the first
/// spatial dimension number of dof types are the constrained velocity.
/// 
/// Consider the case of imposing parallel outflow (3 constrained velocity
/// dof types and 2 lagrange multiplier dof types) and tangential flow (3
/// constrained velocity dof types and 1 lagrange multiplier dof type)
/// along two different boundaries in 3D. The resulting natural block dof
/// type structure is: 
/// [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12 ]
/// [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
/// 
/// Given that we know the spatial dimension of the problem, this information
/// can be conveniently stored in a Vector N_doftype_in_mesh = [4, 5, 4]. This
/// Vector will be used to re-order the dof types to group together the
/// velocity, pressure, then lagrange dof types like so: 
/// 
///  0 4  9  1 5  10  2 6  11    3    7   8  12   
/// [u up ut v vp vt  w wp wt ] [p] [Lp1 Lp2 Lt1] 
///
///    0 4  9  1 5  10  2 6  11  3  7   8  12   
///    u up ut v vp vt  w wp wt  p Lp1 Lp2 Lt1  
///  ..... this is too hard to do without Latex....
///
/// We use the preconditioner in the form... check my first year report...
/// 
/// Giving rise to the blocked Jacobian:
/// F G^t
///      L
/// D   
///  L
/// 
/// Here F is the momemtum block, G the discrete gradient operator,
/// and D the discrete divergence operator. (For unstabilised elements, 
/// we have D = G^T and in much of the literature the divergence matrix is 
/// denoted by B.) The L blocks
//=============================================================================
 class LagrangeEnforcedflowPreconditioner
  : public BlockPreconditioner<CRDoubleMatrix>
 {
   public:


  /// Constructor - sets the defaults for control flags
   LagrangeEnforcedflowPreconditioner():BlockPreconditioner<CRDoubleMatrix>()
   {
    // Set default preconditioners
    Navier_stokes_preconditioner_pt = 0;

    // new temp exact prec
    Exact_prec_pt = 0;

    // flag to indicate whether the default w preconditioner is used
    Using_superlu_w_preconditioner = true;

    // flag to indicate to use SuperLU or not.
    Using_superlu_ns_preconditioner = true;

    // flag to indicate LSC preconditioner
    Use_default_norm_of_f_scaling = true;
    Scaling_sigma = 0.0;
    Scaling_sigma_multiplier = 1.0;
    N_lagrange_doftypes = 0;
    N_fluid_doftypes = 0;

    N_velocity_doftypes = 0;

    Doc_time = false;

    Doc_prec = false;

    Doc_linear_solver_info_pt = 0;

    Use_diagonal_w_block = true;

    Mapping_info_calculated = false;

    First_NS_solve = true;

    Label_pt = 0;

    Doc_prec_directory_pt = 0;
   }

  /// destructor
  virtual ~LagrangeEnforcedflowPreconditioner()
   {
    this->clean_up_memory();
   }

  /// Broken copy constructor
  LagrangeEnforcedflowPreconditioner (const LagrangeEnforcedflowPreconditioner&)
   {
    BrokenCopy::broken_copy("LagrangeEnforcedflowPreconditioner");
   }

  /// Broken assignment operator
  void operator=(const LagrangeEnforcedflowPreconditioner&)
   {
    BrokenCopy::broken_assign(" LagrangeEnforcedflowPreconditioner");
   }

  /// Setup method for the LagrangeEnforcedflowPreconditioner.
  void setup();

  /// Add a scalar to each of the diagonal entry of a matrix.
  void add_scaling_to_diag(double &Scaling, CRDoubleMatrix *&block_pt);

  /// Extract the diagonal entries of a matrix.
  void get_diag(CRDoubleMatrix *&block_pt, Vector<double>& diag);

  /// Element-wise addition of two matrices.
  void add_matrices(CRDoubleMatrix *&block_pt1, CRDoubleMatrix *&block_pt2);

  /// Use the diagonal approximation for the W block.
  void use_diagonal_w_block() {Use_diagonal_w_block = true;}

  /// Use block diagonal W block.
  void use_block_diagonal_w_block() {Use_diagonal_w_block  = false;}

  ///Enable documentation of time
  void enable_doc_prec() {Doc_prec = true;}

  ///Disable documentation of time
  void disable_doc_prec() {Doc_prec = false;}

  ///Enable documentation of time
  void enable_doc_time() {Doc_time = true;}

  ///Disable documentation of time
  void disable_doc_time() {Doc_time = false;}
  
  void set_label_pt(std::string* label_pt) 
  {
   Label_pt = label_pt;
  }

  void set_doc_prec_directory_pt(std::string* doc_prec_directory_pt) 
  {
   Doc_prec_directory_pt = doc_prec_directory_pt;
  }

  /// \short Apply the preconditioner.
  /// r is the residual (rhs), z will contain the solution.
  void preconditioner_solve(const DoubleVector& r, DoubleVector& z)
  {
   // // Counter for the current linear solver iteration.
   // // This is used when dumping the rhs block vector,
   // // we only want the first Newton Step.
    if(Doc_prec && First_NS_solve)
    {
      std::string currentsetting 
        = *Label_pt + "NS"
          + StringConversion::to_string(Doc_linear_solver_info_pt
                                        ->current_nnewton_step());
      // Dump out the block rhs if  it is the first Newton Iteration.
      DoubleVector x; // Will contain the re-ordered rhs
      this->get_block_ordered_preconditioner_vector(r,x);
      x.output( *Doc_prec_directory_pt + "/rhsx_" + currentsetting,15);
    }

   // Working vectors.
   DoubleVector temp_vec;
   DoubleVector another_temp_vec;
   DoubleVector yet_another_temp_vec;

   // First we solve all the w blocks:
   // Loop through all of the Lagrange multipliers
   for(unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++)
    {
     // Get the block type of block l_i
     unsigned l_ii = N_fluid_doftypes + l_i;

     // Extract the block
     this->get_block_vector(l_ii,r,temp_vec);
     W_preconditioner_pts[l_i]->preconditioner_solve(temp_vec,
                                                     another_temp_vec);

     this->return_block_vector(l_ii,another_temp_vec,z);
     temp_vec.clear();
     another_temp_vec.clear();
    }
   
   // Now solve the Navier-Stokes block.

   // At this point, all vectors are cleared.
   if(Using_superlu_ns_preconditioner)
    {
     // Concatenate the fluid block vectors
     Vector<DoubleVector*> fluid_sub_vec_pt(N_fluid_doftypes,0);

     // Loop through the fluid rhs block vectors
     for(unsigned i = 0; i < N_fluid_doftypes; i++)
      {
       fluid_sub_vec_pt[i] = new DoubleVector;
       this->get_block_vector(i,r,*fluid_sub_vec_pt[i]);
      } // for
     
     // Perform the concatenation. 
     DoubleVectorHelpers::concatenate_without_communication
      (fluid_sub_vec_pt,temp_vec);

     // Do not clear the sub vectors since we need them to split the result
     // back.
     
     // temp_vec contains the (concatenated) fluid rhs.
     Navier_stokes_preconditioner_pt
       ->preconditioner_solve(temp_vec,another_temp_vec);
     
     temp_vec.clear();
     
     // We now have to put the block vectors in another_temp_vec back!
     DoubleVectorHelpers::split_without_communication
       (another_temp_vec,fluid_sub_vec_pt);
     
     another_temp_vec.clear();

     // loop through the fluid block vectors
     // and return the block vector.
     for(unsigned i = 0; i < N_fluid_doftypes; i++)
      {
       this->return_block_vector(i,*fluid_sub_vec_pt[i],z);
       fluid_sub_vec_pt[i]->clear();
      }//for
    }
   else
    {
     Navier_stokes_preconditioner_pt->preconditioner_solve(r,z);
    }

   First_NS_solve = false;
  } // end of preconditioner_solve

  void set_meshes(Vector<Mesh*> &mesh_pt)
  {
   // There should be at least two meshes for this preconditioner.
   unsigned nmesh = mesh_pt.size();

#ifdef PARANOID
   if(nmesh < 2)
    {
     std::ostringstream err_msg;
     err_msg << "There should be at least two meshes.\n";
     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Check that all pointers are not null
   for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
     if (mesh_pt[mesh_i]==0)
      {
       std::ostringstream err_msg;
       err_msg << "The pointer mesh_pt[" << mesh_i << "] is null.\n";
       throw OomphLibError(err_msg.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
    }
  
   // We assume that the first mesh is the "bulk" mesh. To check this, the
   // elemental dimension must be the same as the nodal dimension.
   //
   // We store the elemental dimension i.e. the number of local coordinates
   // required to parametrise its geomentry.
   unsigned spatial_dim = mesh_pt[0]->finite_element_pt(0)->dim();

   // The dimension of the nodes in the first element in the (supposedly)
   // bulk mesh.
   unsigned nodal_dim = mesh_pt[0]->finite_element_pt(0)
    ->nodal_dimension();
  
   // Check if the first mesh is the "bulk" mesh.
   // Here we assume only one mesh contains "bulk" elements.
   if (spatial_dim != nodal_dim) 
    {
     std::ostringstream err_msg;
     err_msg << "In the first mesh, the elements have elemental dimension of "
             << spatial_dim << ", with a nodal dimension of "
             << nodal_dim << ".\n"
             << "The first mesh does not contain 'bulk' elements.\n"
             << "Please re-order your mesh_pt vector.\n";

     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   if(is_master_block_preconditioner())
    {
     // Set the number of meshes 
     this->set_nmesh(nmesh);

     // Set the meshes
     for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
      {
       this->set_mesh(mesh_i,mesh_pt[mesh_i]);
      }
    }
  }


  /// \short Access function to the Scaling sigma of the preconditioner
  double& scaling_sigma()
  {
   Use_default_norm_of_f_scaling = false;
   return Scaling_sigma;
  }
/// \short Function to get the scaling Sigma of the preconditioner
  double scaling_sigma() const
  {
   return Scaling_sigma;
  }

  /// \short Access function to the Scaling sigma of the preconditioner
  double& scaling_sigma_multiplier()
  {
   return Scaling_sigma_multiplier;
  }
/// \short Function to get the scaling Sigma of the preconditioner
  double scaling_sigma_multiplier() const
  {
   return Scaling_sigma_multiplier;
  } 

  /// \short Helper function to assemble the diagonal of the pressure
  /// and velocity mass matrices from the elemental contributions defined in
  /// NavierStokesEquations<DIM>.
  /// If do_both=true, both are computed, otherwise only the velocity
  /// mass matrix (the LSC version of the preconditioner only needs
  /// that one)
  void assemble_inv_press_and_veloc_mass_matrix_diagonal(
   CRDoubleMatrix*& inv_p_mass_pt,
   CRDoubleMatrix*& inv_v_mass_pt,
   const bool& do_both,
   const unsigned& procnumber);


  void use_default_norm_of_f_scaling()
  {
   Use_default_norm_of_f_scaling = true;
  }

  /// Function to set a new momentum matrix preconditioner (inexact solver)
  void set_navier_stokes_lsc_preconditioner(Preconditioner* new_ns_preconditioner_pt)
  {
   // If the default preconditioner has been used
   // clean it up now...
   if (Using_superlu_ns_preconditioner)
    {
     delete Navier_stokes_preconditioner_pt;
    }
   Navier_stokes_preconditioner_pt = new_ns_preconditioner_pt;
   Using_superlu_ns_preconditioner = false;
  }

  ///\short Function to (re-)set momentum matrix preconditioner (inexact
  /// solver) to SuperLU
  void set_navier_stokes_superlu_preconditioner()
  {
   if (!Using_superlu_ns_preconditioner)
    {
     delete Navier_stokes_preconditioner_pt;
     Navier_stokes_preconditioner_pt = new SuperLUPreconditioner;
     Using_superlu_ns_preconditioner = true;
    }
  }

  /// Function to set a new momentum matrix preconditioner (inexact solver)
  void set_w_preconditioner(Preconditioner* new_w_preconditioner_pt)
  {
   // If the default preconditioner has been used
   // clean it up now...
   if (Using_superlu_w_preconditioner)
    {
     delete W_preconditioner_pt;
    }
   W_preconditioner_pt = new_w_preconditioner_pt;
   Using_superlu_w_preconditioner = false;
  }

  ///\short Function to (re-)set momentum matrix preconditioner (inexact
  /// solver) to SuperLU
  void set_w_superlu_preconditioner()
  {
   if (!Using_superlu_w_preconditioner)
    {
     delete W_preconditioner_pt;
     Using_superlu_w_preconditioner = true;
    }
  }


  void set_doc_linear_solver_info_pt
   (DocLinearSolverInfo* doc_linear_solver_info_pt)
  {
   Doc_linear_solver_info_pt = doc_linear_solver_info_pt;
  }

  /// \short Clears the memory.
  void clean_up_memory();

   private:

  std::string* Label_pt;

  std::string *Doc_prec_directory_pt;

  bool Doc_time;

  bool Doc_prec;

  bool Mapping_info_calculated;

  /// \short the Scaling_sigma variable of this preconditioner
  double Scaling_sigma;
  double Scaling_sigma_multiplier;

  ////////// NEW STUFF
  bool Use_default_norm_of_f_scaling;


  // Pointer to the 'preconditioner' for the W matrix
  // This will only be used if the user provides a preconditioner. Otherwise
  // we will use superLU preconditioners and solve each block using
  // W_preconditioner_pts
  Preconditioner* W_preconditioner_pt;

  // Pointer to the 'preconditioner' for the Navier-Stokes block
  Preconditioner* Navier_stokes_preconditioner_pt;
  Preconditioner* Exact_prec_pt;
  // Same W solvers are used in both exact and LSC.
  // Pointer to the 'preconditoner' for the W matrix
  Vector<Preconditioner*> W_preconditioner_pts;

  // flag to indicate whether the default NS preconditioner is used
  bool Using_superlu_ns_preconditioner;

  // flag to indicate whether the default w preconditioner is used
  bool Using_superlu_w_preconditioner;

  // Bool to use diagonal or block diagonal W block.
  bool Use_diagonal_w_block;

  bool Preconditioner_has_been_setup;

  bool F_preconditioner_is_block_preconditioner;

  // the re-arraned doftypes: velocity, pressure, lagrange.
  Vector<unsigned> Doftype_list_vpl;
  // the re-arraned doftypes: bulk, constrained, pressure, lagrange.
  Vector<unsigned> Subsidiary_list_bcpl;

  /// \short The number of lagrange multiplier dof types
  unsigned N_lagrange_doftypes;

  /// \short The number of fluid dof types (including pressure)
  unsigned N_fluid_doftypes;

  /// \short The number of velocity dof types.
  unsigned N_velocity_doftypes;

  bool First_NS_solve;


  /// \short Pointer to Doc_linear_solver_info.
  /// used for book keeping purposes.
  DocLinearSolverInfo* Doc_linear_solver_info_pt;

 }; // end of LagrangeEnforcedflowPreconditioner class




/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

 //========================================================================
 /// add the scaled identity matrix to the specified block
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::add_matrices(CRDoubleMatrix *&block_pt1,
                                                       CRDoubleMatrix *&block_pt2)
 {
  double* values1 = block_pt1->value();
  int* column_index1 = block_pt1->column_index();
  int* row_start1 = block_pt1->row_start();
  unsigned nrow_local1 = block_pt1->nrow_local();
  //unsigned first_row1 = block_pt1->first_row();
  unsigned nrow_global1 = block_pt1->nrow();

  double* values2 = block_pt2->value();
  int* column_index2 = block_pt2->column_index();
  int* row_start2 = block_pt2->row_start();
  //unsigned nrow_local2 = block_pt2->nrow_local();
  //unsigned first_row2 = block_pt2->first_row();

  // nrow_local should be the same.
  Vector< std::set<int> > column_set(nrow_local1);
  Vector<int> new_row_start(nrow_local1+1, 0);
  unsigned total_entries = 0;

  // Check which columns appear twice.
  std::pair<std::set<int>::iterator,bool> ret;

  for(unsigned i = 0; i < nrow_local1; i++)
   {
    // Union of both column indices
    for (int j = row_start1[i]; j < row_start1[i+1]; j++)
     {
      column_set[i].insert(column_index1[j]);
     }

    for (int j = row_start2[i]; j < row_start2[i+1]; j++)
     {
      ret = column_set[i].insert(column_index2[j]);
     }

    total_entries += column_set[i].size();
    new_row_start[i+1] = total_entries;
   }

  //Vector<double> ray_values33(9);
  //Vector<int> ray_column_indices33(9);
  //Vector<int> ray_row_start33(6);

  //cout << "Total entries: " << total_entries << endl;
  Vector<int> new_column_index(total_entries, 0);
  Vector<double> new_values(total_entries, 0);

  unsigned nci = 0;
  for(unsigned i = 0; i < nrow_local1; i++)
   {
    for(std::set<int>::const_iterator p = column_set[i].begin();
        p != column_set[i].end(); p++)
     {
      new_column_index[nci] =  *p;
      nci++;
      //cout << *p << " ";
     }
    //cout << endl;
   }



  // Now we add all the entries.

  for (unsigned i = 0; i < nrow_local1; i++)
   {
    // Adding the first matrix to the new matrix
    // Loop through the entries on ith row of matrix 1
    for (int j = row_start1[i]; j < row_start1[i+1]; j++)
     {
      bool found = false;
      // loop through the entries on the ith row of result matrix
      for (int jj = new_row_start[i]; jj  < new_row_start[i+1] && !found; jj++)
       {
        if(column_index1[j] == new_column_index[jj])
         {
          new_values[jj] += values1[j];
          found =true;
         }
       }
     }

    // Loop through the entries on ith row of matrix 2
    for (int j = row_start2[i]; j < row_start2[i+1]; j++)
     {
      bool found = false;
      // loop through the entries on the ith row of result matrix
      for (int jj = new_row_start[i]; jj  < new_row_start[i+1] && !found; jj++)
       {
        if(column_index2[j] == new_column_index[jj])
         {
          new_values[jj] += values2[j];
          found =true;
         }
       }
     }
   }

  // FIX THIS! This currently only works with square matrices
  block_pt2->build(nrow_global1,new_values,new_column_index,new_row_start);

  /// ENDS HERE
  /*
    cout << "new_column_index = " << endl;
    for(int i = 0; i < total_entries; i++)
    {
    cout << new_column_index[i] << " ";
    }
    cout << endl;

    cout << "new_row_start = ";
    for(int i = 0; i < nrow_local1 + 1; i++)
    {
    cout << new_row_start[i] << " ";
    }
    cout << endl;
  */
 } // add_matrices


 //========================================================================
 /// add the scaled identity matrix to the specified block
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::get_diag(CRDoubleMatrix *&block_pt,
                                                   Vector<double>& diag)
 {
  // Note that diag_sqrd is nrow_local long.
  double* values = block_pt->value();
  int* column_index = block_pt->column_index();
  int* row_start = block_pt->row_start();
  unsigned nrow_local = block_pt->nrow_local();
  unsigned first_row = block_pt->first_row();

  for (unsigned i = 0; i < nrow_local; i++)
   {
    bool found = false;
    for (int j = row_start[i]; j < row_start[i+1] && !found; j++)
     {
      if (column_index[j] == (int)(i + first_row))
       {
        diag[i] = values[j];
        found = true;
       }
     }
    if(!found)
     {
      diag[i] = 0.0;
     }
   }
 } // end_of_get_diag(CRDoubleMatrix *&block_pt,Vector<double>& diag)

 //========================================================================
 /// add the scaled identity matrix to the specified block
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::add_scaling_to_diag(double &Scaling,
                                                              CRDoubleMatrix *&block_pt)
 {
  double* values = block_pt->value();
  int* column_index = block_pt->column_index();
  int* row_start = block_pt->row_start();
  unsigned nrow_local = block_pt->nrow_local();
  unsigned first_row = block_pt->first_row();

  // We check if there are any zero entries on the diagonal of
  // the block.
  long unsigned nzero_diag = 0;
  Vector<unsigned> diag_pres(nrow_local, 0);
  for (unsigned i = 0; i < nrow_local; i++)
   {
    bool found = false;
    for (int j = row_start[i];
         j < row_start[i+1] && !found; j++)
     {
      if (column_index[j] == (int)(i + first_row))
       {
        diag_pres[i] = 1;
        found = true;
       }
     }
    if(!found)
     {
      nzero_diag++;
     }
   }

  if(nzero_diag != 0)
   {
    long unsigned nnz = block_pt->nnz();
    Vector<double> new_values(nnz + nzero_diag);
    Vector<int> new_column_index(nnz + nzero_diag);
    Vector<int> new_row_start(nrow_local+1);
    long unsigned offset = 0;
    unsigned nrow_global = block_pt->nrow();
    new_row_start[0] = row_start[0];

    // Loop through each row
    for(unsigned i = 0; i < nrow_local; i++)
     {
      // Have we set the artificial zero yet?
      bool set_zero = false;

      if(diag_pres[i])
       {
        // The diagonal is present. We just copy over the
        // column index and value.
        for(int j = row_start[i]; j < row_start[i+1]; j++)
         {
          if (column_index[j] == (int)(i + first_row))
           {
            new_column_index[j + offset] = column_index[j];
            new_values[j + offset] = values[j] + Scaling; // added scaling.
           }
          else
           {
            new_column_index[j + offset] = column_index[j];
            new_values[j + offset] = values[j];
           }
         }
       }
      else
       {
        // Diagonal is zero. There are 3 cases:
        // (1) Zero row - there are no non-zero entries on this row.
        // (2) Right entry - there are non-zero entries to the right
        //                   of the diagonal
        // (3) Left entry only - there are entries to the left
        //                       of the diagonal ONLY.

        // Case (1):
        if(row_start[i] == row_start[i+1])
         {
          // Zero row, set the artificial zero.
          new_column_index[row_start[i] + offset] = i + first_row;
          new_values[row_start[i] + offset] = Scaling; // added scaling
          offset++;
          set_zero = true;
         }
        else
         {
          // Case (2) and (3): There are some values on this row.
          // We loop through all of these values.
          for(int j = row_start[i]; j < row_start[i+1]; j++)
           {
            if(column_index[j] < (int)(i + first_row))
             {
              // First we copy all the values to the left of the diagonal.
              new_column_index[j + offset] = column_index[j];
              new_values[j + offset] = values[j];
             }
            else
             {
              // Now we are at either the diagonal or
              // to the right of the diagonal.

              if(!set_zero)
               {
                // We have reached the diagonal.
                new_column_index[j + offset] = i + first_row;
                new_values[j + offset] = Scaling; // added scaling
                offset++;
                set_zero = true;
               }

              // Values to the right of the diagonal.
              new_column_index[j + offset] = column_index[j];
              new_values[j + offset] = values[j];
             }
           }
          // Case (3): If there are values to the left of the diagonal only,
          // we never reach the diagonal. We set the diagonal in this case.
          if(!set_zero)
           {
            new_column_index[row_start[i+1] + offset] = i + first_row;
            new_values[row_start[i+1] + offset] = Scaling; // added scaling
            offset++;
            set_zero = true;
           }

         }
       }
      new_row_start[i+1] = row_start[i+1]+offset;
     }
    // This assumes that this is a square matrix
    block_pt->build(nrow_global,new_values,new_column_index,new_row_start);
   }
  else
   {
    for (unsigned i = 0; i < nrow_local; i++)
     {
      bool found = false;
      for (int j = row_start[i]; j < row_start[i+1] && !found; j++)
       {
        if (column_index[j] == (int)(i + first_row))
         {
          values[j] += Scaling;
          found = true;
         }
       }
     }
   }
 }// end_of_add_scaling_on_diag

 //========================================================================
 /// Setup method for the LagrangeEnforcedflowPreconditioner.
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::setup()
 {
  First_NS_solve = true;
  // For debugging
  bool Doc_time = false;

  // clean
  this->clean_up_memory();
  
  // Store the number of meshes locally.
  unsigned nmesh = this->nmesh();
  
  // What is the spatial dimension of the problem?
  unsigned spatial_dim = this->Mesh_pt[0]->finite_element_pt(0)->dim();

#ifdef PARANOID
  // Paranoid check that meshes have been set.
  if(nmesh == 0)
   {
    std::ostringstream err_msg;
    err_msg << "There are no meshes set. Please call set_meshes(...)\n";
    throw OomphLibError(err_msg.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // To construct the required block structure for the preconditoner, we
  // require only the
  // (1) spatial dimension of the problem and
  // (2) the number of dof types in each of the meshes.
  //
  // We assume the first mesh is always the bulk mesh. Example:
  // The general structure for the dof types (in 3D) is
  //  0 1 2 3   4 5 6 7  8  ..x   x+0 x+1 x+2 x+3 x+4
  // [u v w p] [u v w l1 l2 ...] [u   v   w   l1  l2 ...] ...
  //
  // where then square brackets [] represents the dof types in each mesh.
  //
  // Consider the case of imposing parallel outflow (3 constrained velocity
  // dof types and 2 lagrange multiplier dof types) and tangential flow (3
  // constrained velocity dof types and 1 lagrange multiplier dof type)
  // along two different boundaries in 3D. The resulting natural block dof
  // type structure is:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12 ]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // Then the dimension = 3 and N_doftype_in_mesh = [4, 5, 4].
  //
  // With these information we can construct the required block structure:
  // | u v w | up vp wp | ut vt wt | p | Lp1 Lp2 Lt1 |
  //
  // We create two dof list maps below to describe the above block structure.
  // One for block_setup(...), the other for 
  // turn_into_subsidiary_block_preconditioner(...).
  //
  // To do this, we first work out a few number of dof types.
 

  /////// Working out the dof types ///////

  // Zero the number of dof types. This is stored in block_preconditioner.h,
  // but only calculated when block_setup(...) is called. I tried to move this
  // out in to another function but something goes wrong...
  unsigned n_doftypes = 0;

  // Compute the variables we just reset!
  if (this->is_master_block_preconditioner())
   {
    // Loop through the meshes.
    for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
     {
      n_doftypes += this->ndof_types_in_mesh(mesh_i);
     }
   }
  else
   {
    pause("RAYRAY todo"); 
    
    // RAYEDIT - I'm not sure what to do here.
    // I'll cross the bridge when I come to it.
    n_doftypes = this->ndof_types();
    N_fluid_doftypes = 5;
   }
  
  // Determine the number of velocity dof types. 

  // Assume that all meshes contain elements for which the first 3 dof types
  // are velocity dof types.
  N_velocity_doftypes = nmesh*spatial_dim;

  // Fluid has +1 for the pressure.
  N_fluid_doftypes = N_velocity_doftypes + 1;

  // The rest are lagrange multiplier dof types.
  N_lagrange_doftypes = n_doftypes - N_fluid_doftypes;

  /////// Now create the dof lists ///////

  // Re-order the dof_types.
  // The natural ordering of the dof types are ordered by their meshes.
  // We want all the bulk velocities together, then the constrained velocities,
  // then the pressure, and finally the Lagrange multiplier block.
  // Consider the same example above:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // We want:
  //  0 1 2   4  5  6    9  10 11    3    7   8  12
  // [u v w | up vp wp | ut vt wt ] [p | Lp1 Lp2 Lt1]
  //
  // To create the list, think of it as 
  // "What do I want to move into this position?"
  // Consider the 3rd entry (starting from 0), which dof type do we want to
  // move into this position? - It's "up" or "4". 
  //
  // This is stored in Subsidiary_list_bcpl, this is passed to 
  // turn_into_subsidiary_block_preconditioner(...).
  //
  // Artificial test data for the above example. Just uncomment to test.
  // nmesh = 3;
  // N_doftype_in_mesh.resize(nmesh,0);
  // N_doftype_in_mesh[0] = 4;
  // N_doftype_in_mesh[1] = 5;
  // N_doftype_in_mesh[2] = 4;
  // spatial_dim = 3;
  // n_doftypes = 13;
  { // encapsulating temp vectors.

    // We create the mapping with the help of two vectors.
    // Noting that the first spatial dimension number of dof types in each mesh
    // corresponds to the velocity dof types, and the rest are either pressure
    // (in the case of the bulk mesh) or lagrange multiplier dof types, we
    // simply:
    // 1) Loop through the meshes
    // 2)   Loop through the spatial_dim, store the dof type in the v_vector.
    // 3)   Loop through the remaining dof types, store the dof type in the l
    //      vector.
    // 4) Concatenate the two vectors.

    // Temp velocity and lagrange dof type vectors.
   Vector<unsigned> temp_v_doftypes;
   Vector<unsigned> temp_l_doftypes;
    
   unsigned increment = 0;
   for(unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
     // Store the velocity dof types.
     for(unsigned dim_i = 0; dim_i < spatial_dim; dim_i++)
      {
       temp_v_doftypes.push_back(increment++);
      } // for spatial_dim

     // Store the pressure/lagrange dof types.
     unsigned n_doftype_in_mesh = this->ndof_types_in_mesh(mesh_i);

     for(unsigned l_i = spatial_dim; l_i < n_doftype_in_mesh; l_i++)
      {
       temp_l_doftypes.push_back(increment++);
      }
    } // for nmesh
    
   // Concatenate the vectors.
   Subsidiary_list_bcpl.clear();
   Subsidiary_list_bcpl.reserve(temp_v_doftypes.size() + 
                                temp_l_doftypes.size());
   Subsidiary_list_bcpl.insert(Subsidiary_list_bcpl.end(),
                               temp_v_doftypes.begin(),
                               temp_v_doftypes.end());
   Subsidiary_list_bcpl.insert(Subsidiary_list_bcpl.end(),
                               temp_l_doftypes.begin(),
                               temp_l_doftypes.end());
  } // end of encapculating

//  // Output for artificial test.
//  std::cout << "Subsidiary_list_bcpl:" << std::endl; 
//  for (unsigned i = 0; i < Subsidiary_list_bcpl.size(); i++) 
//  {
//    std::cout << Subsidiary_list_bcpl[i] << std::endl;
//  }
//  pause("Printed out Subsidiary_list_bcpl"); 


  // Re-order the dof_types.
  // The natural ordering of the dof types are ordered by their meshes.
  // We want to tell the blocks where they should be in the 
  // new blocking scheme. This mapping is passed to block_setup(...).
  //
  // This corresponds with the Subsidiary_list_bcpl above. We want the order: 
  // 1) bulk velocities, 2) constrained velocities, 3) pressure,
  // 4) the Lagrange multipliers.
  //
  // Consider the same example above:
  // [0 1 2 3] [4  5  6   7   8 ] [9  10 11 12]
  // [u v w p] [up vp wp Lp1 Lp2] [ut vt wt Lt1]
  //
  // We want:
  //  0 1 2 9 3  4  5  10  11  6  7  8  12
  // [u v w p up vp wp Lp1 Lp2 ut vt wt Lt1
  //
  // To create the mapping, think of this in terms of:
  // "Where do I want to move this dof type to?"
  // For example, take the 3th entry in the original list "p". Where do we want
  // to move this to? the 9th place.
  //
  // Artificial test data for the above example. Just uncomment to test.
  // nmesh = 3;
  // N_doftype_in_mesh.resize(nmesh,0);
  // N_doftype_in_mesh[0] = 4;
  // N_doftype_in_mesh[1] = 5;
  // N_doftype_in_mesh[2] = 4;
  // spatial_dim = 3;
  // N_velocity_doftypes = spatial_dim*nmesh;
  // n_doftypes = 13;

  Vector<unsigned> block_setup_bcpl(n_doftypes,0);
  
  // Encapsulate temporary variables
  {
   unsigned temp_index = 0;
   unsigned lagrange_entry = N_velocity_doftypes;
   for (unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
    {
     for (unsigned dim_i = 0; dim_i < spatial_dim; dim_i++) 
      {
       block_setup_bcpl[temp_index] = dim_i + mesh_i*spatial_dim;
       temp_index++;
      } // for

     unsigned ndof_type_in_mesh = this->ndof_types_in_mesh(mesh_i);

     for (unsigned doftype_i = spatial_dim; 
          doftype_i < ndof_type_in_mesh; doftype_i++) 
      {
       block_setup_bcpl[temp_index] = lagrange_entry;
       lagrange_entry++;
       temp_index++;
      } // for
    } // for
  } // Encapsulation

//  std::cout << "block_setup_bcpl:" << std::endl; 
//  for (unsigned i = 0; i < block_setup_bcpl.size(); i++) 
//  {
//    std::cout << block_setup_bcpl[i] << std::endl;
//  }
//  pause("Done the block_setup_bcpl"); 

  // Call the block setup
  this->block_setup(block_setup_bcpl);

//  // Check the block size.
//  unsigned tmp_nblocks = this->nblock_types(true);
//  for (unsigned i = 0; i < tmp_nblocks; i++) 
//  {
//    // Go along the first column.
//    unsigned raycol = 0;
//
//    CRDoubleMatrix* tmpblockpt = new CRDoubleMatrix;
//    this->get_block(i,raycol,*tmpblockpt);
//
//    unsigned raynrow = tmpblockpt->nrow();
//    std::cout << "block: " << i << ", nrow: " << raynrow << std::endl; 
//  }
//  pause("now!"); 
  

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

  if(Doc_prec)
   {
//    unsigned my_rank 
//     = master_distribution_pt()->communicator_pt()->my_rank();
//    unsigned nproc 
//     = master_distribution_pt()->communicator_pt()->nproc();
    // This is for bebugging purposes.
//    std::stringstream curr_setting_stream;
//    curr_setting_stream << "NP" << nproc << "R" << my_rank;
//    std::string currentsetting = curr_setting_stream.str();
    std::string currentsetting 
      = *Label_pt + "NS"
        + StringConversion::to_string(Doc_linear_solver_info_pt
                                      ->current_nnewton_step());

    // Output the spatial dimension,
    // on a new line, output the number of dof types in each mesh
    // This information allows us to assemble the preconditioner in, say, 
    // MATLAB
    std::ofstream precinfo_ofstream;
    std::string precinfo_string = *Doc_prec_directory_pt + "/precinfo_" + currentsetting;
    precinfo_ofstream.open(precinfo_string.c_str());
    // The dimension
    precinfo_ofstream << spatial_dim << " ";
    // The number of blocks
    unsigned nblock_types = this->nblock_types();

    for (unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++)
     {
      precinfo_ofstream << this->Ndof_types_in_mesh[mesh_i] << " ";
     }
    precinfo_ofstream.close();

    // Now output all the blocks.
    // Loop through all the blocks and output them.
    for(unsigned Mi=0; Mi<nblock_types; Mi++)
     {
      for(unsigned Mj=0; Mj<nblock_types; Mj++)
       {
        CRDoubleMatrix* sub_matrix_pt = new CRDoubleMatrix;
        this->get_block(Mi,Mj,*sub_matrix_pt);
        std::stringstream blockname;
        blockname << *Doc_prec_directory_pt+"/j_"<< currentsetting<< "_"
                  << std::setw(2) << std::setfill('0') << Mi
                  << std::setw(2) << std::setfill('0') << Mj;
        sub_matrix_pt->sparse_indexed_output(blockname.str(),true,15);
        delete sub_matrix_pt;
        sub_matrix_pt = 0;
       }//for
     }//for

//    // Now get the mass matrices for LSC solve
//
//    // Extract all of the inv_v_mass.
//    bool do_both=false;
//    CRDoubleMatrix* inv_v_mass_pt = 0;
//    CRDoubleMatrix* inv_p_mass_pt = 0;
//
//    for(unsigned dof_type_i = 0;
//        dof_type_i < N_velocity_doftypes; dof_type_i++)
//    {
//      unsigned required_block = dof_type_i; //Doftype_list_vpl[dof_type_i];
//      assemble_inv_press_and_veloc_mass_matrix_diagonal
//        (inv_p_mass_pt, inv_v_mass_pt,
//         do_both, required_block);
//      
//      std::stringstream blockname;
//      blockname << "vmm_"<< currentsetting<< "_"
//        << std::setw(2) << std::setfill('0') << required_block
//        << std::setw(2) << std::setfill('0') << required_block;
//      inv_v_mass_pt->sparse_indexed_output(blockname.str());
//      delete inv_v_mass_pt;
//    }
   }// if Doc_prec
  

  ///////////////////////////////////////////////////////////////////////////
  // Need to create the norms, used for Sigma, if required
  ///////////////////////////////////////////////////////////////////////////

  // Extract the velocity block. Although we only require the infinity norm
  // a single direction of the velocity block, we extract them all since we
  // use the rest immediately (to perform the augmentation).
  DenseMatrix<CRDoubleMatrix*> v_aug_pt(N_velocity_doftypes,
                                        N_velocity_doftypes,0);
  for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
   {
    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
     {
      v_aug_pt(row_i,col_i) = new CRDoubleMatrix;
      this->get_block(row_i,col_i,*v_aug_pt(row_i,col_i));
     } // for
   } // for

  if(Use_default_norm_of_f_scaling)
   {
    // Create the scaling, norm of the momentum block.
    // The the u block (the blocks corresponding to the velocity in the 
    // x direction).

    double t_norm_start = TimingHelpers::timer();

    DenseMatrix<CRDoubleMatrix* > u_pt(nmesh,nmesh,0);

    // Recall the blocking scheme:
    // 0 1 2 3  4  5  6  7  8
    // u v w u1 v1 w1 u2 v2 w2 ...
    // So we loop through the meshes and then get the first entry...
    // from v_aug_pt.
    for(unsigned row_i = 0; row_i < nmesh; row_i++)
     {
      for(unsigned col_i = 0; col_i < nmesh; col_i++)
       {
        u_pt(row_i,col_i) = v_aug_pt(row_i*spatial_dim,
                                     col_i*spatial_dim);
       } // for
     } //  for

    // Get the norm and set the scaling sigma.
//    Scaling_sigma = -CRDoubleMatrixHelpers::inf_norm(u_pt)
//     *Scaling_sigma_multiplier;

    Scaling_sigma = -CRDoubleMatrixHelpers::inf_norm(v_aug_pt)
     *Scaling_sigma_multiplier;

//    Scaling_sigma = CRDoubleMatrixHelpers::maximum_gershgorin_disk(v_aug_pt)
//     *Scaling_sigma_multiplier;

    double t_norm_finish = TimingHelpers::timer();
    if(Doc_time)
     {
      double t_norm_time = t_norm_finish - t_norm_start;
      std::cout << "t_norm_time: " << t_norm_time << std::endl;
     }
   } // if(Use_default_f_scaling)

#ifdef PARANOID
  if(Scaling_sigma == 0.0)
   {
    std::ostringstream warning_stream;
    warning_stream << "WARNING: " << std::endl
                   << "The scaling (Scaling_sigma) is " 
                   << Scaling_sigma << std::endl
                   << "Division by Scaling_sigma = 0 will implode the world."
                   << std::endl;
    OomphLibWarning(warning_stream.str(),
                    OOMPH_CURRENT_FUNCTION,
                    OOMPH_EXCEPTION_LOCATION);
   }
  if(Scaling_sigma > 0.0)
   {
    std::ostringstream warning_stream;
    warning_stream << "WARNING: " << std::endl
                   << "The scaling (Scaling_sigma) is positive: " 
                   << Scaling_sigma << std::endl
                   << "Performance may be degraded."
                   << std::endl;
    OomphLibWarning(warning_stream.str(),
                    OOMPH_CURRENT_FUNCTION,
                    OOMPH_EXCEPTION_LOCATION);
   }
#endif


  std::streamsize cout_precision = std::cout.precision();
  oomph_info << "RAYSIGMA: " << std::setprecision(15) << Scaling_sigma
             << std::setprecision(cout_precision)
             << std::endl;

  ///////////////////////////////////////////////////////////////////////////
  //                Now create the augmented fluid matrix.                 //
  ///////////////////////////////////////////////////////////////////////////


  // Loop through the Lagrange multipliers and do three things:
  // For each Lagrange block:
  //   Create an empty w_i, this will be constructed incrementally from the
  //   mass matrices (in the columns).
  //
  //   For each block column
  //     1) Store the location of mass matrix.
  //     2) Store the mass matrix.
  //     3) Create the partial w_i += diag(m)^2
  //
  //   1) Store the w_i for this lagrange multiplier.
  //   Loop through the mass matrix location to determine the aug. row.
  //     Loop through the mm location to determine the aug. col.
  //       1) Create inv_wi from the w_i already created.
  //       1) Create augmentation m * inv(w_i) * m
  //       2) Add the augmentation as determined by aug. row and aug. col.

  // Storage for the W block.
  Vector<CRDoubleMatrix*> w_pt(N_lagrange_doftypes,0);

  // Note that we do not need to store all the inverse w_i since they
  // are only used once per lagrage multiplier.
  for(unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++)
   {
    // Storage for the current lagrange block mass matrices.
    Vector<CRDoubleMatrix*> mm_pt;
    Vector<CRDoubleMatrix*> mmt_pt;

    // Get the current lagrange doftype.
    unsigned l_doftype = N_fluid_doftypes + l_i;

    // Store the mass matrix locations for the current lagrange block.
    Vector<unsigned> mm_locations;
    
    // Store the number of mass matrices.
    unsigned n_mm = 0;

    // It is easier to create the diagonal matrix w_i after
    // I have extracted all the mass matrices for this Lagrange
    // block.

    // Go along the block columns for the current lagrange block.
    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
     {
      // Get the block matrix for this block column.
      CRDoubleMatrix* mm_temp_pt = new CRDoubleMatrix;
      this->get_block(l_doftype, col_i, *mm_temp_pt);

      if(mm_temp_pt->nnz() > 0)
       {
        mm_locations.push_back(col_i);
        mm_pt.push_back(mm_temp_pt);
        n_mm++;
       }
      else
       {
        // This is just an empty matrix. No need to keep this.
        delete mm_temp_pt;
       }
     } // loop through the columns of the lagrange row.

#ifdef PARANOID
    if (n_mm == 0) 
     {
      std::ostringstream warning_stream;
      warning_stream << "WARNING:\n"
                     << "There are no mass matrices on lagrange block " 
                     << l_i << ".\n"
                     << "Perhaps the problem setup is incorrect." << std::endl;
      OomphLibWarning(warning_stream.str(),
                      OOMPH_CURRENT_FUNCTION,
                      OOMPH_EXCEPTION_LOCATION);
     }
#endif

    // Get the transpose of the mass matrices.
    for(unsigned mm_i = 0; mm_i < n_mm; mm_i++)
     {
      // Get the block matrix for this block column.
      CRDoubleMatrix* mm_temp_pt = new CRDoubleMatrix;
      this->get_block(mm_locations[mm_i],l_doftype,*mm_temp_pt);

      if(mm_temp_pt->nnz() > 0)
       {
        mmt_pt.push_back(mm_temp_pt);
       }
      else
      {
        // There should be a non-zero mass matrix here, since we are getting
        // mass matrices from the L^T block, corresponding to L.
#ifdef PARANOID
        {
          std::ostringstream warning_stream;
          warning_stream << "WARNING:\n"
            << "The mass matrix block " << mm_locations[mm_i] 
            << "in L^T block " << l_i << "is zero.\n"
            << "Perhaps the problem setup is incorrect." << std::endl;
          OomphLibWarning(warning_stream.str(),
              OOMPH_CURRENT_FUNCTION,
              OOMPH_EXCEPTION_LOCATION);
        }
#endif
      }
     } // loop through the ROW of the lagrange COLUMN.

    // The mass matrices for the current Lagrange block row is in mm_pt. 
    // The mass matrices for the current Lagrange block col is in mmt_pt. 
    // Now create the w_i and put it in w_pt.
    
    unsigned long l_i_nrow_global 
      = this->Block_distribution_pt[l_doftype]->nrow();
  
    // Create both the w_i and inv_w_i matrices.
    w_pt[l_i] = new CRDoubleMatrix(this->Block_distribution_pt[l_doftype]);
    CRDoubleMatrix* inv_w_pt 
      = new CRDoubleMatrix(this->Block_distribution_pt[l_doftype]);

    // The w_i is either a
    // 1) diagonal or
    // 2) block diagonal
    // approximation of the actual W = LL^T block 
    // (LL^T has off-diagonal blocks).
    //
    // When w_i is inverted, we always take the diagonal approximation 
    // beforehand. In the case of (1), nothing needs to be done, 
    // but in (2) we need to extract the diagonal of the block-diagonal matrix.

    if(Use_diagonal_w_block)
     {
      // Get the number of local rows for this lagrange block.
      unsigned long l_i_nrow_local 
        = this->Block_distribution_pt[l_doftype]->nrow_local();

      // The first row, for the offset.
      unsigned l_i_first_row 
        = this->Block_distribution_pt[l_doftype]->first_row();
      
      // A vector to contain the results of mass matrices squared.
      Vector<double> w_i_diag_values(l_i_nrow_local,0);
      Vector<double> invw_i_diag_values(l_i_nrow_local,0);
      
      Vector<int> w_i_column_indices(l_i_nrow_local);
      Vector<int> w_i_row_start(l_i_nrow_local+1);
      
      // Component-wise, square and add all the diagonals.
      // Loop through the mass matrices.
      for(unsigned m_i = 0; m_i < n_mm; m_i++)
       {
        // NOTE: THIS WILL BREAK IF THE MASS MATRICES IS NOT SQUARE.
        // THIS HAPPENS WHEN THE FREE NODES ON THE CONSTRAINED BOUNDARIES
        // ARE DIFFERENT BETWEEN VELOCITY DEGREES OF FREEDOM.
        // WE CAN GET AROUND THIS MY MULTIPLYING THE MASS MATRIX BY
        // IT'S TRANSPOSE, THEN TAKE THE DIAGONAL ENTRIES OF THAT.
        // Get the diagonal entries for the mass matrix.
        CRDoubleMatrix* temp_mm_sqrd_pt = new CRDoubleMatrix;
        temp_mm_sqrd_pt->build(mm_pt[m_i]->distribution_pt());
        mm_pt[m_i]->multiply(*mmt_pt[m_i],*temp_mm_sqrd_pt);

        //Vector<double> m_diag = mm_pt[m_i]->diagonal_entries();
        Vector<double> m_diag = temp_mm_sqrd_pt->diagonal_entries();

        // Loop through the entries, square and add them.
        for(unsigned long row_i = 0; row_i < l_i_nrow_local; row_i++)
         {
          w_i_diag_values[row_i] += m_diag[row_i];
         }
       }
      

      // Divide by Scaling_sigma and create the inverse of w.
      for(unsigned long row_i = 0; row_i < l_i_nrow_local; row_i++)
       {
        w_i_diag_values[row_i] /= Scaling_sigma;
  
        // w_i is a diagonal matrix, so take the inverse to
        // invert the matrix.
        invw_i_diag_values[row_i] = 1.0/w_i_diag_values[row_i];
        w_i_column_indices[row_i] = row_i + l_i_first_row;
        w_i_row_start[row_i] = row_i;
       }
      
      w_i_row_start[l_i_nrow_local] = l_i_nrow_local;

      // Theses are square matrices. So we use the l_i_nrow_global for the
      // number of columns.
      w_pt[l_i]->build(l_i_nrow_global,
                         w_i_diag_values,
                         w_i_column_indices,
                         w_i_row_start);
      inv_w_pt->build(l_i_nrow_global,
                      invw_i_diag_values,
                      w_i_column_indices,
                      w_i_row_start);
     }
    else
     {
      // Square the first mass matrix. We assume that there is at least one.
      mm_pt[0]->multiply((*mm_pt[0]),(*w_pt[l_i]));
      
      // Square the other mass matrices and add the result to w_pt[l_i].
      for (unsigned mm_i = 1; mm_i < n_mm; mm_i++)
       {
        // Squaring process.
        CRDoubleMatrix* temp_mm_sqrd_pt = new CRDoubleMatrix;
        temp_mm_sqrd_pt->build(this->Block_distribution_pt[l_doftype]);
        mm_pt[mm_i]->multiply((*mm_pt[mm_i]),*temp_mm_sqrd_pt);
        
        // adding to the sum of squared mass matrices.
        add_matrices(temp_mm_sqrd_pt,w_pt[l_i]);
        delete temp_mm_sqrd_pt;
       }

      // Now multiply by the Scaling sigma:
      double* current_w_values = w_pt[l_i]->value();
      long unsigned current_w_nnz = w_pt[l_i]->nnz();
      for (unsigned nnz_i = 0; nnz_i < current_w_nnz; nnz_i++)
       {
        current_w_values[nnz_i] /= Scaling_sigma;
       }

      // w_i is complete.
      // We have to create inv_w_pt by extracting the diagonal entries of w_i.

      // Get the number of local rows for this lagrange block.
      // We shall use the block in the first column.
      unsigned long l_i_nrow_local = mm_pt[0]->nrow_local();

      // A Vector for the diagonal entries of w_i.
      Vector<double> inv_w_i_diag_values(l_i_nrow_local,0.0);
      get_diag(w_pt[l_i],inv_w_i_diag_values);


      Vector<int> inv_w_i_row_start(l_i_nrow_local+1);
      Vector<int> inv_w_i_column_indices(l_i_nrow_local);
      // Invert the values to create the diagonal entries for inv_w_i: 
      for(unsigned long row_i = 0; row_i < l_i_nrow_local; row_i++)
       {
        inv_w_i_diag_values[row_i] = 1/inv_w_i_diag_values[row_i];
        inv_w_i_column_indices[row_i] = row_i;
        inv_w_i_row_start[row_i] = row_i;
       }

      inv_w_i_row_start[l_i_nrow_local] = l_i_nrow_local;

      inv_w_pt->build(l_i_nrow_global,
                      inv_w_i_diag_values,
                      inv_w_i_column_indices,
                      inv_w_i_row_start);
     }


///////////////////////////////////////////////////////////////////////////////
    // Now we create the augmented matrix in v_aug_pt.
    // v_aug_pt is already re-ordered
    // Loop through the mm_locations
    for(unsigned ii = 0; ii < n_mm; ii++)
     {
      unsigned aug_i = mm_locations[ii];

      for(unsigned jj = 0; jj < n_mm; jj++)
       {
        unsigned aug_j = mm_locations[jj];

        // A temp pointer to store the intermediate results.
        CRDoubleMatrix* aug_pt = new CRDoubleMatrix;

        mmt_pt[ii]->multiply((*inv_w_pt),(*aug_pt));
        CRDoubleMatrix* another_mat_pt = new CRDoubleMatrix;

        aug_pt->multiply(*mm_pt[jj],(*another_mat_pt));

        //add_matrices(aug_pt,v_aug_pt(aug_i,aug_j));
        v_aug_pt(aug_i,aug_j)->add(*another_mat_pt,*v_aug_pt(aug_i,aug_j));

        delete aug_pt;
       } // loop jj
     } // loop ii

    delete inv_w_pt;
    for(unsigned m_i = 0; m_i < n_mm; m_i++)
     {
      delete mm_pt[m_i];
      delete mmt_pt[m_i];
     }
   } // loop through Lagrange multipliers.

  // AT this point, we have created the aumented fluid block in v_aug_pt
  // and the w block in w_pt.
  //
  /////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////

  // Setup the fluid subsidiary precoditioner
  //
  // We solve the fluid block using different preconditioners.
  //
  // 1) For exact block preconditioning, we use the SuperLU solver.
  // For this, we have to form the fluid block by extracting the 
  // pressure matrices.
  //
  // 2) For Exact lsc block preconditioning we do not need to form the whole
  // fluid block since the pressure and velocity are solved separately.
  //
  if(Using_superlu_ns_preconditioner)
   {
    DenseMatrix<CRDoubleMatrix* > f_subblock_pt(N_fluid_doftypes,
                                                N_fluid_doftypes,0);
    // put in v_aug_pt:
    for(unsigned v_i = 0; v_i < N_velocity_doftypes; v_i++)
     {
      for(unsigned v_j = 0; v_j < N_velocity_doftypes; v_j++)
       {
        f_subblock_pt(v_i,v_j) = v_aug_pt(v_i,v_j);
       }
     }

    // Now get the B and B^T blocks. Note that we have left out the zero block.

    // Fill in the pressure block B
    for(unsigned col_i = 0; col_i < N_velocity_doftypes; col_i++)
     {
      f_subblock_pt(N_velocity_doftypes,col_i) = new CRDoubleMatrix;
      this->get_block(N_velocity_doftypes,col_i,
                      *f_subblock_pt(N_velocity_doftypes,col_i));
     }

    // Fill in the pressure block B^T
    for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
     {
      f_subblock_pt(row_i,N_velocity_doftypes) = new CRDoubleMatrix;
      this->get_block(row_i,N_velocity_doftypes,
                      *f_subblock_pt(row_i,N_velocity_doftypes));
     }

    // Concatenate the sub matrices.
    CRDoubleMatrix* f_aug_pt = new CRDoubleMatrix;

    Vector<LinearAlgebraDistribution*> f_dist_pt(N_fluid_doftypes,0);
    for(unsigned f_i = 0; f_i < N_fluid_doftypes; f_i++)
     {
      f_dist_pt[f_i] = this->Block_distribution_pt[f_i];
     }

    CRDoubleMatrixHelpers::concatenate_without_communication
     (f_dist_pt,f_subblock_pt,*f_aug_pt);

    // delete the sub F pointers
    for(unsigned row_i = 0; row_i < N_fluid_doftypes; row_i++)
     {
      for(unsigned col_i = 0; col_i < N_fluid_doftypes; col_i++)
       {
        delete f_subblock_pt(row_i, col_i);
        f_subblock_pt(row_i, col_i) = 0;
       }
     }
    
    if(Navier_stokes_preconditioner_pt == 0)
     {
      Navier_stokes_preconditioner_pt = new SuperLUPreconditioner;
     }
    
    Navier_stokes_preconditioner_pt->setup(f_aug_pt, comm_pt());

    delete f_aug_pt;
    f_aug_pt = 0;
   }
  else
   {
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////
    
    // Get the rest of the f block.
    DenseMatrix<CRDoubleMatrix* > f_subblock_pt(N_fluid_doftypes,
                                                N_fluid_doftypes,0);
    // put in v_aug_pt:
    for(unsigned v_i = 0; v_i < N_velocity_doftypes; v_i++)
     {
      for(unsigned v_j = 0; v_j < N_velocity_doftypes; v_j++)
       {
        f_subblock_pt(v_i,v_j) = v_aug_pt(v_i,v_j);
       }
     }

    // Fill in the pressure block B plus 1
    for(unsigned col_i = 0; col_i < N_fluid_doftypes; col_i++)
     {
      f_subblock_pt(N_velocity_doftypes,col_i) = new CRDoubleMatrix;

      this->get_block(N_velocity_doftypes,col_i,
                      *f_subblock_pt(N_velocity_doftypes,col_i));
     }

    // Fill in the pressure block B^T
    for(unsigned row_i = 0; row_i < N_velocity_doftypes; row_i++)
     {
      f_subblock_pt(row_i,N_velocity_doftypes) = new CRDoubleMatrix;

      this->get_block(row_i,N_velocity_doftypes,
                      *f_subblock_pt(row_i,N_velocity_doftypes));
     }

    Vector<unsigned> ns_dof_list(N_fluid_doftypes,0);
    for (unsigned i = 0; i < N_fluid_doftypes; i++)
     {
      ns_dof_list[i]= Subsidiary_list_bcpl[i];
     }

    // Determine whether the NS preconditioner is a block preconditioner (and
    // therefore a subsidiary preconditioner)
#ifdef PARANOID
    BlockPreconditioner<CRDoubleMatrix>* navier_stokes_block_preconditioner_pt
     = dynamic_cast<BlockPreconditioner<CRDoubleMatrix>* >
     (Navier_stokes_preconditioner_pt);

    if(navier_stokes_block_preconditioner_pt == 0)
     {
      std::ostringstream error_message;
      error_message << "Navier stokes preconditioner is not a block\n"
                    << "preconditioner." << std::endl;
      throw OomphLibError(
       error_message.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }
#else
    BlockPreconditioner<CRDoubleMatrix>* navier_stokes_block_preconditioner_pt
     = static_cast<BlockPreconditioner<CRDoubleMatrix>* >
     (Navier_stokes_preconditioner_pt);
#endif

    // The ns_dof_list will ensure that the NS preconditioner have the 
    // structure:
    // 0  1  2  3  4  5  6
    // ub vb up vp ut vt p
    navier_stokes_block_preconditioner_pt
     ->turn_into_subsidiary_block_preconditioner(this, ns_dof_list);

    // Tell the LSC preconditioner which dof type should be treated as one
    // dof type. i.e.
    // 0   0  2  4
    // u = ub up ut
    //
    // 1   1  3  5
    // v = vb vp vt
    //
    // 2   6
    // p = p
    Vector<Vector<unsigned> > doftype_to_doftype_map;

    for (unsigned direction = 0; direction < spatial_dim; direction++)
     {
      Vector<unsigned> dir_doftypes_vec(nmesh,0);
      for (unsigned mesh_i = 0; mesh_i < nmesh; mesh_i++) 
       {
        dir_doftypes_vec[mesh_i] = spatial_dim*mesh_i+direction;
       }

       // Push it in!
       doftype_to_doftype_map.push_back(dir_doftypes_vec);
     }

    Vector<unsigned> ns_p_vec(1,0);
    ns_p_vec[0] = N_velocity_doftypes;

    doftype_to_doftype_map.push_back(ns_p_vec);

    navier_stokes_block_preconditioner_pt
     ->set_precomputed_blocks(f_subblock_pt,doftype_to_doftype_map);

    navier_stokes_block_preconditioner_pt
     ->setup(matrix_pt(), comm_pt());
    
    for (unsigned i = 0; i < N_fluid_doftypes; i++)
     {
      for (unsigned j = 0; j < N_fluid_doftypes; j++) 
       {
        delete f_subblock_pt(i,j);
       }
     }
   }

///////////////////////////////////////////////////////////////////////////////

  // Solver for the W block.
  double t_w_prec_start = TimingHelpers::timer();
  W_preconditioner_pts.resize(N_lagrange_doftypes);
  for(unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++)
   {
    if(Using_superlu_w_preconditioner)
     {
      if(W_preconditioner_pts[l_i] == 0)
       {
        W_preconditioner_pts[l_i] = new SuperLUPreconditioner;
       }

      W_preconditioner_pts[l_i]->setup(w_pt[l_i], comm_pt());
     }
    else
     {
      pause("Other W preconditioners are not yet implemented.");
     }
   }
  
  double t_w_prec_finish = TimingHelpers::timer();
  if(Doc_time)
   {
    double t_w_prec_time = t_w_prec_finish - t_w_prec_start;
    std::cout << "t_w_prec_time: "
              << t_w_prec_time << "\n";
   }

  // Delete w_pt(0,N_lagrange_doftypes)
  for (unsigned l_i = 0; l_i < N_lagrange_doftypes; l_i++) 
   {
    delete w_pt[l_i];
   }

  Mapping_info_calculated = true;
 } // end of LagrangeEnforcedflowPreconditioner::setup


 //========================================================================
 /// \short Clears the memory.
 //========================================================================
 void LagrangeEnforcedflowPreconditioner::clean_up_memory()
 {
  // clean the block preconditioner base class memory
  this->clear_block_preconditioner_base();
 } // end of LagrangeEnforcedflowPreconditioner::clean_up_memory


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////



//========================================================================
/// Helper function to assemble the diagonal of the velocity
/// mass matrix from the elemental contributions defined in
/// NavierStokesEquations<DIM>::get_velocity_mass_matrix_diagonal(...).
/// If do_both=true, both are computed, otherwise only the velocity
/// mass matrix (the LSC version of the preconditioner only needs
/// that one)
//========================================================================
 void LagrangeEnforcedflowPreconditioner::
  assemble_inv_press_and_veloc_mass_matrix_diagonal(
   CRDoubleMatrix*& inv_p_mass_pt,
   CRDoubleMatrix*& inv_v_mass_pt,
   const bool& do_both,
   const unsigned& procnumber)
 {
  int pronumber = (int)procnumber;
  // determine the velocity rows required by this processor
  // RRR_type
  unsigned v_first_row = this->block_distribution_pt(pronumber)->first_row();
  unsigned v_nrow_local = this->block_distribution_pt(pronumber)->nrow_local();
  unsigned v_nrow = this->block_distribution_pt(pronumber)->nrow();

  //cout << "v_first_row = " << v_first_row << endl;
  //cout << "v_nrow_local = " << v_nrow_local << endl;
  //cout << "v_nrow = " << v_nrow << endl;

  // create storage for the diagonals
  double* v_values = new double[v_nrow_local];
  for (unsigned i = 0; i < v_nrow_local; i++)
   {
    v_values[i] = 0.0;
   }

  // Equivalent information for pressure mass matrix (only needed for
  // Fp version)
  //unsigned p_first_row=0;
  //unsigned p_nrow_local=0;
  //unsigned p_nrow=0;
  //double* p_values = 0;
/*
  if (L_prec_type != Exact_lsc_block_preconditioner)
  {
  // determine the pressure rows required by this processor
  p_first_row = this->block_distribution_pt(1)->first_row();
  p_nrow_local = this->block_distribution_pt(1)->nrow_local();
  p_nrow = this->block_distribution_pt(1)->nrow();

  // create storage for the diagonals
  p_values = new double[p_nrow_local];
  for (unsigned i = 0; i < p_nrow_local; i++)
  {
  p_values[i] = 0.0;
  }
  } // if (!Use_LSC)
*/

  // store the problem pt, this seems to be not used.
  //const Problem* problem_pt = this->problem_pt();

  // if the problem is distributed
  bool distributed = false;

  if (distributed)
   {
    // To do
   }
  else
   {
    // find number of elements
    unsigned n_el = this->Mesh_pt[0]->nelement();

    //unsigned n_el = problem_pt->mesh_pt(0)->nelement();
    // Fp needs pressure and velocity mass matrices
    unsigned which_one=0;
    if (1)
     which_one=2;

    // get the contribution for each element
    for (unsigned e = 0; e < n_el; e++)
     {
      // Get element
      //GeneralisedElement* el_pt=problem_pt->mesh_pt(0)->element_pt(e);
      GeneralisedElement* el_pt=this->Mesh_pt[0]->element_pt(e);

      // find number of degrees of freedom in the element
      // (this is slightly too big because it includes the
      // pressure dofs but this doesn't matter)
      unsigned el_dof = el_pt->ndof();

      // allocate local storage for the element's contribution to the
      // pressure and velocity mass matrix diagonal
      Vector<double> el_vmm_diagonal(el_dof);
      Vector<double> el_pmm_diagonal(el_dof);

      dynamic_cast<TemplateFreeNavierStokesEquationsBase*>(el_pt)->
       get_pressure_and_velocity_mass_matrix_diagonal(
        el_pmm_diagonal,el_vmm_diagonal,which_one);

      // Get the contribution for each dof
      for (unsigned i = 0; i < el_dof; i++)
       {
        //Get the equation number
        unsigned eqn_number = el_pt->eqn_number(i);

        // Get the velocity dofs
        if (this->block_number(eqn_number)==pronumber) // RAY_TOCHANGE
         {
          //cout << "GOT HERE!!!!" << endl;
          // get the index in the block
          unsigned index = this->index_in_block(eqn_number);

          // if it is required on this processor
          if ((index >= v_first_row) &&
              (index < (v_first_row + v_nrow_local) ) )
           {
            //cout << "ZOMG Got in if" << endl;
            //cout << "index-v_first_row = " << index-v_first_row << endl;
            v_values[index-v_first_row] += el_vmm_diagonal[i];
           }
         }
        // Get the pressure dofs
        // NOTE: This is not used for the LSC case.
        else if (this->block_number(eqn_number)==1) // RAY_TOCHANGE
         {
          /*
            if (L_prec_type != Exact_lsc_block_preconditioner)
            {
            // get the index in the block
            unsigned index = this->index_in_block(eqn_number);

            // if it is required on this processor
            if ((index >= p_first_row)&&
            (index < (p_first_row + p_nrow_local)) )
            {
            p_values[index-p_first_row] += el_pmm_diagonal[i];
            }
            } // if (!Use_LSC)
          */
         }
       }
     } // for (unsigned e = 0; e < n_el; e++)
   }// if (distributed), else

  // Create column index and row start for velocity mass matrix
  int* v_column_index = new int[v_nrow_local];
  int* v_row_start = new int[v_nrow_local+1];
  for (unsigned i = 0; i < v_nrow_local; i++)
   {
#ifdef PARANOID
    if (v_values[i]==0.0)
     {
      std::ostringstream error_message;
      error_message << "Zero entry in diagonal of velocity mass matrix\n"
                    << "Index: " << i << std::endl;
      throw OomphLibError(
       error_message.str(),
       "ConstrainedNavierStokesSchurComplementPreconditioner::assemble_inv_press_and_veloc_mass_matrix_diagonal()",
       OOMPH_EXCEPTION_LOCATION);
     }
#endif
    v_values[i] = 1.0/v_values[i];
    v_column_index[i] = v_first_row + i;
    v_row_start[i] = i;
   }
  v_row_start[v_nrow_local] = v_nrow_local;

  // Build the velocity mass matrix
  inv_v_mass_pt = new CRDoubleMatrix(this->block_distribution_pt(pronumber));
  inv_v_mass_pt->build_without_copy(v_nrow,v_nrow_local,
                                    v_values,v_column_index,
                                    v_row_start);
  /*
  // Create pressure mass matrix
  if (L_prec_type != Exact_lsc_block_preconditioner)
  {
  // Create column index and row start for pressure mass matrix
  int* p_column_index = new int[p_nrow_local];
  int* p_row_start = new int[p_nrow_local+1];
  for (unsigned i = 0; i < p_nrow_local; i++)
  {

  #ifdef PARANOID
  if (p_values[i]==0.0)
  {
  std::ostringstream error_message;
  error_message << "Zero entry in diagonal of pressure mass matrix\n"
  << "Index: " << i << std::endl;
  throw OomphLibError(
  error_message.str(),
  "ConstrainedNavierStokesSchurComplementPreconditioner::assemble_inv_press_and_veloc_mass_matrix_diagonal()",
  OOMPH_EXCEPTION_LOCATION);
  }
  #endif
  p_values[i] = 1.0/p_values[i];

  p_column_index[i] = p_first_row + i;
  p_row_start[i] = i;
  }
  p_row_start[p_nrow_local] = p_nrow_local;

  // Build the pressure mass matrix
  inv_p_mass_pt = new CRDoubleMatrix(this->block_distribution_pt(1)); // This also needs to change.
  inv_p_mass_pt->build_without_copy(p_nrow,p_nrow_local,
  p_values,p_column_index,
  p_row_start);

  } // if (!Use_LSC)
  */
 }
// void LagrangeEnforcedflowPreconditioner::assemble_inv_press_and_veloc_mass_matrix_diagonal



}
#endif
