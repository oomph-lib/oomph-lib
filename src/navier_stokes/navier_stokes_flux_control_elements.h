//Include guard to prevent multiple inclusions of the header
#ifndef OOMPH_NAVIER_STOKES_FLUX_CONTROL_ELEMENTS
#define OOMPH_NAVIER_STOKES_FLUX_CONTROL_ELEMENTS

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
 #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../navier_stokes/navier_stokes_surface_power_elements.h"

namespace oomph
{

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


//======================================================================
/// A template free base class for an element to imposes an applied 
/// boundary pressure to the Navier-Stokes equations in order to 
/// control a volume flux when used in conjunction with a 
/// NetFluxControlElement or
/// NetFluxControlElementForWomersleyPressureControl). 
//======================================================================
class TemplateFreeNavierStokesFluxControlElementBase : 
public virtual GeneralisedElement 
{
  public:
 
 /// Empty constructor
 TemplateFreeNavierStokesFluxControlElementBase() {}
 
 /// Empty virtual destructor 
 virtual ~TemplateFreeNavierStokesFluxControlElementBase() {}

 /// Pure virtual function to calculate integral of the volume flux
 virtual double get_volume_flux()=0;
 
 /// \short Function adds to the external data the Data object whose
 /// single value is the pressure applied by the element
 void add_pressure_data(Data* pressure_data_pt)
  {
   Pressure_data_id = add_external_data(pressure_data_pt);
  }

  protected:

 /// \short Access function gives id of external Data object whose 
 /// single value is the pressure applied by the element
 unsigned& pressure_data_id() {return Pressure_data_id;}

  private:

 /// \short Id of external Data object whose single value is the 
 /// pressure applied by the elements
 unsigned Pressure_data_id;

}; 



//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////



//======================================================================
/// A class for an element that controls the net fluid flux across a 
/// boundary by the imposition of an unknown applied pressure to the 
/// Navier-Stokes equations. This element is used with a mesh of 
/// NavierStokesFluxControlElement elements which are attached 
/// to the boundary. 
/// Note: fill_in_contribution_to_jacobian() does not calculate
/// Jacobian contributions for this element as they are calculated by
/// NavierStokesFluxControlElement::fill_in_contribution_to_jacobian(...)
//======================================================================
class NetFluxControlElement : public virtual GeneralisedElement 
{
  public:
 
 /// \short Constructor takes a mesh of 
 /// TemplateFreeNavierStokesFluxControlElementBase elements
 /// that impose the pressure to control the flux, plus a pointer to
 /// the double which contains the desired flux value
 NetFluxControlElement(Mesh* flux_control_mesh_pt,
                       double* prescribed_flux_value_pt) :
  Flux_control_mesh_pt(flux_control_mesh_pt),
  Prescribed_flux_value_pt(prescribed_flux_value_pt)
  {
   // Construct Pressure_data_pt
   Pressure_data_pt = new Data(1);
   
   // Add the new Data to internal Data for this element
   add_internal_data(Pressure_data_pt);

   // There's no need to add the external data for this element since
   // this elements Jacobian contributions are calculated by the
   // NavierStokesFluxControlElements

   // Loop over elements in the Flux_control_mesh to add this element's
   // Data to the external Data in the elements in the flux control mesh 
   unsigned n_el =  Flux_control_mesh_pt->nelement();
   for (unsigned e=0; e<n_el; e++)
    {
     // Get pointer to the element
     GeneralisedElement* el_pt = Flux_control_mesh_pt->element_pt(e);

     // Perform cast to TemplateFreeNavierStokesFluxControlElementBase pointer
     TemplateFreeNavierStokesFluxControlElementBase* flux_el_pt = 
      dynamic_cast<TemplateFreeNavierStokesFluxControlElementBase*>(el_pt); 
     
     flux_el_pt->add_pressure_data(Pressure_data_pt);
    }
   
   // Default value for Ndof_number_for_unknown 
   Ndof_number_for_unknown = 0;
  }

 
 /// Empty Destructor - Data gets deleted automatically
 ~NetFluxControlElement() {}
 
 /// Broken copy constructor
 NetFluxControlElement(const NetFluxControlElement& dummy) 
  { 
   BrokenCopy::broken_copy("NetFluxControlElement");
  } 
 
 
 /// Broken assignment operator
 void operator=(const NetFluxControlElement&) 
  {
   BrokenCopy::broken_assign("NetFluxControlElement");
  }
 
 
 /// \short Function to return a pointer to the Data object whose
 /// single value is the pressure applied by the
 /// NavierStokesFluxControlElement elements
 Data* pressure_data_pt() const {return Pressure_data_pt;}

 
 /// \short Add the element's contribution to its residual vector:
 /// i.e. the flux constraint.
 inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic routine
   fill_in_generic_residual_contribution_flux_control(residuals);
  }
 
 /// \short This function returns the residuals, but adds nothing to the 
 /// Jacobian as this element's Jacobian contributions are calculated by 
 /// the NavierStokesFluxControlElements which impose the traction 
 /// used to control the flux. 
 inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                              DenseMatrix<double> &jacobian)
  {
   //Call the generic routine
   fill_in_generic_residual_contribution_flux_control(residuals);
  }


 /// \short The number of "blocks" that degrees of freedom in this element
 /// are sub-divided into - set to Ndof_number_for_unknown+1
 /// because it's expected this element is added to a fluid mesh 
 /// containing navier stokes elements
 unsigned ndof_types()
  {
   return Ndof_number_for_unknown+1;
  }

 /// \short The id number of the "block" to which the degree
 /// of freedom in this element is added to. This should be set to the 
 /// number id of the Navier-Stokes pressure block (which is dimension
 /// dependent!) if this element is added to a fluid mesh 
 /// containing navier stokes elements
 unsigned& ndof_number_for_unknown() {return Ndof_number_for_unknown; }

 /// \short Create a list of pairs for all unknowns in this element,
 /// so that the first entry in each pair contains the global equation
 /// number of the unknown, while the second one contains the number
 /// of the "block" that this unknown is associated with.
 /// (Function can obviously only be called if the equation numbering
 /// scheme has been set up.) The single degree of freedom is given the 
 /// block number of 1 since it's expected this unknown is added to the 
 /// Navier-Stokes pressure block
 void get_dof_numbers_for_unknowns(
  std::list<std::pair<unsigned long, unsigned> >& block_lookup_list)
  {
   // pair to store block lookup prior to being added to list
   std::pair<unsigned,unsigned> block_lookup;
 
   block_lookup.first = this->eqn_number(0);
   block_lookup.second = Ndof_number_for_unknown;
     
   // add to list
   block_lookup_list.push_front(block_lookup);
  }
 
  protected:
 
 ///\short This function returns the residuals for the 
 ///flux control master element.
 void fill_in_generic_residual_contribution_flux_control(
  Vector<double> &residuals)
  {

   // Initialise volume flux
   double volume_flux  = 0.0;
   
   // Loop over elements in Flux_control_mesh_pt and calculate flux 
   unsigned n_el = Flux_control_mesh_pt->nelement();
   for (unsigned e=0; e<n_el; e++)
    {
     // Get a pointer to the element
     GeneralisedElement* el_pt = Flux_control_mesh_pt->element_pt(e);
     
     // Cast to NavierStokesFluxControlElement
     TemplateFreeNavierStokesFluxControlElementBase* flux_control_el_pt=0;
     flux_control_el_pt = 
      dynamic_cast<TemplateFreeNavierStokesFluxControlElementBase*>(el_pt);

#ifdef PARANOID
   if (flux_control_el_pt==0)
    {
     throw OomphLibError(
      "Element must be used with a mesh of NavierStokesFluxControlElements",
      "NetFluxControlElement::fill_in_generic_residual_contribution_flux_control()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
     
     // Add the elemental volume flux
     volume_flux += flux_control_el_pt->get_volume_flux();
    }
   
   residuals[0] += *Prescribed_flux_value_pt -  volume_flux;
  }
 
 
private:
 
 /// \short Data object whose single value is the pressure 
 /// applied by the elements in the Flux_control_mesh_pt
 Data* Pressure_data_pt;
 
 /// \short Mesh of elements which impose the pressure which controls
 /// the net flux
 Mesh* Flux_control_mesh_pt;
 
 /// \short Pointer to the value that stores the prescribed flux
 double* Prescribed_flux_value_pt;

 /// \short The id number of the "block" to which the degree
 /// of freedom in this element is added to. This should be set to the 
 /// number id of the Navier-Stokes pressure block (which is dimension
 /// dependent!) if this element is added to a fluid mesh 
 /// containing navier stokes elements
 unsigned Ndof_number_for_unknown;

};




//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////



//======================================================================
/// A class of element to impose an applied boundary pressure to 
/// Navier-Stokes elements to control to control a volume flux. A mesh of 
/// these elements are used in conjunction with a NetFluxControlElement. 
/// The template arguement ELEMENT is a Navier-Stokes "bulk" element. 
///
/// Note: This element calculates Jacobian contributions for both itself
/// and also for the NetFluxControlElement with respect to its unknowns.
//======================================================================
template <class ELEMENT>
class NavierStokesFluxControlElement : 
 public virtual TemplateFreeNavierStokesFluxControlElementBase,
 public virtual NavierStokesSurfacePowerElement<ELEMENT> 
{
  public:
 
 ///Constructor, which takes a "bulk" element and the value of the index
 ///and its limit
 NavierStokesFluxControlElement(FiniteElement* const &element_pt, 
                                const int &face_index) : 
  NavierStokesSurfacePowerElement<ELEMENT>(element_pt, face_index)
  { 
#ifdef PARANOID
   {
    //Check that the element is not a refineable 3d element
    ELEMENT* elem_pt = new ELEMENT;
    //If it's three-d
    if(elem_pt->dim()==3)
     {
      //Is it refineable
      if(dynamic_cast<RefineableElement*>(elem_pt))
       {
        //Issue a warning
        OomphLibWarning(
         "This flux element will not work correctly if nodes are hanging\n",
         "NavierStokesFluxControlElement::Constructor",
         OOMPH_EXCEPTION_LOCATION);
       }
     }
   }
#endif
   
   //Set the dimension from the dimension of the first node (since Dim is 
   //private in the parent class)
   Dim = this->node_pt(0)->ndim();
  }
 
 /// Destructor should not delete anything
 ~NavierStokesFluxControlElement() {}

 ///This function returns just the residuals
 inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function using a dummy matrix argument
   fill_in_generic_residual_contribution_fluid_traction(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }
 
 ///\short This function returns the residuals and the Jacobian 
 /// including the Jacobian contribution from the flux control 
 ///master element with respect to dof in this 
 ///element 
 inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                              DenseMatrix<double> &jacobian)
  {
   //Call the generic routine
   fill_in_generic_residual_contribution_fluid_traction(residuals,jacobian,1);
  }
 
 ///Overload the output function
 void output(std::ostream &outfile) {FiniteElement::output(outfile);}
 
 /// Output function: x,y,[z],u,v,[w],p in tecplot format
 void output(std::ostream &outfile, const unsigned &nplot)
  {FiniteElement::output(outfile,nplot);}

 /// Function to get the integral of the volume flux
 double get_volume_flux()
  {
   return NavierStokesSurfacePowerElement<ELEMENT>::get_volume_flux();
  } 
 
protected:
 
 
 /// \short Access function that returns the local equation numbers
 /// for velocity components.
 /// u_local_eqn(n,i) = local equation number or < 0 if pinned.
 /// The default is to asssume that n is the local node number
 /// and the i-th velocity component is the i-th unknown stored at the node.
 virtual inline int u_local_eqn(const unsigned &n, const unsigned &i)
  {return this->nodal_local_eqn(n,i);}
 
 ///\short Function to compute the shape and test functions and to return 
 ///the Jacobian of mapping 
 inline double shape_and_test_at_knot(const unsigned &ipt, 
                                      Shape &psi, Shape &test)
  const
  {
   //Find number of nodes
   unsigned n_node = this->nnode();
   //Calculate the shape functions
   this->shape_at_knot(ipt,psi);
   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}
   //Return the value of the jacobian
   return this->J_eulerian_at_knot(ipt);
  }
 
 
 ///\short This function returns the residuals for the traction function
 ///flag=1(or 0): do (or don't) compute the Jacobian as well. 
 ///This function also calculates the Jacobian contribution for the 
 ///NetFluxControlElement
 void fill_in_generic_residual_contribution_fluid_traction(
  Vector<double> &residuals, 
  DenseMatrix<double> &jacobian,
  unsigned flag)
  {
   //Find out how many nodes there are
   unsigned n_node = this->nnode();
   
   //Set up memory for the shape and test functions
   Shape psif(n_node), testf(n_node);
   
   //Set the value of n_intpt
   unsigned n_intpt = this->integral_pt()->nweight();
   
   //Integers to store local equation numbers
   int local_eqn=0;
   
   // Get the pressure at the outflow
   double pressure = this->external_data_pt(pressure_data_id())->value(0);
   
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Get the integral weight
     double w = this->integral_pt()->weight(ipt);
     
     //Find the shape and test functions and return the Jacobian
     //of the mapping
     double J = shape_and_test_at_knot(ipt,psif,testf);
     
     //Premultiply the weights and the Jacobian
     double W = w*J;
     
     // Get the outer unit normal
     Vector<double> unit_normal(Dim);
     this->outer_unit_normal(ipt, unit_normal);
     
     // Calculate the traction
     Vector<double> traction(Dim);
     for (unsigned i=0; i<Dim; i++)
      {
       traction[i] = -pressure*unit_normal[i];
      }
     
     //Loop over the test functions
     for(unsigned l=0;l<n_node;l++)
      {
       //Loop over the velocity components
       for(unsigned i=0;i<Dim;i++)
        {
         local_eqn = u_local_eqn(l,i);
         
         /*IF it's not a boundary condition*/
         if(local_eqn >= 0)
          {
           //Add the user-defined traction terms
           residuals[local_eqn] += traction[i]*testf[l]*W;

           //Calculate the Jacobian if required. It is assumed 
           //that traction DOES NOT depend upon velocities
           //or pressures in the Navier Stokes elements, but 
           //depend in the Data value which holds the 
           //pressure.
           if (flag)
            {
             //Get equation number of the pressure data unknown
             int local_unknown =
              this->external_local_eqn(pressure_data_id(),0);
             
             //IF it's not a boundary condition
             if(local_unknown >= 0)
              {
               //Add to Jacobian for this element
               double jac_contribution = -unit_normal[i]*testf[l]*W;
               jacobian(local_eqn,local_unknown) += jac_contribution;

               //Add to Jacobian for master element
               jacobian(local_unknown,local_eqn) += jac_contribution;
              }
            }
          }
        } //End of loop over dimension
      } //End of loop over shape functions
    }
  }
 
private:
 
 ///The highest dimension of the problem 
 unsigned Dim;

}; 

}

#endif


