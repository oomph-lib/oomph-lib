//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for elements that are used to apply surface loads to 
//the equations of elasticity

#ifndef OOMPH_SOLID_TRACTION_ELEMENTS_HEADER
#define OOMPH_SOLID_TRACTION_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//OOMPH-LIB headers
#include "../generic/Qelements.h"
#include "../generic/hermite_elements.h"

namespace oomph
{



//=======================================================================
/// Namespace containing the zero traction function for solid traction
/// elements
//=======================================================================
namespace SolidTractionElementHelper
 {

  //=======================================================================
  /// Default load function (zero traction)
  //=======================================================================
  void Zero_traction_fct(const Vector<double>& xi,
                         const Vector<double> &x,
                         const Vector<double>& N,
                         Vector<double>& load)
   {
    unsigned n_dim=load.size();
    for (unsigned i=0;i<n_dim;i++) {load[i]=0.0;}
   }
 
 }


//======================================================================
/// A class for elements that allow the imposition of an applied traction
/// in the principle of virtual displacements.
/// The geometrical information can be read from the FaceGeometry<ELEMENT> 
/// class and and thus, we can be generic enough without the need to have
/// a separate equations class.
//======================================================================
template <class ELEMENT>
class SolidTractionElement : public virtual FaceGeometry<ELEMENT>, 
public virtual SolidFaceElement
{

  protected:

 /// \short Pointer to an imposed traction function. Arguments:
 /// Lagrangian coordinate; Eulerian coordinate; outer unit normal;
 /// applied traction. (Not all of the input arguments will be
 /// required for all specific load functions but the list should
 /// cover all cases)
 void (*Traction_fct_pt)(const Vector<double> &xi, 
                         const Vector<double> &x, 
                         const Vector<double> &n,
                         Vector<double> &result);
 

 /// \short Get the traction vector: Pass number of integration point (dummy), 
 /// Lagr. coordinate and normal vector and return the load vector
 /// (not all of the input arguments will be
 /// required for all specific load functions but the list should
 /// cover all cases). This function is virtual so it can be 
 /// overloaded for FSI.
 virtual void get_traction(const unsigned& intpt,
                           const Vector<double>& xi,
                           const Vector<double>& x,
                           const Vector<double>& n,
                           Vector<double>& traction)
  {
   Traction_fct_pt(xi,x,n,traction);
  }


 /// \short Helper function that actually calculates the residuals
 // This small level of indirection is required to avoid calling
 // fill_in_contribution_to_residuals in fill_in_contribution_to_jacobian
 // which causes all kinds of pain if overloading later on
 void fill_in_contribution_to_residuals_solid_traction(
  Vector<double> &residuals);


public:

 /// \short Constructor, which takes a "bulk" element and the 
 /// value of the index and its limit
 SolidTractionElement(FiniteElement* const &element_pt, 
                      const int &face_index) : 
  FaceGeometry<ELEMENT>(), FaceElement()
  { 
#ifdef PARANOID
   {
  //Check that the element is not a refineable 3d element
  if(element_pt->dim()==3)
   {
    //Is it refineable
    if(dynamic_cast<RefineableElement*>(element_pt))
     {
      //Issue a warning
      OomphLibWarning(
       "This flux element will not work correctly if nodes are hanging\n",
       "SolidTractionElement::Constructor",
       OOMPH_EXCEPTION_LOCATION);
     }
   }
 }
#endif
 
   //Attach the geometrical information to the element. N.B. This function
   //also assigns nbulk_value from the required_nvalue of the bulk element
   element_pt->build_face_element(face_index,this);
 
   // Zero traction
   Traction_fct_pt=&SolidTractionElementHelper::Zero_traction_fct;
  }
 

 /// Reference to the traction function pointer
 void (* &traction_fct_pt())(const Vector<double>& xi,
                             const Vector<double>& x,
                             const Vector<double>& n,
                             Vector<double>& traction)
  {return Traction_fct_pt;}


 /// Return the residuals
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   fill_in_contribution_to_residuals_solid_traction(residuals);
  }

 

 /// Fill in contribution from Jacobian
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                       DenseMatrix<double> &jacobian)
  {
   //Call the residuals
   fill_in_contribution_to_residuals_solid_traction(residuals);
   //Call the generic FD jacobian calculation
   FaceGeometry<ELEMENT>::fill_in_jacobian_from_solid_position_by_fd(jacobian);
   }

 /// \short Output function
 void output(std::ostream &outfile)
  {
   unsigned n_plot=5;
   output(outfile,n_plot);
  }
 

 /// \short Output function
 void output(std::ostream &outfile, const unsigned &n_plot)
 {
  unsigned n_dim = this->nodal_dimension();
  
  Vector<double> x(n_dim);
  Vector<double> xi(n_dim);
  Vector<double> s(n_dim-1);
 
  // Tecplot header info
  outfile << this->tecplot_zone_string(n_plot);
  
  // Loop over plot points
  unsigned num_plot_points=this->nplot_points(n_plot);
  for (unsigned iplot=0;iplot<num_plot_points;iplot++)
   {
    // Get local coordinates of plot point
    this->get_s_plot(iplot,n_plot,s);
    
    // Get Eulerian and Lagrangian coordinates
    this->interpolated_x(s,x);
    this->interpolated_xi(s,x);   

    // Outer unit normal
    Vector<double> unit_normal(n_dim);
    outer_unit_normal(s,unit_normal);

    // Dummy
    unsigned ipt=0;
    
    // Traction vector
    Vector<double> traction(n_dim);
    get_traction(ipt,xi,x,unit_normal,traction);
    
    //Output the x,y,..
    for(unsigned i=0;i<n_dim;i++) 
     {outfile << x[i] << " ";}
    
    // Output traction
    for(unsigned i=0;i<n_dim;i++) 
     {outfile << traction[i] << " ";} 
    
    // Output normal
    for(unsigned i=0;i<n_dim;i++) 
     {outfile << unit_normal[i] << " ";} 
    
    outfile << std::endl;
   }
   
  // Write tecplot footer (e.g. FE connectivity lists)
  this->write_tecplot_zone_footer(outfile,n_plot);
  
 }
 
 /// \short C_style output function
 void output(FILE* file_pt)
 {FiniteElement::output(file_pt);}

 /// \short C-style output function
 void output(FILE* file_pt, const unsigned &n_plot)
  {FiniteElement::output(file_pt,n_plot);}


 /// \short Compute traction vector at specified local coordinate
 /// Should only be used for post-processing; ignores dependence
 /// on integration point!
 void traction(const Vector<double>& s, 
               Vector<double>& traction);

}; 

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//=====================================================================
/// Compute traction vector at specified local coordinate
/// Should only be used for post-processing; ignores dependence
/// on integration point!
//=====================================================================
template<class ELEMENT>
void SolidTractionElement<ELEMENT>::traction(const Vector<double>& s, 
                                             Vector<double>& traction)
{
 unsigned n_dim = this->nodal_dimension();

 // Position vector
 Vector<double> x(n_dim);
 interpolated_x(s,x);


 // Lagrangian coordinate
 Vector<double> xi(n_dim);
 this-> interpolated_xi(s,x);

 // Outer unit normal
 Vector<double> unit_normal(n_dim);
 outer_unit_normal(s,unit_normal);

 // Dummy
 unsigned ipt=0;

 // Traction vector
 get_traction(ipt,xi,x,unit_normal,traction);

}

 
//=====================================================================
/// Return the residuals for the SolidTractionElement equations
//=====================================================================
template<class ELEMENT>
void SolidTractionElement<ELEMENT>::
fill_in_contribution_to_residuals_solid_traction(Vector<double> &residuals)
{
 //Find out how many nodes there are
 unsigned n_node = nnode();

 //Find out how many positional dofs there are
 unsigned n_position_type = this->nnodal_position_type();

 //Find out the dimension of the node
 unsigned n_dim = this->nodal_dimension();

 //Integer to hold the local equation number
 int local_eqn=0;
   
 //Set up memory for the shape functions
 //Note that in this case, the number of lagrangian coordinates is always
 //equal to the dimension of the nodes
 Shape psi(n_node,n_position_type);
 DShape dpsids(n_node,n_position_type,n_dim-1); 

 //Set the value of n_intpt
 unsigned n_intpt = integral_pt()->nweight();
 
 //Loop over the integration points
 for(unsigned ipt=0;ipt<n_intpt;ipt++)
  {
   //Get the integral weight
   double w = integral_pt()->weight(ipt);
   
   //Only need to call the local derivatives
   dshape_local_at_knot(ipt,psi,dpsids);

   //Calculate the Eulerian and Lagrangian coordinates 
   Vector<double> interpolated_x(n_dim,0.0);
   Vector<double> interpolated_xi(n_dim,0.0);

   //Also calculate the surface Vectors (derivatives wrt local coordinates)
   DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);   
  
   //Calculate displacements and derivatives
   for(unsigned l=0;l<n_node;l++) 
    {
     //Loop over positional dofs
     for(unsigned k=0;k<n_position_type;k++)
      {
       //Loop over displacement components (deformed position)
       for(unsigned i=0;i<n_dim;i++)
        {
         //Calculate the Eulerian and Lagrangian positions
         interpolated_x[i] += 
          nodal_position_gen(l,bulk_position_type(k),i)*psi(l,k);

         interpolated_xi[i] += 
          this->lagrangian_position_gen(l,bulk_position_type(k),i)*psi(l,k);

         //Loop over LOCAL derivative directions, to calculate the tangent(s)
         for(unsigned j=0;j<n_dim-1;j++)
          {
           interpolated_A(j,i) += 
            nodal_position_gen(l,bulk_position_type(k),i)*dpsids(l,k,j);
          }
        }
      }
    }

   //Now find the local deformed metric tensor from the tangent Vectors
   DenseMatrix<double> A(n_dim-1);
   for(unsigned i=0;i<n_dim-1;i++)
    {
     for(unsigned j=0;j<n_dim-1;j++)
      {
       //Initialise surface metric tensor to zero
       A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
         A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
        }
      }
    }

   //Get the outer unit normal
   Vector<double> interpolated_normal(n_dim);
   outer_unit_normal(ipt,interpolated_normal);
   
   //Find the determinant of the metric tensor
   double Adet =0.0;
   switch(n_dim)
    {
    case 2:
     Adet = A(0,0);
     break;
    case 3:
     Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
     break;
    default:
     throw 
      OomphLibError("Wrong dimension in SolidTractionElement",
                    "SolidTractionElement::fill_in_contribution_to_residuals()",
                    OOMPH_EXCEPTION_LOCATION);
    }

   //Premultiply the weights and the square-root of the determinant of 
   //the metric tensor
   double W = w*sqrt(Adet);

   //Now calculate the load
   Vector<double> traction(n_dim);
   get_traction(ipt,
                interpolated_xi,
                interpolated_x,
                interpolated_normal,
                traction);
   
   //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========
       
   //Loop over the test functions, nodes of the element
   for(unsigned l=0;l<n_node;l++)
    {
     //Loop of types of dofs
     for(unsigned k=0;k<n_position_type;k++)
      {
       //Loop over the displacement components
       for(unsigned i=0;i<n_dim;i++)
        {
         local_eqn = this->position_local_eqn(l,bulk_position_type(k),i);
         /*IF it's not a boundary condition*/
         if(local_eqn >= 0)
          {
           //Add the loading terms to the residuals
           residuals[local_eqn] -= traction[i]*psi(l,k)*W;
          }
        }
      } //End of if not boundary condition
    } //End of loop over shape functions
  } //End of loop over integration points

}



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


 //=========================================================================
 /// SolidTractionElement "upgraded" to a FSIWallElement (and thus, 
 /// by inheritance, a GeomObject), so it can be used in FSI. 
 /// The element is templated by the bulk solid element and 
 /// the spatial (Eulerian) dimension of the bulk element.
 //=========================================================================
 template<class ELEMENT, unsigned DIM>
 class FSISolidTractionElement : 
  public virtual SolidTractionElement<ELEMENT>, 
  public virtual FSIWallElement
{

  private:

 /// Boolean flag to indicate whether the normal is directed into the fluid
 bool Normal_points_into_fluid;
 
  public:

 
 /// \short Constructor: Create element as FSIWallElement (and thus,
 /// by inheritance, a GeomObject) with DIM-1 Lagrangian and DIM
 /// Eulerian coordinates. By default, we assume that the
 /// normal vector computed by the underlying FaceElement 
 /// points into the fluid. If this is not the case, overwrite this
 /// with the access function 
 /// FSISolidTractionElement::normal_points_into_fluid().
 /// Constructor for GeomObject is called explicitly because
 /// of virtual inheritance!
 FSISolidTractionElement(FiniteElement* const &element_pt, 
                         const int &face_index) : 
  SolidTractionElement<ELEMENT>(element_pt,face_index), 
  Normal_points_into_fluid(true)
  {
   unsigned n_lagr=DIM-1;
   unsigned n_dim=DIM;
   setup_fsi_wall_element(n_lagr,n_dim);
  } 
 
 /// \short Destructor: empty
 ~FSISolidTractionElement(){}

 /// \short Does the normal computed by the underlying FaceElement
 /// point into the fluid?
 bool &normal_points_into_fluid() {return Normal_points_into_fluid;}

 /// \short Derivative of position vector w.r.t. the SolidFiniteElement's
 /// Lagrangian coordinates; evaluated at current time.
 void dposition_dlagrangian_at_local_coordinate(
  const Vector<double>& s, DenseMatrix<double> &drdxi) const
  {
   throw OomphLibError(
    "Broken -- who calls this? \n",
    "FSISolidTractionElement::dposition_dlagrangian_at_local_coordinate()",
    OOMPH_EXCEPTION_LOCATION);
  }  


 /// \short Final overload... Forwards to the version in the FSIWallElement
 virtual void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                               DenseMatrix<double> &jacobian)
  {
  //Call the underlying element's jacobian function
  SolidTractionElement<ELEMENT>::
    fill_in_contribution_to_jacobian(residuals,jacobian);
  //Add the contribution of the external load data by finite differences
  this->fill_in_jacobian_from_external_interaction_by_fd(jacobian);
  }


 /// \short Get the load vector: Pass number of the integration point,
 /// Lagr. coordinate, Eulerian coordinate (neither of the last two 
 /// are used in the FSI implementation of this function!) and normal vector 
 /// and return the load vector, taking
 /// the sign of the normal into account. 
 virtual void get_traction(const unsigned& intpt,
                           const Vector<double>& xi,
                           const Vector<double>& x,
                           const Vector<double>& n,
                           Vector<double>& traction)
  { 

   // Get the fluid load on the wall stress scale, i.e. this
   // includes the ratio of stresses represented by Q.
   fluid_load_vector(intpt,n,traction);
   
   //If the normal is outer to the fluid switch the direction
   if (!Normal_points_into_fluid)
    {
     for(unsigned i=0;i<DIM;i++)
      {
       traction[i]*=-1.0;
      }
    }
   
  }//end of get_traction



 /// \short Output function: Note we can only output the traction
 /// at Gauss points so n_plot is actually ignored.
 void output(std::ostream &outfile, const unsigned &n_plot)
  {
   //Tecplot header info 
   outfile << "ZONE" << std::endl;
   
   //Find the number of Gauss points of the element
   unsigned n_intpt = this->integral_pt()->nweight();
   
   //Find the dimension of the element (i.e. its number of local coordinates)
   unsigned el_dim = this->dim();
   
   // Set storage for the local coordinates of the Gauss points
   // in the solid 
   Vector<double> s(el_dim);
        
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Loop over the dimension of the solid element and find the local
     //coordinates of the Gauss points, then the global
     for(unsigned i=0;i<el_dim;i++) 
      {
       s[i] = integral_pt()->knot(ipt,i);
      }

     // Eulerian position of Gauss point
     Vector<double> r(DIM);
     interpolated_x(s,r);
     
     // Outer unit normal
     Vector<double> unit_normal(DIM);
     this->outer_unit_normal(s,unit_normal);
     
     // Compute traction with dummy arguments for xi
     Vector<double> xi(el_dim,0.0);
     Vector<double> traction(DIM);
     //Don't get the traction if you are a halo element because
     //the external elements will not have been set up
#ifdef OOMPH_HAS_MPI
     if(!this->is_halo())
#endif
      {
       get_traction(ipt,xi,r,unit_normal,traction);
      }

     
     for (unsigned i=0;i<DIM;i++)
      {
       outfile << r[i]  << " ";
      }
     for (unsigned i=0;i<DIM;i++)
      {
       outfile << traction[i] << " ";
      }
     for (unsigned i=0;i<DIM;i++)
      {
       outfile <<  unit_normal[i] << " ";
      }
     outfile << std::endl;     
    }
  }
 
 /// \short Broken overloaded reference to the traction function pointer. 
 /// It doesn't make sense to specify an external
 /// traction.
 virtual void (* &traction_fct_pt())(const Vector<double>& xi,
                                     const Vector<double>& x,
                                     const Vector<double>& n,
                                     Vector<double>& traction)
  {   
   throw OomphLibError(
    "It doesn't make sense to specify an external traction in an FSI context",
    "FSISolidTractionElement::traction_fct_pt()",
    OOMPH_EXCEPTION_LOCATION);

   // Dummy return to shut up the compiler
   return this->Traction_fct_pt;
  }

 /// \short The number of "blocks" that degrees of freedom in this element
 /// are sub-divided into: Just the solid degrees of freedom themselves.
 unsigned ndof_types()
  {
   return 1;
  }
 
 /// \short Create a list of pairs for all unknowns in this element,
 /// so that the first entry in each pair contains the global equation
 /// number of the unknown, while the second one contains the number
 /// of the "block" that this unknown is associated with.
 /// (Function can obviously only be called if the equation numbering
 /// scheme has been set up.) 
 void get_dof_numbers_for_unknowns(
  std::list<std::pair<unsigned long,unsigned> >& block_lookup_list);

};


//=============================================================================
/// Create a list of pairs for all unknowns in this element,
/// so that the first entry in each pair contains the global equation
/// number of the unknown, while the second one contains the number
/// of the "block" that this unknown is associated with.
/// (Function can obviously only be called if the equation numbering
/// scheme has been set up.) This element is only in charge of the solid dofs.
//=============================================================================
 template<class ELEMENT, unsigned DIM>
void FSISolidTractionElement<ELEMENT,DIM>::get_dof_numbers_for_unknowns(
 std::list<std::pair<unsigned long,unsigned> >& block_lookup_list)
{

 // temporary pair (used to store block lookup prior to being added to list)
 std::pair<unsigned,unsigned> block_lookup;
 
 // number of nodes
 const unsigned n_node = this->nnode();
  
 //Get the number of position dofs and dimensions at the node
 const unsigned n_position_type = nnodal_position_type();
 const unsigned nodal_dim = nodal_dimension();
 
 //Integer storage for local unknown
 int local_unknown=0;
 
 //Loop over the nodes
 for(unsigned n=0;n<n_node;n++)
  {
   //Loop over position dofs
   for(unsigned k=0;k<n_position_type;k++)
    {
     //Loop over dimension
     for(unsigned i=0;i<nodal_dim;i++)
      {
       //If the variable is free
       local_unknown = position_local_eqn(n,k,i);
       
       // ignore pinned values
       if (local_unknown >= 0)
        {
         // store block lookup in temporary pair: First entry in pair
         // is global equation number; second entry is block type
         block_lookup.first = this->eqn_number(local_unknown);
         block_lookup.second = 0;
         
         // add to list
         block_lookup_list.push_front(block_lookup);
         
        }
      }
    }
  }
}



////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////



//======================================================================
/// A class for elements that allow the imposition of a displacement
/// constraint for "bulk" solid elements via a Lagrange multiplier.
/// The geometrical information can be read from the FaceGeometry<ELEMENT> 
/// class and and thus, we can be generic enough without the need to have
/// a separate equations class.
/// \b NOTE: Currently (and for the foreseeable future) this 
/// element only works with bulk elements that do not have
/// generalised degrees of freedom (so it won't work with
/// Hermite-type elements, say). The additional functionality 
/// to deal with such elements could easily be added (once a 
/// a suitable test case is written). For now we simply throw
/// errors if an attempt is made to use the element with an unsuitable
/// bulk element.
//======================================================================
template <class ELEMENT>
class ImposeDisplacementByLagrangeMultiplierElement : 
  public virtual FaceGeometry<ELEMENT>, 
  public virtual SolidFaceElement
{
 
public:

 /// \short Constructor takes a "bulk" element and the 
 /// index that identifies which face the FaceElement is supposed
 /// to be attached to.
 ImposeDisplacementByLagrangeMultiplierElement(
  FiniteElement* const &element_pt, 
  const int &face_index, const unsigned &id=0) : 
 FaceGeometry<ELEMENT>(), FaceElement(), Boundary_shape_geom_object_pt(0)
  {   
   //  set the Id
   Id=id;

   // By default sparsify, i.e. check if the GeomObject that
   // defines the boundary contains sub-GeomObjects. If so,
   // only use their GeomData as the external Data that affects
   // this element's residuals.
   Sparsify=true;
   
#ifdef PARANOID
   { 
    // Initialise number of assigned geom Data.
    N_assigned_geom_data=0;

    //Check that the bulk element is not a refineable 3d element
    //If it's three-d
    if(element_pt->dim()==3)
     {
      //Is it refineable
      if(dynamic_cast<RefineableElement*>(element_pt))
       {
        //Issue a warning
        OomphLibWarning(
         "This flux element will not work correctly if nodes are hanging\n",
         "ImposeDisplacementByLagrangeMultiplierElement::Constructor",
         OOMPH_EXCEPTION_LOCATION);
       }
     }
   }
   {
    // Check that the bulk element does not require generalised positional
    // degrees of freedom
    if(element_pt->nnodal_position_type()!=1)
     {      
      throw OomphLibError(
       "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) be used with elements that have generalised positional dofs",
       "ImposeDisplacementByLagrangeMultiplierElement::ImposeDisplacementByLagrangeMultiplierElement()",
       OOMPH_EXCEPTION_LOCATION);
     }
   }
#endif
 
   //Build the face element
   element_pt->build_face_element(face_index,this);

    
   // dimension of the bulk element
   unsigned dim=element_pt->dim();
 
   // we need dim additional values for each FaceElement node
   Vector<unsigned> n_additional_values(nnode(), dim);
   
   // add storage for lagrange multipliers and set the map containing 
   // the position of the first entry of this face element's 
   // additional values.
   add_additional_values(n_additional_values,id);
  }
 

 /// \short Access to GeomObject that specifies the prescribed 
 /// boundary displacement; GeomObject is assumed to be
 /// parametrised by the same coordinate that is used as
 /// the boundary coordinate in the bulk solid mesh to which
 /// this element is attached.
 GeomObject* boundary_shape_geom_object_pt() const
  {
   return Boundary_shape_geom_object_pt;
  }


 /// \short Set GeomObject that specifies the prescribed 
 /// boundary displacement; GeomObject is assumed to be
 /// parametrised by the same coordinate that is used as
 /// the boundary coordinate in the bulk solid mesh to which
 /// this element is attached. GeomData of GeomObject
 /// is added to this element's external Data. Also specify
 /// the boundary number in the bulk mesh to which this element is 
 /// attached.
 void set_boundary_shape_geom_object_pt(
  GeomObject* boundary_shape_geom_object_pt,
  const unsigned& boundary_number_in_bulk_mesh)
  {

   // Record boundary number
#ifdef PARANOID
   Boundary_number_in_bulk_mesh_has_been_set=true;
#endif
   Boundary_number_in_bulk_mesh=boundary_number_in_bulk_mesh;


   // Store (possibly compound) GeomObject that specifies the
   // the desired  boundary shape.
   Boundary_shape_geom_object_pt=boundary_shape_geom_object_pt;


   // Don't sparsify: Use all the geometric Data associated with
   // the (possibly compound) GeomObject that specifies the
   // boundary shape as external data for this element.
   if (!Sparsify)
    {
     unsigned n_geom_data=boundary_shape_geom_object_pt->ngeom_data();

#ifdef PARANOID
     if ((this->nexternal_data()>0)&&
         (N_assigned_geom_data!=this->nexternal_data()))
      {
       std::ostringstream error_message;
       error_message << "About to wipe external data for "
                     << "ImposeDisplacementByLagrangeMultiplierElement.\n" 
                     << "I noted that N_assigned_geom_data = "
                     << N_assigned_geom_data << " != nexternal_data() = "
                     << this->nexternal_data() << " \n"
                     << "so we're going to wipe some external data that\n"
                     << "is not geometric Data of the GeomObject that\n"
                     << "specifies the desired boundary shape.\n"
                     << std::endl;
       throw OomphLibError(
        error_message.str(),
        "ImposeDisplacementByLagrangeMultiplierElement::set_boundary_shape_geom_object_pt()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     this->flush_external_data();
     for (unsigned i=0;i<n_geom_data;i++)
      {
       add_external_data(boundary_shape_geom_object_pt->geom_data_pt(i));
      }
#ifdef PARANOID     
     N_assigned_geom_data=n_geom_data;
#endif
    }
   // Sparsify: Use locate_zeta to determine the sub-GeomObjects that 
   // make up  the (possibly compound) GeomObject that specifies the
   // boundary shape. Use their geometric Data as external data for 
   // this element.
   else
    {
     //Find out how many nodes there are
     unsigned n_node = nnode();
    
     //Get the number of position dofs and dimensions at the node
     const unsigned n_position_type = nnodal_position_type();
 
     // Dimension of element
     unsigned dim_el=dim();
     
     //Set up memory for the shape functions
     Shape psi(n_node);

     
#ifdef PARANOID
     if ((this->nexternal_data()>0)&&
         (N_assigned_geom_data!=this->nexternal_data()))
      {
       std::ostringstream error_message;
       error_message << "About to wipe external data for "
                     << "ImposeDisplacementByLagrangeMultiplierElement.\n"
                     << "I noted that N_assigned_geom_data = "
                     << N_assigned_geom_data << " != nexternal_data() = "
                     << this->nexternal_data() << " \n"
                     << "so we're going to wipe some external data that\n"
                     << "is not geometric Data of the GeomObject that\n"
                     << "specifies the desired boundary shape.\n"
                     << std::endl;
       throw OomphLibError(
        error_message.str(),
        "ImposeDisplacementByLagrangeMultiplierElement::set_boundary_shape_geom_object_pt()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // Flush the data
     this->flush_external_data();

#ifdef PARANOID
     N_assigned_geom_data=0;
#endif     

     //Prepare local storage
     unsigned n_intpt = integral_pt()->nweight();
     Sub_geom_object_pt.resize(n_intpt); 
     Zeta_sub_geom_object.resize(n_intpt); 

     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       
       //Get shape function
       shape_at_knot(ipt,psi);
       
       //Calculate the intrinsic coordinates
       Vector<double> zeta(dim_el,0.0);
       Vector<double> s(dim_el);
       
       // Loop over nodes
       for(unsigned j=0;j<n_node;j++) 
        {
         for(unsigned k=0;k<n_position_type;k++)
          {   
           //Assemble the intrinsic coordinate
           for(unsigned i=0;i<dim_el;i++)
            {
             zeta[i]+=zeta_nodal(j,k,i)*psi(j,k);
            }
          }
        }

       // Find sub-GeomObject and local coordinate within it
       // at integration point
       Zeta_sub_geom_object[ipt].resize(dim_el);
       Boundary_shape_geom_object_pt->locate_zeta(zeta, 
                                                  Sub_geom_object_pt[ipt], 
                                                  Zeta_sub_geom_object[ipt]);
      
       unsigned n_geom_data=Sub_geom_object_pt[ipt]->ngeom_data();
       for (unsigned i=0;i<n_geom_data;i++)
        {
         add_external_data(Sub_geom_object_pt[ipt]->geom_data_pt(i));
        }
#ifdef PARANOID
       N_assigned_geom_data+=n_geom_data;
#endif
      }
    }
   
  }
 
 /// Fill in the residuals
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic routine with the flag set to 0
   fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }

 
 /// Fill in contribution from Jacobian
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                   DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
    residuals,jacobian,1);

   // Fill in the derivatives w.r.t. external data by FD, re-using
   // the pre-computed residual vector
   fill_in_jacobian_from_external_by_fd(residuals,jacobian);
  }

 
 /// \short Output function
 void output(std::ostream &outfile, const unsigned &n_plot)
  {
   // Elemental dimension
   unsigned dim_el=dim();

   //Find the number of positional types
   unsigned n_position_type = this->nnodal_position_type();
   
#ifdef PARANOID
   if(n_position_type!=1)
    {      
     throw OomphLibError(
      "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) be used with elements that have generalised positional dofs",
      "ImposeDisplacementByLagrangeMultiplierElement::output()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif


   //Local coord
   Vector<double> s(dim_el);
      
   // # of nodes, 
   unsigned n_node=nnode();
   Shape psi(n_node,n_position_type);

   //Tecplot header info 
   outfile << "ZONE I=" << n_plot << std::endl;
   
   //Loop over plot points
   for(unsigned l=0;l<n_plot;l++)
    {
     s[0] = -1.0 + l*2.0/(n_plot-1);
     
     // Get shape function
     shape(s,psi);
     
     //Calculate the Eulerian coordinates and Lagrange multiplier
     Vector<double> x(dim_el+1,0.0);
     Vector<double> lambda(dim_el+1,0.0);
     Vector<double> zeta(dim_el,0.0);
     for(unsigned j=0;j<n_node;j++) 
      {
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt = 
        dynamic_cast<BoundaryNodeBase*>(node_pt(j));

       // get the node pt
         Node* nod_pt = node_pt(j);

       // higher dimensional quantities
       for(unsigned i=0;i<dim_el+1;i++)
        {
         x[i]+=nodal_position(j,i)*psi(j,0); // need to sort
                                             // this out properly
                                             // for generalised dofs
         lambda[i]+=nod_pt->value
          ((*bnod_pt->first_face_element_value_pt())[Id] +i)*psi(j,0);
        }
       //In-element quantities
       for(unsigned i=0;i<dim_el;i++)
        {
         //Loop over positional types
         for (unsigned k=0;k<n_position_type;k++)
          {
           zeta[i]+=zeta_nodal(j,k,i)*psi(j,k);
          }
        }
      }

     // Get prescribed wall shape
     Vector<double> r_prescribed(dim_el+1);
     Boundary_shape_geom_object_pt->position(zeta,r_prescribed);

     //Output stuff
     outfile << x[0] << " "
             << x[1] << " "
             << -lambda[0] << " "
             << -lambda[1] << " "
             << r_prescribed[0] << " "
             << r_prescribed[1] << " "
             <<  std::endl;
    }
  }


 /// \short Output function
 void output(std::ostream &outfile)
  {
   unsigned n_plot=5;
   output(outfile,n_plot);
  }


protected:

 /// \short Helper function to compute the residuals and, if flag==1, the
 /// Jacobian 
 void fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
  Vector<double> &residuals, 
  DenseMatrix<double> &jacobian, 
  const unsigned& flag)
  {
   //Find out how many positional dofs there are
   unsigned n_position_type = this->nnodal_position_type();
   
#ifdef PARANOID
   if(n_position_type!=1)
    {      
     throw OomphLibError(
      "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) be used with elements that have generalised positional dofs",
      "ImposeDisplacementByLagrangeMultiplierElement::fill_in_generic_contribution_to_residuals_displ_lagr_multiplier()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif

   //Find out how many nodes there are
   unsigned n_node = nnode();
   
   // Dimension of element
   unsigned dim_el=dim();

   //Set up memory for the shape functions
   Shape psi(n_node);
   DShape dpsids(n_node,dim_el); 

   //Set the value of n_intpt
   unsigned n_intpt = integral_pt()->nweight();
 
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Get the integral weight
     double w = integral_pt()->weight(ipt);
     
     //Only need to call the local derivatives
     dshape_local_at_knot(ipt,psi,dpsids);

     //Calculate the Eulerian coordinates and Lagrange multiplier
     Vector<double> x(dim_el+1,0.0);
     Vector<double> lambda(dim_el+1,0.0);
     Vector<double> zeta(dim_el,0.0);
     DenseMatrix<double> interpolated_a(dim_el,dim_el+1,0.0);   

     // Loop over nodes
     for(unsigned j=0;j<n_node;j++) 
      {
       Node* nod_pt=node_pt(j);
       
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt = 
        dynamic_cast<BoundaryNodeBase*>(node_pt(j));

       //Assemble higher-dimensional quantities
       for(unsigned i=0;i<dim_el+1;i++)
        {
         x[i]+=nodal_position(j,i)*psi(j);
         lambda[i]+=nod_pt->value
          ( (*bnod_pt->first_face_element_value_pt())[Id] +i)*psi(j);
         for(unsigned ii=0;ii<dim_el;ii++)
          {
           interpolated_a(ii,i) += 
            lagrangian_position(j,i)*dpsids(j,ii);
          }
        }  
       if (!Sparsify)
        {
         for(unsigned k=0;k<n_position_type;k++)
          {   
           //Assemble in-element quantities: boundary coordinate
           for(unsigned i=0;i<dim_el;i++)
            {
             zeta[i]+=zeta_nodal(j,k,i)*psi(j,k);
            }
          }
        }
      }
     
     if (Sparsify) zeta=Zeta_sub_geom_object[ipt];
      
     
     //Now find the local undeformed metric tensor from the tangent Vectors
     DenseMatrix<double> a(dim_el);
     for(unsigned i=0;i<dim_el;i++)
      {
       for(unsigned j=0;j<dim_el;j++)
        {
         //Initialise surface metric tensor to zero
         a(i,j) = 0.0;
         //Take the dot product
         for(unsigned k=0;k<dim_el+1;k++)
          { 
           a(i,j) += interpolated_a(i,k)*interpolated_a(j,k);
          }
        }
      }

     
     //Find the determinant of the metric tensor
     double adet =0.0;
     switch(dim_el+1)
      {

      case 2:
       adet = a(0,0);
       break;

      case 3:
       adet = a(0,0)*a(1,1) - a(0,1)*a(1,0);
       break;

      default:
       throw 
        OomphLibError(
         "Wrong dimension fill_in_generic_contribution_to_residuals_displ_lagr_multiplier",
         "ImposeDisplacementByLagrangeMultiplierElement::fill_in_generic_contribution_to_residuals_displ_lagr_multiplier()",
         OOMPH_EXCEPTION_LOCATION);
      }
     
     // Get prescribed wall shape
     Vector<double> r_prescribed(dim_el+1);
     if (!Sparsify)
      {
       Boundary_shape_geom_object_pt->position(zeta,r_prescribed);
      }
     else
      {
       Sub_geom_object_pt[ipt]->position(zeta,r_prescribed);       
      }

     //Premultiply the weights and the square-root of the determinant of 
     //the metric tensor
     double W = w*sqrt(adet);

     // Assemble residuals and jacobian
     
     //Loop over directions
     for(unsigned i=0;i<dim_el+1;i++)
      {     
       //Loop over the nodes
       for(unsigned j=0;j<n_node;j++)
        {          
         
         // Assemble residual for Lagrange multiplier:
        
         // Cast to a boundary node
         BoundaryNodeBase *bnod_pt = 
          dynamic_cast<BoundaryNodeBase*>(node_pt(j));

         // Local eqn number:   
         int local_eqn=nodal_local_eqn
          (j, (*bnod_pt->first_face_element_value_pt())[Id]+i); 
           
         if (local_eqn>=0)
          {
           residuals[local_eqn]+=(x[i]-r_prescribed[i])*psi(j)*W;

           // Do Jacobian too?
           if (flag==1)
            {
             // Loop over the nodes again for unknowns (only diagonal
             // contribution to direction!).
             for(unsigned jj=0;jj<n_node;jj++)
              {     
               int local_unknown=position_local_eqn(jj,0,i);
               if (local_unknown>=0)
                {
                 jacobian(local_eqn,local_unknown)+=psi(jj)*psi(j)*W;
                }
              }
            }
          }

         
         // Add Lagrange multiplier contribution to bulk equations

         // Local eqn number: Node, type, direction
         local_eqn=position_local_eqn(j,0,i);
         if (local_eqn>=0)
          {
           // Add to residual
           residuals[local_eqn]+=lambda[i]*psi(j)*W;

           // Do Jacobian too?
           if (flag==1)
            {
             // Loop over the nodes again for unknowns (only diagonal
             // contribution to direction!).
             for(unsigned jj=0;jj<n_node;jj++)
              { 
               // Cast to a boundary node
               BoundaryNodeBase *bnode_pt = 
                dynamic_cast<BoundaryNodeBase*>(node_pt(jj));

               int local_unknown=nodal_local_eqn
                (jj,(*bnode_pt->first_face_element_value_pt())[Id]+i);
               if (local_unknown>=0)
                {
                 jacobian(local_eqn,local_unknown)+=psi(jj)*psi(j)*W;
                }
              }
            }
          }

        }
      }
   
  
  } //End of loop over the integration points

  }


 /// \short The number of "blocks" that degrees of freedom in this element
 /// are sub-divided into: Just the solid degrees of freedom themselves.
 unsigned ndof_types()
  {
   return this->dim()+1;
  };
 
 /// \short Create a list of pairs for all unknowns in this element,
 /// so that the first entry in each pair contains the global equation
 /// number of the unknown, while the second one contains the number
 /// of the dof that this unknown is associated with.
 /// (Function can obviously only be called if the equation numbering
 /// scheme has been set up.) 
 void get_dof_numbers_for_unknowns(
  std::list<std::pair<unsigned long,unsigned> >& block_lookup_list)
  {
  
   // temporary pair (used to store block lookup prior to being added to list)
   std::pair<unsigned,unsigned> block_lookup;
  
   // number of nodes
   const unsigned n_node = this->nnode();

   //Loop over directions
   unsigned dim_el = this->dim();
   for(unsigned i=0;i<dim_el+1;i++)
    {     
     //Loop over the nodes
     for(unsigned j=0;j<n_node;j++)
      {          
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt = 
        dynamic_cast<BoundaryNodeBase*>(node_pt(j));
	 
       // Local eqn number:
       int local_eqn=nodal_local_eqn
        (j, (*bnod_pt->first_face_element_value_pt())[Id]+i);
       if (local_eqn>=0)
        {
         // store block lookup in temporary pair: First entry in pair
         // is global equation number; second entry is block type
         block_lookup.first = this->eqn_number(local_eqn);
         block_lookup.second = i;
        
         // add to list
         block_lookup_list.push_front(block_lookup);
        }
      }
    }
  }


private:

 /// Lagrange Id
 unsigned Id;


#ifdef PARANOID

 /// \short Bool to record the number of geom Data that has been
 /// assigned to external data (we're keeping a record to make
 /// sure we're not accidentally wiping more than we assigned). Only 
 /// included if compiled with PARANOID switched on.
 unsigned N_assigned_geom_data;

#endif

 /// \short GeomObject that specifies the prescribed 
 /// boundary displacement; GeomObject is assumed to be
 /// parametrised by the same coordinate the is used as
 /// the boundary coordinate in the bulk solid mesh to which
 /// this element is attached.
 GeomObject* Boundary_shape_geom_object_pt;
  
 /// \short Storage for sub-GeomObject at the integration points
 Vector<GeomObject*> Sub_geom_object_pt;

 /// \short Storage for local coordinates in sub-GeomObjects at integration 
 /// points
 Vector<Vector<double> > Zeta_sub_geom_object;

 /// \short Boolean flag to indicate if we're using geometric Data of
 /// sub-GeomObjects that make up the (possibly compound) GeomObject
 /// that specifies the boundary shape. Defaults to true.
 bool Sparsify;
}; 


}

#endif
