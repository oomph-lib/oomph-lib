// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2025 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for elements that are used to apply surface loads to
// the equations of elasticity

#ifndef OOMPH_SOLID_TRACTION_ELEMENTS_HEADER
#define OOMPH_SOLID_TRACTION_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


// OOMPH-LIB headers
#include "../generic/Qelements.h"
#include "../generic/hermite_elements.h"

namespace oomph
{
  //=======================================================================
  /// Namespace containing the zero traction function for solid traction
  /// elements
  //=======================================================================
  namespace SolidTractionElementHelper
  {
    //=======================================================================
    /// Default load function (zero traction)
    //=======================================================================
    void Zero_traction_fct(const Vector<double>& xi,
                           const Vector<double>& x,
                           const Vector<double>& N,
                           Vector<double>& load)
    {
      unsigned n_dim = load.size();
      for (unsigned i = 0; i < n_dim; i++)
      {
        load[i] = 0.0;
      }
    }

  } // namespace SolidTractionElementHelper


  //======================================================================
  /// A class for elements that allow the imposition of an applied traction
  /// in the principle of virtual displacements.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and and thus, we can be generic enough without the need to have
  /// a separate equations class.
  //======================================================================
  template<class ELEMENT>
  class SolidTractionElement : public virtual FaceGeometry<ELEMENT>,
                               public virtual SolidFaceElement
  {
  protected:
    /// Pointer to an imposed traction function. Arguments:
    /// Lagrangian coordinate; Eulerian coordinate; outer unit normal;
    /// applied traction. (Not all of the input arguments will be
    /// required for all specific load functions but the list should
    /// cover all cases)
    void (*Traction_fct_pt)(const Vector<double>& xi,
                            const Vector<double>& x,
                            const Vector<double>& n,
                            Vector<double>& result);


    /// Get the traction vector: Pass number of integration point
    /// (dummy), Lagr. coordinate and normal vector and return the load vector
    /// (not all of the input arguments will be
    /// required for all specific load functions but the list should
    /// cover all cases). This function is virtual so it can be
    /// overloaded for FSI.
    virtual void get_traction(const unsigned& intpt,
                              const Vector<double>& xi,
                              const Vector<double>& x,
                              const Vector<double>& n,
                              Vector<double>& traction)
    {
      Traction_fct_pt(xi, x, n, traction);
    }


    /// Helper function that actually calculates the residuals
    // This small level of indirection is required to avoid calling
    // fill_in_contribution_to_residuals in fill_in_contribution_to_jacobian
    // which causes all kinds of pain if overloading later on
    void fill_in_contribution_to_residuals_solid_traction(
      Vector<double>& residuals);


  public:
    /// Constructor, which takes a "bulk" element and the
    /// value of the index and its limit
    SolidTractionElement(FiniteElement* const& element_pt,
                         const int& face_index,
                         const bool& called_from_refineable_constructor = false)
      : FaceGeometry<ELEMENT>(), FaceElement()
    {
      // Attach the geometrical information to the element. N.B. This function
      // also assigns nbulk_value from the required_nvalue of the bulk element
      element_pt->build_face_element(face_index, this);

      // Zero traction
      Traction_fct_pt = &SolidTractionElementHelper::Zero_traction_fct;

#ifdef PARANOID
      {
        // Check that the bulk element is not a refineable 3d element
        if (!called_from_refineable_constructor)
        {
          if (element_pt->dim() == 3)
          {
            // Is it refineable
            RefineableElement* ref_el_pt =
              dynamic_cast<RefineableElement*>(element_pt);
            if (ref_el_pt != 0)
            {
              if (this->has_hanging_nodes())
              {
                throw OomphLibError(
                  "This face element will not work correctly if nodes are "
                  "hanging.\nUse the refineable version instead. ",
                  OOMPH_CURRENT_FUNCTION,
                  OOMPH_EXCEPTION_LOCATION);
              }
            }
          }
        }
      }
#endif
    }


    /// Reference to the traction function pointer
    void (*&traction_fct_pt())(const Vector<double>& xi,
                               const Vector<double>& x,
                               const Vector<double>& n,
                               Vector<double>& traction)
    {
      return Traction_fct_pt;
    }


    /// Return the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      fill_in_contribution_to_residuals_solid_traction(residuals);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the residuals
      fill_in_contribution_to_residuals_solid_traction(residuals);

      // Call the generic FD jacobian calculation
      FaceGeometry<ELEMENT>::fill_in_jacobian_from_solid_position_by_fd(
        jacobian);

      // Derivs w.r.t. to any external data (e.g. during displacement control)
      this->fill_in_jacobian_from_external_by_fd(residuals, jacobian);
    }

    /// Output function
    void output(std::ostream& outfile)
    {
      unsigned n_plot = 5;
      output(outfile, n_plot);
    }


    /// Output function
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      unsigned n_dim = this->nodal_dimension();

      Vector<double> x(n_dim);
      Vector<double> xi(n_dim);
      Vector<double> s(n_dim - 1);

      // Tecplot header info
      outfile << this->tecplot_zone_string(n_plot);

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points(n_plot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, n_plot, s);

        // Get Eulerian and Lagrangian coordinates
        this->interpolated_x(s, x);
        this->interpolated_xi(s, xi);

        // Outer unit normal
        Vector<double> unit_normal(n_dim);
        outer_unit_normal(s, unit_normal);

        // Dummy
        unsigned ipt = 0;

        // Traction vector
        Vector<double> traction(n_dim);
        get_traction(ipt, xi, x, unit_normal, traction);

        // Output the x,y,..
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << x[i] << " ";
        }

        // Output traction
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << traction[i] << " ";
        }

        // Output normal
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << unit_normal[i] << " ";
        }

        outfile << std::endl;
      }

      // Write tecplot footer (e.g. FE connectivity lists)
      this->write_tecplot_zone_footer(outfile, n_plot);
    }

    /// C_style output function
    void output(FILE* file_pt)
    {
      FiniteElement::output(file_pt);
    }

    /// C-style output function
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FiniteElement::output(file_pt, n_plot);
    }


    /// Compute traction vector at specified local coordinate
    /// Should only be used for post-processing; ignores dependence
    /// on integration point!
    void traction(const Vector<double>& s, Vector<double>& traction);
  };

  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////

  //=====================================================================
  /// Compute traction vector at specified local coordinate
  /// Should only be used for post-processing; ignores dependence
  /// on integration point!
  //=====================================================================
  template<class ELEMENT>
  void SolidTractionElement<ELEMENT>::traction(const Vector<double>& s,
                                               Vector<double>& traction)
  {
    unsigned n_dim = this->nodal_dimension();

    // Position vector
    Vector<double> x(n_dim);
    interpolated_x(s, x);


    // Lagrangian coordinate
    Vector<double> xi(n_dim);
    this->interpolated_xi(s, xi);

    // Outer unit normal
    Vector<double> unit_normal(n_dim);
    outer_unit_normal(s, unit_normal);

    // Dummy
    unsigned ipt = 0;

    // Traction vector
    get_traction(ipt, xi, x, unit_normal, traction);
  }


  //=====================================================================
  /// Return the residuals for the SolidTractionElement equations
  //=====================================================================
  template<class ELEMENT>
  void SolidTractionElement<ELEMENT>::
    fill_in_contribution_to_residuals_solid_traction(Vector<double>& residuals)
  {
    // Find out how many nodes there are
    unsigned n_node = nnode();

    // Find out how many positional dofs there are
    unsigned n_position_type = this->nnodal_position_type();

    // Find out the dimension of the node
    unsigned n_dim = this->nodal_dimension();

    // Integer to hold the local equation number
    int local_eqn = 0;

    // Set up memory for the shape functions
    // Note that in this case, the number of lagrangian coordinates is always
    // equal to the dimension of the nodes
    Shape psi(n_node, n_position_type);
    DShape dpsids(n_node, n_position_type, n_dim - 1);

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Calculate the Eulerian and Lagrangian coordinates
      Vector<double> interpolated_x(n_dim, 0.0);
      Vector<double> interpolated_xi(n_dim, 0.0);

      // Also calculate the surface Vectors (derivatives wrt local coordinates)
      DenseMatrix<double> interpolated_A(n_dim - 1, n_dim, 0.0);

      // Calculate displacements and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over positional dofs
        for (unsigned k = 0; k < n_position_type; k++)
        {
          // Loop over displacement components (deformed position)
          for (unsigned i = 0; i < n_dim; i++)
          {
            // Calculate the Eulerian and Lagrangian positions
            interpolated_x[i] +=
              nodal_position_gen(l, bulk_position_type(k), i) * psi(l, k);

            interpolated_xi[i] +=
              this->lagrangian_position_gen(l, bulk_position_type(k), i) *
              psi(l, k);

            // Loop over LOCAL derivative directions, to calculate the
            // tangent(s)
            for (unsigned j = 0; j < n_dim - 1; j++)
            {
              interpolated_A(j, i) +=
                nodal_position_gen(l, bulk_position_type(k), i) *
                dpsids(l, k, j);
            }
          }
        }
      }

      // Now find the local deformed metric tensor from the tangent Vectors
      DenseMatrix<double> A(n_dim - 1);
      for (unsigned i = 0; i < n_dim - 1; i++)
      {
        for (unsigned j = 0; j < n_dim - 1; j++)
        {
          // Initialise surface metric tensor to zero
          A(i, j) = 0.0;
          // Take the dot product
          for (unsigned k = 0; k < n_dim; k++)
          {
            A(i, j) += interpolated_A(i, k) * interpolated_A(j, k);
          }
        }
      }

      // Get the outer unit normal
      Vector<double> interpolated_normal(n_dim);
      outer_unit_normal(ipt, interpolated_normal);

      // Find the determinant of the metric tensor
      double Adet = 0.0;
      switch (n_dim)
      {
        case 2:
          Adet = A(0, 0);
          break;
        case 3:
          Adet = A(0, 0) * A(1, 1) - A(0, 1) * A(1, 0);
          break;
        default:
          throw OomphLibError(
            "Wrong dimension in SolidTractionElement",
            "SolidTractionElement::fill_in_contribution_to_residuals()",
            OOMPH_EXCEPTION_LOCATION);
      }

      // Premultiply the weights and the square-root of the determinant of
      // the metric tensor
      double W = w * sqrt(Adet);

      // Now calculate the load
      Vector<double> traction(n_dim);
      get_traction(
        ipt, interpolated_xi, interpolated_x, interpolated_normal, traction);

      //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========

      // Loop over the test functions, nodes of the element
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop of types of dofs
        for (unsigned k = 0; k < n_position_type; k++)
        {
          // Loop over the displacement components
          for (unsigned i = 0; i < n_dim; i++)
          {
            local_eqn = this->position_local_eqn(l, bulk_position_type(k), i);
            /*IF it's not a boundary condition*/
            if (local_eqn >= 0)
            {
              // Add the loading terms to the residuals
              residuals[local_eqn] -= traction[i] * psi(l, k) * W;
            }
          }
        } // End of if not boundary condition
      } // End of loop over shape functions
    } // End of loop over integration points
  }


  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////


  //======================================================================
  ///  A class for elements that allow the imposition of an applied traction
  /// in the principle of virtual displacements.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and and thus, we can be generic enough without the need to have
  /// a separate equations class.
  ///
  /// THIS IS THE REFINEABLE VERSION.
  //======================================================================
  template<class ELEMENT>
  class RefineableSolidTractionElement
    : public virtual SolidTractionElement<ELEMENT>,
      public virtual NonRefineableSolidElementWithHangingNodes
  {
  public:
    /// Constructor, which takes a "bulk" element and the face index
    RefineableSolidTractionElement(FiniteElement* const& element_pt,
                                   const int& face_index)
      : // we're calling this from the constructor of the refineable version.
        SolidTractionElement<ELEMENT>(element_pt, face_index, true)
    {
    }

    /// Destructor should not delete anything
    ~RefineableSolidTractionElement() {}

    /// Number of continuously interpolated values are the
    /// same as those in the bulk element.
    unsigned ncont_interpolated_values() const
    {
      return dynamic_cast<ELEMENT*>(this->bulk_element_pt())
        ->ncont_interpolated_values();
    }

    /// This function returns just the residuals
    inline void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic residuals function
      refineable_fill_in_contribution_to_residuals_solid_traction(residuals);
    }


    /// This function returns the residuals and the Jacobian
    inline void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                                 DenseMatrix<double>& jacobian)
    {
      // Get the residuals
      refineable_fill_in_contribution_to_residuals_solid_traction(residuals);

      // Jacobian only contains derivatives w.r.t. to positions which we
      // evaluate by finite differencing
      FaceGeometry<ELEMENT>::fill_in_jacobian_from_solid_position_by_fd(
        jacobian);

      // Derivs w.r.t. to any external data (e.g. during displacement control)
      this->fill_in_jacobian_from_external_by_fd(residuals, jacobian);
    }


  protected:
    /// This function returns the residuals for the
    /// traction function.
    void refineable_fill_in_contribution_to_residuals_solid_traction(
      Vector<double>& residuals);
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //============================================================================
  /// Function that returns the residuals for the imposed traction solid
  /// equations
  //============================================================================
  template<class ELEMENT>
  void RefineableSolidTractionElement<ELEMENT>::
    refineable_fill_in_contribution_to_residuals_solid_traction(
      Vector<double>& residuals)
  {
    // Find out how many nodes there are
    unsigned n_node = nnode();

    // Find out how many positional dofs there are
    unsigned n_position_type = this->nnodal_position_type();


#ifdef PARANOID
    if (n_position_type != 1)
    {
      throw OomphLibError(
        "RefineableSolidTractionElement only works for n_position_type=1",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
    }
#endif


    // Find out the dimension of the node
    unsigned n_dim = this->nodal_dimension();

    // Integer to hold the local equation number
    int local_eqn = 0;

    // Set up memory for the shape functions
    // Note that in this case, the number of lagrangian coordinates is always
    // equal to the dimension of the nodes
    Shape psi(n_node, n_position_type);
    DShape dpsids(n_node, n_position_type, n_dim - 1);

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Calculate the Eulerian and Lagrangian coordinates
      Vector<double> interpolated_x(n_dim, 0.0);
      Vector<double> interpolated_xi(n_dim, 0.0);

      // Also calculate the surface Vectors (derivatives wrt local coordinates)
      DenseMatrix<double> interpolated_A(n_dim - 1, n_dim, 0.0);

      // Calculate displacements and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over positional dofs
        for (unsigned k = 0; k < n_position_type; k++)
        {
          // Loop over displacement components (deformed position)
          for (unsigned i = 0; i < n_dim; i++)
          {
            // Calculate the Eulerian and Lagrangian positions
            interpolated_x[i] +=
              nodal_position_gen(l, this->bulk_position_type(k), i) * psi(l, k);

            interpolated_xi[i] +=
              this->lagrangian_position_gen(l, this->bulk_position_type(k), i) *
              psi(l, k);

            // Loop over LOCAL derivative directions, to calculate the
            // tangent(s)
            for (unsigned j = 0; j < n_dim - 1; j++)
            {
              interpolated_A(j, i) +=
                nodal_position_gen(l, this->bulk_position_type(k), i) *
                dpsids(l, k, j);
            }
          }
        }
      }

      // Now find the local deformed metric tensor from the tangent Vectors
      DenseMatrix<double> A(n_dim - 1);
      for (unsigned i = 0; i < n_dim - 1; i++)
      {
        for (unsigned j = 0; j < n_dim - 1; j++)
        {
          // Initialise surface metric tensor to zero
          A(i, j) = 0.0;
          // Take the dot product
          for (unsigned k = 0; k < n_dim; k++)
          {
            A(i, j) += interpolated_A(i, k) * interpolated_A(j, k);
          }
        }
      }

      // Get the outer unit normal
      Vector<double> interpolated_normal(n_dim);
      this->outer_unit_normal(ipt, interpolated_normal);

      // Find the determinant of the metric tensor
      double Adet = 0.0;
      switch (n_dim)
      {
        case 2:
          Adet = A(0, 0);
          break;
        case 3:
          Adet = A(0, 0) * A(1, 1) - A(0, 1) * A(1, 0);
          break;
        default:
          throw OomphLibError(
            "Wrong dimension in RefineableSolidTractionElement",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
      }

      // Premultiply the weights and the square-root of the determinant of
      // the metric tensor
      double W = w * sqrt(Adet);

      // Now calculate the load
      Vector<double> traction(n_dim);
      this->get_traction(
        ipt, interpolated_xi, interpolated_x, interpolated_normal, traction);

      // Number of master nodes and storage for the weight of the shape function
      unsigned n_master = 1;
      double hang_weight = 1.0;

      //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========

      // Loop over the test functions, nodes of the element
      for (unsigned l = 0; l < n_node; l++)
      {
        // Get pointer to local node l
        Node* local_node_pt = node_pt(l);

        // Cache hang status
        bool is_hanging = local_node_pt->is_hanging();

        // If the node is a hanging node
        if (is_hanging)
        {
          n_master = local_node_pt->hanging_pt()->nmaster();
        }
        // Otherwise the node is its own master
        else
        {
          n_master = 1;
        }


        // Storage for local equation numbers at node indexed by
        // type and direction
        DenseMatrix<int> position_local_eqn_at_node(n_position_type, n_dim);

        // Loop over the master nodes
        for (unsigned m = 0; m < n_master; m++)
        {
          if (is_hanging)
          {
            // Find the equation numbers
            position_local_eqn_at_node = local_position_hang_eqn(
              local_node_pt->hanging_pt()->master_node_pt(m));

            // Find the hanging node weight
            hang_weight = local_node_pt->hanging_pt()->master_weight(m);
          }
          else
          {
            // Loop of types of dofs
            for (unsigned k = 0; k < n_position_type; k++)
            {
              // Loop over the displacement components
              for (unsigned i = 0; i < n_dim; i++)
              {
                position_local_eqn_at_node(k, i) =
                  this->position_local_eqn(l, k, i);
              }
            }

            // Hang weight is one
            hang_weight = 1.0;
          }

          // Loop of types of dofs
          for (unsigned k = 0; k < n_position_type; k++)
          {
            // Loop over the displacement components
            for (unsigned i = 0; i < n_dim; i++)
            {
              local_eqn = position_local_eqn_at_node(k, i);

              /*IF it's not a boundary condition*/
              if (local_eqn >= 0)
              {
                /*    //Loop over the test functions, nodes of the element */
                /*    for(unsigned l=0;l<n_node;l++) */
                /*     { */
                /*      //Loop of types of dofs */
                /*      for(unsigned k=0;k<n_position_type;k++) */
                /*       { */
                /*        //Loop over the displacement components */
                /*        for(unsigned i=0;i<n_dim;i++) */
                /*         { */
                /*          local_eqn =
                 * this->position_local_eqn(l,bulk_position_type(k),i); */
                /*          /\*IF it's not a boundary condition*\/ */
                /*          if(local_eqn >= 0) */
                /*           { */


                // Add the loading terms to the residuals
                residuals[local_eqn] -=
                  traction[i] * psi(l, k) * W * hang_weight;

              } // End of if not boundary condition
            }
          }
        }
      }
    } // End of loop over integration points
  }


  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////


  //=========================================================================
  /// SolidTractionElement "upgraded" to a FSIWallElement (and thus,
  /// by inheritance, a GeomObject), so it can be used in FSI.
  /// The element is templated by the bulk solid element and
  /// the spatial (Eulerian) dimension of the bulk element.
  //=========================================================================
  template<class ELEMENT, unsigned DIM>
  class FSISolidTractionElement : public virtual SolidTractionElement<ELEMENT>,
                                  public virtual FSIWallElement
  {
  private:
    /// Boolean flag to indicate whether the normal is directed into the fluid
    bool Normal_points_into_fluid;

  public:
    /// Constructor: Create element as FSIWallElement (and thus,
    /// by inheritance, a GeomObject) with DIM-1 Lagrangian and DIM
    /// Eulerian coordinates. By default, we assume that the
    /// normal vector computed by the underlying FaceElement
    /// points into the fluid. If this is not the case, overwrite this
    /// with the access function
    /// FSISolidTractionElement::set_normal_pointing_out_of_fluid()
    /// Constructor for GeomObject is called explicitly because
    /// of virtual inheritance!
    FSISolidTractionElement(
      FiniteElement* const& element_pt,
      const int& face_index,
      const bool& called_from_refineable_constructor = false)
      : SolidTractionElement<ELEMENT>(
          element_pt, face_index, called_from_refineable_constructor),
        Normal_points_into_fluid(true)
    {
      unsigned n_lagr = DIM - 1;
      unsigned n_dim = DIM;
      setup_fsi_wall_element(n_lagr, n_dim);
    }

    /// Destructor: empty
    ~FSISolidTractionElement() {}


    /// Set the normal computed by underlying FaceElement
    /// to point into the fluid
    void set_normal_pointing_into_fluid()
    {
      Normal_points_into_fluid = true;
    }

    /// Set the normal computed by underlying FaceElement
    /// to point out of the fluid
    void set_normal_pointing_out_of_fluid()
    {
      Normal_points_into_fluid = false;
    }

    /// Derivative of position vector w.r.t. the SolidFiniteElement's
    /// Lagrangian coordinates; evaluated at current time.
    void dposition_dlagrangian_at_local_coordinate(
      const Vector<double>& s, DenseMatrix<double>& drdxi) const
    {
      throw OomphLibError("Broken -- who calls this? \n",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }


    /// Final overload... Forwards to the version in the FSIWallElement
    virtual void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                                  DenseMatrix<double>& jacobian)
    {
      // Call the underlying element's jacobian function
      SolidTractionElement<ELEMENT>::fill_in_contribution_to_jacobian(residuals,
                                                                      jacobian);
      // Add the contribution of the external load data by finite differences
      this->fill_in_jacobian_from_external_interaction_by_fd(jacobian);
    }


    /// Get the load vector: Pass number of the integration point,
    /// Lagr. coordinate, Eulerian coordinate (neither of the last two
    /// are used in the FSI implementation of this function!) and normal vector
    /// and return the load vector, taking
    /// the sign of the normal into account.
    virtual void get_traction(const unsigned& intpt,
                              const Vector<double>& xi,
                              const Vector<double>& x,
                              const Vector<double>& n,
                              Vector<double>& traction)
    {
      // Get the fluid load on the wall stress scale, i.e. this
      // includes the ratio of stresses represented by Q.
      fluid_load_vector(intpt, n, traction);

      // If the normal is outer to the fluid switch the direction
      if (!Normal_points_into_fluid)
      {
        for (unsigned i = 0; i < DIM; i++)
        {
          traction[i] *= -1.0;
        }
      }

    } // end of get_traction


    /// Output function: Note we can only output the traction
    /// at Gauss points so n_plot is actually ignored.
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      // Tecplot header info
      outfile << "ZONE" << std::endl;

      // Find the number of Gauss points of the element
      unsigned n_intpt = this->integral_pt()->nweight();

      // Find the dimension of the element (i.e. its number of local
      // coordinates)
      unsigned el_dim = this->dim();

      // Set storage for the local coordinates of the Gauss points
      // in the solid
      Vector<double> s(el_dim);

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Loop over the dimension of the solid element and find the local
        // coordinates of the Gauss points, then the global
        for (unsigned i = 0; i < el_dim; i++)
        {
          s[i] = integral_pt()->knot(ipt, i);
        }

        // Eulerian position of Gauss point
        Vector<double> r(DIM);
        interpolated_x(s, r);

        // Outer unit normal
        Vector<double> unit_normal(DIM);
        this->outer_unit_normal(s, unit_normal);

        // Compute traction with dummy arguments for xi
        Vector<double> xi(el_dim, 0.0);
        Vector<double> traction(DIM);
        // Don't get the traction if you are a halo element because
        // the external elements will not have been set up
#ifdef OOMPH_HAS_MPI
        if (!this->is_halo())
#endif
        {
          get_traction(ipt, xi, r, unit_normal, traction);
        }


        for (unsigned i = 0; i < DIM; i++)
        {
          outfile << r[i] << " ";
        }
        for (unsigned i = 0; i < DIM; i++)
        {
          outfile << traction[i] << " ";
        }
        for (unsigned i = 0; i < DIM; i++)
        {
          outfile << unit_normal[i] << " ";
        }
        outfile << std::endl;
      }
    }

    /// Broken overloaded reference to the traction function pointer.
    /// It doesn't make sense to specify an external
    /// traction.
    virtual void (*&traction_fct_pt())(const Vector<double>& xi,
                                       const Vector<double>& x,
                                       const Vector<double>& n,
                                       Vector<double>& traction)
    {
      throw OomphLibError("It doesn't make sense to specify an external "
                          "traction in an FSI context",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);

      // Dummy return to shut up the compiler
      return this->Traction_fct_pt;
    }

    /// The number of "DOF types" that degrees of freedom in this element
    /// are sub-divided into: Just the solid degrees of freedom themselves.
    unsigned ndof_types() const
    {
      return 1;
    }

    /// Create a list of pairs for all unknowns in this element,
    /// so that the first entry in each pair contains the global equation
    /// number of the unknown, while the second one contains the number
    /// of the "DOF types" that this unknown is associated with.
    /// (Function can obviously only be called if the equation numbering
    /// scheme has been set up.)
    void get_dof_numbers_for_unknowns(
      std::list<std::pair<unsigned long, unsigned>>& dof_lookup_list) const;
  };


  //=============================================================================
  /// Create a list of pairs for all unknowns in this element,
  /// so that the first entry in each pair contains the global equation
  /// number of the unknown, while the second one contains the number
  /// of the "DOF types" that this unknown is associated with.
  /// (Function can obviously only be called if the equation numbering
  /// scheme has been set up.) This element is only in charge of the solid dofs.
  //=============================================================================
  template<class ELEMENT, unsigned DIM>
  void FSISolidTractionElement<ELEMENT, DIM>::get_dof_numbers_for_unknowns(
    std::list<std::pair<unsigned long, unsigned>>& dof_lookup_list) const
  {
    // temporary pair (used to store dof lookup prior to being added to list)
    std::pair<unsigned, unsigned> dof_lookup;

    // number of nodes
    const unsigned n_node = this->nnode();

    // Get the number of position dofs and dimensions at the node
    const unsigned n_position_type = nnodal_position_type();
    const unsigned nodal_dim = nodal_dimension();

    // Integer storage for local unknown
    int local_unknown = 0;

    // Loop over the nodes
    for (unsigned n = 0; n < n_node; n++)
    {
      // Loop over position dofs
      for (unsigned k = 0; k < n_position_type; k++)
      {
        // Loop over dimension
        for (unsigned i = 0; i < nodal_dim; i++)
        {
          // If the variable is free
          local_unknown = position_local_eqn(n, k, i);

          // ignore pinned values
          if (local_unknown >= 0)
          {
            // store dof lookup in temporary pair: First entry in pair
            // is global equation number; second entry is dof type
            dof_lookup.first = this->eqn_number(local_unknown);
            dof_lookup.second = 0;

            // add to list
            dof_lookup_list.push_front(dof_lookup);
          }
        }
      }
    }
  }


  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////
  /// //////////////////////////////////////////////////////////////////////


  //=========================================================================
  /// RefineableSolidTractionElement "upgraded" to a FSIWallElement (and thus,
  /// by inheritance, a GeomObject), so it can be used in FSI.
  /// The element is templated by the bulk solid element and
  /// the spatial (Eulerian) dimension of the bulk element.
  //=========================================================================
  template<class ELEMENT, unsigned DIM>
  class RefineableFSISolidTractionElement
    : public virtual RefineableSolidTractionElement<ELEMENT>,
      public virtual FSISolidTractionElement<ELEMENT, DIM>,
      public virtual FSIWallElement
  {
  public:
    /// Constructor: Create element as FSIWallElement (and thus,
    /// by inheritance, a GeomObject) with DIM-1 Lagrangian and DIM
    /// Eulerian coordinates. By default, we assume that the
    /// normal vector computed by the underlying FaceElement
    /// points into the fluid. If this is not the case, overwrite this
    /// with the access function
    /// FSISolidTractionElement::set_normal_pointing_out_of_fluid()
    /// Constructor for GeomObject is called explicitly because
    /// of virtual inheritance!
    RefineableFSISolidTractionElement(FiniteElement* const& element_pt,
                                      const int& face_index)
      : SolidTractionElement<ELEMENT>(element_pt, face_index, true),
        RefineableSolidTractionElement<ELEMENT>(element_pt, face_index),
        FSISolidTractionElement<ELEMENT, DIM>(element_pt, face_index, true)
    {
    }

    /// Destructor: empty
    ~RefineableFSISolidTractionElement() {}


    /// Final overload. Get contributions from refineable solid
    /// traction element and derivatives from external data
    virtual void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                                  DenseMatrix<double>& jacobian)
    {
      // Call the underlying element's jacobian function
      RefineableSolidTractionElement<ELEMENT>::fill_in_contribution_to_jacobian(
        residuals, jacobian);
      // Add the contribution of the external load data by finite differences
      this->fill_in_jacobian_from_external_interaction_by_fd(jacobian);
    }
  };


  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////


  //======================================================================
  /// A class for elements that allow the imposition of a displacement
  /// constraint for "bulk" solid elements via a Lagrange multiplier.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and and thus, we can be generic enough without the need to have
  /// a separate equations class.
  /// \b NOTE: Currently (and for the foreseeable future) this
  /// element only works with bulk elements that do not have
  /// generalised degrees of freedom (so it won't work with
  /// Hermite-type elements, say). The additional functionality
  /// to deal with such elements could easily be added (once a
  /// a suitable test case is written). For now we simply throw
  /// errors if an attempt is made to use the element with an unsuitable
  /// bulk element.
  //======================================================================
  template<class ELEMENT>
  class ImposeDisplacementByLagrangeMultiplierElement
    : public virtual FaceGeometry<ELEMENT>,
      public virtual SolidFaceElement
  {
  public:
    /// Constructor takes a "bulk" element and the
    /// index that identifies which face the FaceElement is supposed
    /// to be attached to. The optional identifier can be used
    /// to distinguish the additional nodal values created by
    /// this element from thos created by other FaceElements.
    ImposeDisplacementByLagrangeMultiplierElement(
      FiniteElement* const& element_pt,
      const int& face_index,
      const unsigned& id = 0,
      const bool& called_from_refineable_constructor = false)
      : FaceGeometry<ELEMENT>(), FaceElement(), Boundary_shape_geom_object_pt(0)
    {
      //  Store the ID of the FaceElement -- this is used to distinguish
      // it from any others
      Id = id;

      // By default sparsify, i.e. check if the GeomObject that
      // defines the boundary contains sub-GeomObjects. If so,
      // only use their GeomData as the external Data that affects
      // this element's residuals.
      Sparsify = true;

      // Build the face element
      element_pt->build_face_element(face_index, this);

#ifdef PARANOID
      {
        // Initialise number of assigned geom Data.
        N_assigned_geom_data = 0;

        // Check that the bulk element is not a refineable 3d element
        if (!called_from_refineable_constructor)
        {
          if (element_pt->dim() == 3)
          {
            // Is it refineable
            RefineableElement* ref_el_pt =
              dynamic_cast<RefineableElement*>(element_pt);
            if (ref_el_pt != 0)
            {
              if (this->has_hanging_nodes())
              {
                throw OomphLibError(
                  "This face element will not work correctly if nodes are "
                  "hanging\nUse the refineable version instead. ",
                  OOMPH_CURRENT_FUNCTION,
                  OOMPH_EXCEPTION_LOCATION);
              }
            }
          }
        }
      }

      {
        // Check that the bulk element does not require generalised positional
        // degrees of freedom
        if (element_pt->nnodal_position_type() != 1)
        {
          throw OomphLibError(
            "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) "
            "be used with elements that have generalised positional dofs",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
        }
      }
#endif

      // Dimension of the bulk element
      unsigned dim = element_pt->dim();

      // We need dim additional values for each FaceElement node
      // to store the dim Lagrange multipliers.
      Vector<unsigned> n_additional_values(nnode(), dim);

      // Now add storage for Lagrange multipliers and set the map containing
      // the position of the first entry of this face element's
      // additional values.
      add_additional_values(n_additional_values, id);
    }


    /// Access to GeomObject that specifies the prescribed
    /// boundary displacement; GeomObject is assumed to be
    /// parametrised by the same coordinate that is used as
    /// the boundary coordinate in the bulk solid mesh to which
    /// this element is attached.
    GeomObject* boundary_shape_geom_object_pt() const
    {
      return Boundary_shape_geom_object_pt;
    }


    /// Set GeomObject that specifies the prescribed
    /// boundary displacement; GeomObject is assumed to be
    /// parametrised by the same coordinate that is used as
    /// the boundary coordinate in the bulk solid mesh to which
    /// this element is attached. GeomData of GeomObject
    /// is added to this element's external Data. Also specify
    /// the boundary number in the bulk mesh to which this element is
    /// attached.
    void set_boundary_shape_geom_object_pt(
      GeomObject* boundary_shape_geom_object_pt,
      const unsigned& boundary_number_in_bulk_mesh)
    {
      // Record boundary number
#ifdef PARANOID
      Boundary_number_in_bulk_mesh_has_been_set = true;
#endif
      Boundary_number_in_bulk_mesh = boundary_number_in_bulk_mesh;


      // Store (possibly compound) GeomObject that specifies the
      // the desired  boundary shape.
      Boundary_shape_geom_object_pt = boundary_shape_geom_object_pt;


      // Don't sparsify: Use all the geometric Data associated with
      // the (possibly compound) GeomObject that specifies the
      // boundary shape as external data for this element.
      if (!Sparsify)
      {
        unsigned n_geom_data = boundary_shape_geom_object_pt->ngeom_data();

#ifdef PARANOID
        if ((this->nexternal_data() > 0) &&
            (N_assigned_geom_data != this->nexternal_data()))
        {
          std::ostringstream error_message;
          error_message << "About to wipe external data for "
                        << "ImposeDisplacementByLagrangeMultiplierElement.\n"
                        << "I noted that N_assigned_geom_data = "
                        << N_assigned_geom_data
                        << " != nexternal_data() = " << this->nexternal_data()
                        << " \n"
                        << "so we're going to wipe some external data that\n"
                        << "is not geometric Data of the GeomObject that\n"
                        << "specifies the desired boundary shape.\n"
                        << std::endl;
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif
        this->flush_external_data();
        for (unsigned i = 0; i < n_geom_data; i++)
        {
          add_external_data(boundary_shape_geom_object_pt->geom_data_pt(i));
        }
#ifdef PARANOID
        N_assigned_geom_data = n_geom_data;
#endif
      }
      // Sparsify: Use locate_zeta to determine the sub-GeomObjects that
      // make up  the (possibly compound) GeomObject that specifies the
      // boundary shape. Use their geometric Data as external data for
      // this element.
      else
      {
        // Find out how many nodes there are
        unsigned n_node = nnode();

        // Get the number of position dofs and dimensions at the node
        const unsigned n_position_type = nnodal_position_type();

        // Dimension of element
        unsigned dim_el = dim();

        // Set up memory for the shape functions
        Shape psi(n_node);


#ifdef PARANOID
        if ((this->nexternal_data() > 0) &&
            (N_assigned_geom_data != this->nexternal_data()))
        {
          std::ostringstream error_message;
          error_message << "About to wipe external data for "
                        << "ImposeDisplacementByLagrangeMultiplierElement.\n"
                        << "I noted that N_assigned_geom_data = "
                        << N_assigned_geom_data
                        << " != nexternal_data() = " << this->nexternal_data()
                        << " \n"
                        << "so we're going to wipe some external data that\n"
                        << "is not geometric Data of the GeomObject that\n"
                        << "specifies the desired boundary shape.\n"
                        << std::endl;
          throw OomphLibError(error_message.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Flush the data
        this->flush_external_data();

#ifdef PARANOID
        N_assigned_geom_data = 0;
#endif

        // Prepare local storage
        unsigned n_intpt = integral_pt()->nweight();
        Sub_geom_object_pt.resize(n_intpt);
        Zeta_sub_geom_object.resize(n_intpt);

        // Loop over the integration points
        for (unsigned ipt = 0; ipt < n_intpt; ipt++)
        {
          // Get shape function
          shape_at_knot(ipt, psi);

          // Calculate the intrinsic coordinates
          Vector<double> zeta(dim_el, 0.0);
          Vector<double> s(dim_el);

          // Loop over nodes
          for (unsigned j = 0; j < n_node; j++)
          {
            for (unsigned k = 0; k < n_position_type; k++)
            {
              // Assemble the intrinsic coordinate
              for (unsigned i = 0; i < dim_el; i++)
              {
                zeta[i] += zeta_nodal(j, k, i) * psi(j, k);
              }
            }
          }

          // Find sub-GeomObject and local coordinate within it
          // at integration point
          Zeta_sub_geom_object[ipt].resize(dim_el);
          Boundary_shape_geom_object_pt->locate_zeta(
            zeta, Sub_geom_object_pt[ipt], Zeta_sub_geom_object[ipt]);

          unsigned n_geom_data = Sub_geom_object_pt[ipt]->ngeom_data();
          for (unsigned i = 0; i < n_geom_data; i++)
          {
            add_external_data(Sub_geom_object_pt[ipt]->geom_data_pt(i));
          }
#ifdef PARANOID
          N_assigned_geom_data += n_geom_data;
#endif
        }
      }
    }

    /// Fill in the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic routine with the flag set to 0
      fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
        residuals, jacobian, 1);

      // Fill in the derivatives w.r.t. external data by FD, re-using
      // the pre-computed residual vector
      fill_in_jacobian_from_external_by_fd(residuals, jacobian);
    }


    /// Fill in contribution to Mass matrix and
    /// Jacobian. There is no contributiont to mass matrix
    /// so simply call the fill_in_contribution_to_jacobian term
    /// Note that the Jacobian is multiplied by minus one to
    /// ensure that the mass matrix is positive semi-definite.
    void fill_in_contribution_to_jacobian_and_mass_matrix(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix)
    {
      // Just call the jacobian calculation
      fill_in_contribution_to_jacobian(residuals, jacobian);

      // Multiply the residuals and jacobian by minus one
      const unsigned n_dof = this->ndof();
      for (unsigned i = 0; i < n_dof; i++)
      {
        residuals[i] *= -1.0;
        for (unsigned j = 0; j < n_dof; j++)
        {
          jacobian(i, j) *= -1.0;
        }
      }
    }


    /// Output function
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      // Elemental dimension
      unsigned dim_el = dim();

      // Find the number of positional types
      unsigned n_position_type = this->nnodal_position_type();

#ifdef PARANOID
      if (n_position_type != 1)
      {
        throw OomphLibError(
          "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) be "
          "used with elements that have generalised positional dofs",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif


      // Local coord
      Vector<double> s(dim_el);

      // # of nodes,
      unsigned n_node = nnode();
      Shape psi(n_node, n_position_type);

      // Tecplot header info
      outfile << this->tecplot_zone_string(n_plot);

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points(n_plot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, n_plot, s);

        // Get shape function
        shape(s, psi);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        for (unsigned j = 0; j < n_node; j++)
        {
          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // get the node pt
          Node* nod_pt = node_pt(j);

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(Id);

          // higher dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += nodal_position(j, i) * psi(j, 0); // need to sort
                                                      // this out properly
                                                      // for generalised dofs
            lambda[i] += nod_pt->value(first_index + i) * psi(j, 0);
          }
          // In-element quantities
          for (unsigned i = 0; i < dim_el; i++)
          {
            // Loop over positional types
            for (unsigned k = 0; k < n_position_type; k++)
            {
              zeta[i] += zeta_nodal(j, k, i) * psi(j, k);
            }
          }
        }

        // Get prescribed wall shape
        Vector<double> r_prescribed(dim_el + 1);
        Boundary_shape_geom_object_pt->position(zeta, r_prescribed);

        // Output stuff
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          outfile << x[i] << " ";
        }
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          outfile << -lambda[i] << " ";
        }
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          outfile << r_prescribed[i] << " ";
        }
        /*     for(unsigned i=0;i<dim_el;i++) */
        /*       { */
        /*        outfile << zeta[i] << " "; */
        /*       } */
        outfile << std::endl;
      }
    }


    /// Output function
    void output(std::ostream& outfile)
    {
      unsigned n_plot = 5;
      output(outfile, n_plot);
    }


    /// Compute square of L2 norm of error between
    /// prescribed and actual displacement
    double square_of_l2_norm_of_error()
    {
      // Find out how many positional dofs there are
      unsigned n_position_type = this->nnodal_position_type();

#ifdef PARANOID
      if (n_position_type != 1)
      {
        throw OomphLibError(
          "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) be "
          "used with elements that have generalised positional dofs",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Find out how many nodes there are
      unsigned n_node = nnode();

      // Dimension of element
      unsigned dim_el = dim();

      // Set up memory for the shape functions
      Shape psi(n_node);
      DShape dpsids(n_node, dim_el);

      // Set the value of n_intpt
      unsigned n_intpt = integral_pt()->nweight();


      // Initialise error
      double squared_error = 0.0;

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Get the integral weight
        double w = integral_pt()->weight(ipt);

        // Only need to call the local derivatives
        dshape_local_at_knot(ipt, psi, dpsids);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        DenseMatrix<double> interpolated_a(dim_el, dim_el + 1, 0.0);

        // Loop over nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          Node* nod_pt = node_pt(j);

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(Id);

          // Assemble higher-dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += nodal_position(j, i) * psi(j);
            lambda[i] += nod_pt->value(first_index + i) * psi(j);
            for (unsigned ii = 0; ii < dim_el; ii++)
            {
              interpolated_a(ii, i) +=
                lagrangian_position(j, i) * dpsids(j, ii);
            }
          }
          if (!Sparsify)
          {
            for (unsigned k = 0; k < n_position_type; k++)
            {
              // Assemble in-element quantities: boundary coordinate
              for (unsigned i = 0; i < dim_el; i++)
              {
                zeta[i] += zeta_nodal(j, k, i) * psi(j, k);
              }
            }
          }
        }

        if (Sparsify) zeta = Zeta_sub_geom_object[ipt];


        // Now find the local undeformed metric tensor from the tangent Vectors
        DenseMatrix<double> a(dim_el);
        for (unsigned i = 0; i < dim_el; i++)
        {
          for (unsigned j = 0; j < dim_el; j++)
          {
            // Initialise surface metric tensor to zero
            a(i, j) = 0.0;
            // Take the dot product
            for (unsigned k = 0; k < dim_el + 1; k++)
            {
              a(i, j) += interpolated_a(i, k) * interpolated_a(j, k);
            }
          }
        }


        // Find the determinant of the metric tensor
        double adet = 0.0;
        switch (dim_el + 1)
        {
          case 2:
            adet = a(0, 0);
            break;

          case 3:
            adet = a(0, 0) * a(1, 1) - a(0, 1) * a(1, 0);
            break;

          default:
            throw OomphLibError(
              "Wrong dimension "
              "fill_in_generic_contribution_to_residuals_displ_lagr_multiplier",
              "ImposeDisplacementByLagrangeMultiplierElement::fill_in_generic_"
              "contribution_to_residuals_displ_lagr_multiplier()",
              OOMPH_EXCEPTION_LOCATION);
        }

        // Get prescribed wall shape
        Vector<double> r_prescribed(dim_el + 1);
        if (!Sparsify)
        {
          Boundary_shape_geom_object_pt->position(zeta, r_prescribed);
        }
        else
        {
          Sub_geom_object_pt[ipt]->position(zeta, r_prescribed);
        }

        // Premultiply the weights and the square-root of the determinant of
        // the metric tensor
        double W = w * sqrt(adet);

        // Assemble error

        // Loop over directions
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          squared_error +=
            (x[i] - r_prescribed[i]) * (x[i] - r_prescribed[i]) * W;
        }
      } // End of loop over the integration points

      return squared_error;
    }


  protected:
    /// Helper function to compute the residuals and, if flag==1, the
    /// Jacobian
    void fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag)
    {
      // Find out how many positional dofs there are
      unsigned n_position_type = this->nnodal_position_type();

#ifdef PARANOID
      if (n_position_type != 1)
      {
        throw OomphLibError(
          "ImposeDisplacementByLagrangeMultiplierElement cannot (currently) be "
          "used with elements that have generalised positional dofs",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Find out how many nodes there are
      unsigned n_node = nnode();

      // Dimension of element
      unsigned dim_el = dim();

      // Set up memory for the shape functions
      Shape psi(n_node);
      DShape dpsids(n_node, dim_el);

      // Set the value of n_intpt
      unsigned n_intpt = integral_pt()->nweight();

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Get the integral weight
        double w = integral_pt()->weight(ipt);

        // Only need to call the local derivatives
        dshape_local_at_knot(ipt, psi, dpsids);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        DenseMatrix<double> interpolated_a(dim_el, dim_el + 1, 0.0);

        // Loop over nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          Node* nod_pt = node_pt(j);

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(Id);

          // Assemble higher-dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += nodal_position(j, i) * psi(j);
            lambda[i] += nod_pt->value(first_index + i) * psi(j);
            for (unsigned ii = 0; ii < dim_el; ii++)
            {
              interpolated_a(ii, i) +=
                lagrangian_position(j, i) * dpsids(j, ii);
            }
          }
          if (!Sparsify)
          {
            for (unsigned k = 0; k < n_position_type; k++)
            {
              // Assemble in-element quantities: boundary coordinate
              for (unsigned i = 0; i < dim_el; i++)
              {
                zeta[i] += zeta_nodal(j, k, i) * psi(j, k);
              }
            }
          }
        }

        if (Sparsify) zeta = Zeta_sub_geom_object[ipt];


        // Now find the local undeformed metric tensor from the tangent Vectors
        DenseMatrix<double> a(dim_el);
        for (unsigned i = 0; i < dim_el; i++)
        {
          for (unsigned j = 0; j < dim_el; j++)
          {
            // Initialise surface metric tensor to zero
            a(i, j) = 0.0;
            // Take the dot product
            for (unsigned k = 0; k < dim_el + 1; k++)
            {
              a(i, j) += interpolated_a(i, k) * interpolated_a(j, k);
            }
          }
        }


        // Find the determinant of the metric tensor
        double adet = 0.0;
        switch (dim_el + 1)
        {
          case 2:
            adet = a(0, 0);
            break;

          case 3:
            adet = a(0, 0) * a(1, 1) - a(0, 1) * a(1, 0);
            break;

          default:
            throw OomphLibError(
              "Wrong dimension "
              "fill_in_generic_contribution_to_residuals_displ_lagr_multiplier",
              "ImposeDisplacementByLagrangeMultiplierElement::fill_in_generic_"
              "contribution_to_residuals_displ_lagr_multiplier()",
              OOMPH_EXCEPTION_LOCATION);
        }

        // Get prescribed wall shape
        Vector<double> r_prescribed(dim_el + 1);
        if (!Sparsify)
        {
          Boundary_shape_geom_object_pt->position(zeta, r_prescribed);
        }
        else
        {
          Sub_geom_object_pt[ipt]->position(zeta, r_prescribed);
        }

        // Premultiply the weights and the square-root of the determinant of
        // the metric tensor
        double W = w * sqrt(adet);

        // Assemble residuals and jacobian

        // Loop over directions
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          // Loop over the nodes
          for (unsigned j = 0; j < n_node; j++)
          {
            // Assemble residual for Lagrange multiplier:

            // Cast to a boundary node
            BoundaryNodeBase* bnod_pt =
              dynamic_cast<BoundaryNodeBase*>(node_pt(j));

            // Local eqn number:
            int local_eqn = nodal_local_eqn(
              j,
              bnod_pt->index_of_first_value_assigned_by_face_element(Id) + i);


            if (local_eqn >= 0)
            {
              residuals[local_eqn] += (x[i] - r_prescribed[i]) * psi(j) * W;

              // Do Jacobian too?
              if (flag == 1)
              {
                // Loop over the nodes again for unknowns (only diagonal
                // contribution to direction!).
                for (unsigned jj = 0; jj < n_node; jj++)
                {
                  int local_unknown = position_local_eqn(jj, 0, i);
                  if (local_unknown >= 0)
                  {
                    jacobian(local_eqn, local_unknown) += psi(jj) * psi(j) * W;
                  }
                }
              }
            }


            // Add Lagrange multiplier contribution to bulk equations

            // Local eqn number: Node, type, direction
            local_eqn = position_local_eqn(j, 0, i);
            if (local_eqn >= 0)
            {
              // Add to residual
              residuals[local_eqn] += lambda[i] * psi(j) * W;

              // Do Jacobian too?
              if (flag == 1)
              {
                // Loop over the nodes again for unknowns (only diagonal
                // contribution to direction!).
                for (unsigned jj = 0; jj < n_node; jj++)
                {
                  // Cast to a boundary node
                  BoundaryNodeBase* bnode_pt =
                    dynamic_cast<BoundaryNodeBase*>(node_pt(jj));

                  int local_unknown = nodal_local_eqn(
                    jj,
                    bnode_pt->index_of_first_value_assigned_by_face_element(
                      Id) +
                      i);
                  if (local_unknown >= 0)
                  {
                    jacobian(local_eqn, local_unknown) += psi(jj) * psi(j) * W;
                  }
                }
              }
            }
          }
        }


      } // End of loop over the integration points
    }


    /// The number of "DOF types" that degrees of freedom in this element
    /// are sub-divided into: We only label the
    /// Lagrange multiplier degrees of freedom (one for each spatial dimension)
    unsigned ndof_types() const
    {
      return this->dim() + 1;
    }


    /// Create a list of pairs for all unknowns in this element,
    /// so that the first entry in each pair contains the global equation
    /// number of the unknown, while the second one contains the number
    /// of the dof that this unknown is associated with.
    /// (Function can obviously only be called if the equation numbering
    /// scheme has been set up.)
    void get_dof_numbers_for_unknowns(
      std::list<std::pair<unsigned long, unsigned>>& dof_lookup_list) const
    {
      // temporary pair (used to store dof lookup prior to being added to list)
      std::pair<unsigned, unsigned> dof_lookup;

      // number of nodes
      const unsigned n_node = this->nnode();

      // Loop over directions
      unsigned dim_el = this->dim();
      for (unsigned i = 0; i < dim_el + 1; i++)
      {
        // Loop over the nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // Local eqn number:
          int local_eqn = nodal_local_eqn(
            j, bnod_pt->index_of_first_value_assigned_by_face_element(Id) + i);
          if (local_eqn >= 0)
          {
            // store dof lookup in temporary pair: First entry in pair
            // is global equation number; second entry is dof type
            dof_lookup.first = this->eqn_number(local_eqn);
            dof_lookup.second = i;

            // add to list
            dof_lookup_list.push_front(dof_lookup);
          }
        }
      }
    }


    /// Lagrange Id
    unsigned Id;


#ifdef PARANOID

    /// Bool to record the number of geom Data that has been
    /// assigned to external data (we're keeping a record to make
    /// sure we're not accidentally wiping more than we assigned). Only
    /// included if compiled with PARANOID switched on.
    unsigned N_assigned_geom_data;

#endif

    /// GeomObject that specifies the prescribed
    /// boundary displacement; GeomObject is assumed to be
    /// parametrised by the same coordinate the is used as
    /// the boundary coordinate in the bulk solid mesh to which
    /// this element is attached.
    GeomObject* Boundary_shape_geom_object_pt;

    /// Storage for sub-GeomObject at the integration points
    Vector<GeomObject*> Sub_geom_object_pt;

    /// Storage for local coordinates in sub-GeomObjects at integration
    /// points
    Vector<Vector<double>> Zeta_sub_geom_object;

    /// Boolean flag to indicate if we're using geometric Data of
    /// sub-GeomObjects that make up the (possibly compound) GeomObject
    /// that specifies the boundary shape. Defaults to true.
    bool Sparsify;
  };


  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////


  //======================================================================
  /// A class for elements that allow the imposition of a displacement
  /// constraint for "bulk" solid elements via a Lagrange multiplier.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and and thus, we can be generic enough without the need to have
  /// a separate equations class.
  /// \b NOTE: Currently (and for the foreseeable future) this
  /// element only works with bulk elements that do not have
  /// generalised degrees of freedom (so it won't work with
  /// Hermite-type elements, say). The additional functionality
  /// to deal with such elements could easily be added (once a
  /// a suitable test case is written). For now we simply throw
  /// errors if an attempt is made to use the element with an unsuitable
  /// bulk element.
  ///
  /// REFINEABLE VERSION
  //======================================================================
  template<class ELEMENT>
  class RefineableImposeDisplacementByLagrangeMultiplierElement
    : public virtual ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>,
      public virtual NonRefineableSolidElementWithHangingNodes

  {
  public:
    /// Constructor takes a "bulk" element and the
    /// index that identifies which face the FaceElement is supposed
    /// to be attached to. The optional identifier can be used
    /// to distinguish the additional nodal values created by
    /// this element from thos created by other FaceElements.
    RefineableImposeDisplacementByLagrangeMultiplierElement(
      FiniteElement* const& element_pt,
      const int& face_index,
      const unsigned& id = 0)
      : ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>(
          element_pt, face_index, id, true)
    {
    }


    /// Number of continuously interpolated values: Same for
    /// all nodes since it's a refineable element
    unsigned ncont_interpolated_values() const
    {
      return node_pt(0)->nvalue();
    }

    /// Fill in the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic routine with the flag set to 0
      refineable_fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      refineable_fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
        residuals, jacobian, 1);

      // Fill in the derivatives w.r.t. external data by FD, re-using
      // the pre-computed residual vector
      this->fill_in_jacobian_from_external_by_fd(residuals, jacobian);
    }


  protected:
    /// Helper function to compute the residuals and, if flag==1, the
    /// Jacobian
    void refineable_fill_in_generic_contribution_to_residuals_displ_lagr_multiplier(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag)
    {
      // Find out how many positional dofs there are
      unsigned n_position_type = this->nnodal_position_type();

#ifdef PARANOID
      if (n_position_type != 1)
      {
        throw OomphLibError(
          "RefineableImposeDisplacementByLagrangeMultiplierElement \n cannot "
          "(currently) be used with elements that have generalised\n "
          "positional dofs. Upgrade should be straightforward though the code "
          "is in a \n bit of state, with generalised degrees of freedom "
          "sometimes half taken into \n account, sometimes completely "
          "ignored...",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Find out how many nodes there are
      unsigned n_node = this->nnode();

      // Dimension of element
      unsigned dim_el = this->dim();

      // Set up memory for the shape functions
      Shape psi(n_node);
      DShape dpsids(n_node, dim_el);

      // Set the value of n_intpt
      unsigned n_intpt = this->integral_pt()->nweight();


      // Integers to store local equation number
      int local_eqn = 0;
      int local_unknown = 0;

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Get the integral weight
        double w = this->integral_pt()->weight(ipt);

        // Only need to call the local derivatives
        this->dshape_local_at_knot(ipt, psi, dpsids);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        DenseMatrix<double> interpolated_a(dim_el, dim_el + 1, 0.0);

        // Loop over nodes -- note in these calculations hang-ness is
        // automatically taken into account because of calls to position(...)
        // etc
        for (unsigned j = 0; j < n_node; j++)
        {
          Node* nod_pt = this->node_pt(j);

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt = dynamic_cast<BoundaryNodeBase*>(nod_pt);

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(this->Id);

          // Assemble higher-dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += this->nodal_position(j, i) * psi(j);
            lambda[i] += nod_pt->value(first_index + i) * psi(j);
            for (unsigned ii = 0; ii < dim_el; ii++)
            {
              interpolated_a(ii, i) +=
                this->lagrangian_position(j, i) * dpsids(j, ii);
            }
          }
          if (!this->Sparsify)
          {
            for (unsigned k = 0; k < n_position_type; k++)
            {
              // Assemble in-element quantities: boundary coordinate
              for (unsigned i = 0; i < dim_el; i++)
              {
                zeta[i] += this->zeta_nodal(j, k, i) * psi(j, k);
              }
            }
          }
        }

        if (this->Sparsify) zeta = this->Zeta_sub_geom_object[ipt];


        // Now find the local undeformed metric tensor from the tangent Vectors
        DenseMatrix<double> a(dim_el);
        for (unsigned i = 0; i < dim_el; i++)
        {
          for (unsigned j = 0; j < dim_el; j++)
          {
            // Initialise surface metric tensor to zero
            a(i, j) = 0.0;
            // Take the dot product
            for (unsigned k = 0; k < dim_el + 1; k++)
            {
              a(i, j) += interpolated_a(i, k) * interpolated_a(j, k);
            }
          }
        }


        // Find the determinant of the metric tensor
        double adet = 0.0;
        switch (dim_el + 1)
        {
          case 2:
            adet = a(0, 0);
            break;

          case 3:
            adet = a(0, 0) * a(1, 1) - a(0, 1) * a(1, 0);
            break;

          default:
            throw OomphLibError(
              "Wrong dimension "
              "refineable_fill_in_generic_contribution_to_residuals_displ_lagr_"
              "multiplier",
              "RefineableImposeDisplacementByLagrangeMultiplierElement::"
              "refineablefill_in_generic_contribution_to_residuals_displ_lagr_"
              "multiplier()",
              OOMPH_EXCEPTION_LOCATION);
        }

        // Get prescribed wall shape
        Vector<double> r_prescribed(dim_el + 1);
        if (!this->Sparsify)
        {
          this->Boundary_shape_geom_object_pt->position(zeta, r_prescribed);
        }
        else
        {
          this->Sub_geom_object_pt[ipt]->position(zeta, r_prescribed);
        }

        // Premultiply the weights and the square-root of the determinant of
        // the metric tensor
        double W = w * sqrt(adet);

        // Assemble residuals and jacobian


        // Number of master nodes and storage for the weight of the shape
        // function
        unsigned n_master = 1;
        unsigned n_master2 = 1;
        double hang_weight = 1.0;
        double hang_weight2 = 1.0;

        // Pointer to hang info object
        HangInfo* hang_info_pt = 0;
        HangInfo* hang_info2_pt = 0;


        // Loop over nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          // Local node itself (hanging or not)
          Node* local_node_pt = this->node_pt(j);

          // Local boolean to indicate whether the node is hanging
          bool is_node_hanging = local_node_pt->is_hanging();

          // If the node is hanging
          if (is_node_hanging)
          {
            hang_info_pt = local_node_pt->hanging_pt();

            // Read out number of master nodes from hanging data
            n_master = hang_info_pt->nmaster();
          }
          // Otherwise the node is its own master
          else
          {
            n_master = 1;
          }

          // Loop over the master nodes
          for (unsigned m = 0; m < n_master; m++)
          {
            // Loop over velocity components for equations
            for (unsigned i = 0; i < dim_el + 1; i++)
            {
              // Get the equation number for Lagrange multiplier eqn

              // If the node is hanging
              if (is_node_hanging)
              {
                // Cast to a boundary node
                BoundaryNodeBase* bnod_pt = dynamic_cast<BoundaryNodeBase*>(
                  hang_info_pt->master_node_pt(m));

                // Get the equation number from the master node
                local_eqn = this->local_hang_eqn(
                  hang_info_pt->master_node_pt(m),
                  bnod_pt->index_of_first_value_assigned_by_face_element(
                    this->Id) +
                    i);

                // Get the hang weight from the master node
                hang_weight = hang_info_pt->master_weight(m);
              }
              // If the node is not hanging
              else
              {
                // Cast to a boundary node
                BoundaryNodeBase* bnod_pt =
                  dynamic_cast<BoundaryNodeBase*>(local_node_pt);

                // Local equation number
                local_eqn = this->nodal_local_eqn(
                  j,
                  bnod_pt->index_of_first_value_assigned_by_face_element(
                    this->Id) +
                    i);

                // Node contributes with full weight
                hang_weight = 1.0;
              }

              // If it's not a boundary condition...
              if (local_eqn >= 0)
              {
                residuals[local_eqn] +=
                  (x[i] - r_prescribed[i]) * psi(j) * W * hang_weight;

                // Do Jacobian too?
                if (flag == 1)
                {
                  // Loop over the nodes again for unknowns (only diagonal
                  // contribution to direction!).
                  for (unsigned jj = 0; jj < n_node; jj++)
                  {
                    // Local node itself (hanging or not)
                    Node* local_node2_pt = this->node_pt(jj);

                    // Local boolean to indicate whether the node is hanging
                    bool is_node_hanging2 = local_node2_pt->is_hanging();

                    // If the node is hanging
                    if (is_node_hanging2)
                    {
                      hang_info2_pt = local_node2_pt->hanging_pt();

                      // Read out number of master nodes from hanging data
                      n_master2 = hang_info2_pt->nmaster();
                    }
                    // Otherwise the node is its own master
                    else
                    {
                      n_master2 = 1;
                    }

                    // Loop over the master nodes
                    for (unsigned m2 = 0; m2 < n_master2; m2++)
                    {
                      // Storage for local equation numbers at node indexed by
                      // type and direction
                      DenseMatrix<int> position_local_eqn_at_node2(
                        n_position_type, dim_el + 1);

                      if (is_node_hanging2)
                      {
                        // Find the equation numbers
                        position_local_eqn_at_node2 = local_position_hang_eqn(
                          local_node2_pt->hanging_pt()->master_node_pt(m2));

                        // Find the hanging node weight
                        hang_weight2 =
                          local_node2_pt->hanging_pt()->master_weight(m2);
                      }
                      else
                      {
                        // Non-loop of types of dofs
                        // for(unsigned k2=0;k2<n_position_type;k2++)
                        // {
                        unsigned k2 = 0;

                        // Loop over the displacement components
                        // for(unsigned i2=0;i2<dim_el+1;i2++)
                        unsigned i2 =
                          i; // only need that one, but need to store
                             // information in this container because
                             // it's required for hanging case.
                        {
                          position_local_eqn_at_node2(k2, i2) =
                            this->position_local_eqn(jj, k2, i2);
                        }

                        // Hang weight is one
                        hang_weight2 = 1.0;
                      }

                      unsigned k2 = 0;
                      local_unknown = position_local_eqn_at_node2(k2, i);
                      if (local_unknown >= 0)
                      {
                        jacobian(local_eqn, local_unknown) +=
                          psi(jj) * psi(j) * W * hang_weight * hang_weight2;
                      }
                    }
                  }
                }


                // Add Lagrange multiplier contribution to bulk equations


                // Storage for local equation numbers at node indexed by
                // type and direction
                DenseMatrix<int> position_local_eqn_at_node(n_position_type,
                                                            dim_el + 1);

                if (is_node_hanging)
                {
                  // Find the equation numbers
                  position_local_eqn_at_node = local_position_hang_eqn(
                    local_node_pt->hanging_pt()->master_node_pt(m));
                }
                else
                {
                  // Non-loop of types of dofs
                  // for(unsigned k2=0;k2<n_position_type;k2++)
                  // {
                  unsigned k2 = 0;

                  // Loop over the displacement components
                  // for(unsigned i2=0;i2<dim_el+1;i2++)
                  unsigned i2 = i; // only need that one, but need to store
                                   // information in this container because
                                   // it's required for hanging case.
                  {
                    position_local_eqn_at_node(k2, i2) =
                      this->position_local_eqn(j, k2, i2);
                  }
                }
                unsigned k = 0;
                local_eqn = position_local_eqn_at_node(k, i);

                /*IF it's not a boundary condition*/
                if (local_eqn >= 0)
                {
                  // Add to residual
                  residuals[local_eqn] += lambda[i] * psi(j) * W * hang_weight;

                  // Do Jacobian too?
                  if (flag == 1)
                  {
                    // Loop over the nodes again for unknowns (only diagonal
                    // contribution to direction!).
                    for (unsigned jj = 0; jj < n_node; jj++)
                    {
                      // Local node itself (hanging or not)
                      Node* local_node2_pt = this->node_pt(jj);

                      // Local boolean to indicate whether the node is hanging
                      bool is_node_hanging2 = local_node2_pt->is_hanging();

                      // If the node is hanging
                      if (is_node_hanging2)
                      {
                        hang_info2_pt = local_node2_pt->hanging_pt();

                        // Read out number of master nodes from hanging data
                        n_master2 = hang_info2_pt->nmaster();
                      }
                      // Otherwise the node is its own master
                      else
                      {
                        n_master2 = 1;
                      }

                      // Loop over the master nodes
                      for (unsigned m2 = 0; m2 < n_master2; m2++)
                      {
                        // Get the equation number for Lagrange multiplier eqn

                        // If the node is hanging
                        if (is_node_hanging2)
                        {
                          // Cast to a boundary node
                          BoundaryNodeBase* bnod2_pt =
                            dynamic_cast<BoundaryNodeBase*>(
                              hang_info2_pt->master_node_pt(m2));

                          // Get the equation number from the master node
                          local_unknown = this->local_hang_eqn(
                            hang_info2_pt->master_node_pt(m2),
                            bnod2_pt
                                ->index_of_first_value_assigned_by_face_element(
                                  this->Id) +
                              i);

                          // Get the hang weight from the master node
                          hang_weight2 = hang_info2_pt->master_weight(m2);
                        }
                        // If the node is not hanging
                        else
                        {
                          // Cast to a boundary node
                          BoundaryNodeBase* bnod2_pt =
                            dynamic_cast<BoundaryNodeBase*>(local_node2_pt);

                          // Local equation number
                          local_unknown = this->nodal_local_eqn(
                            jj,
                            bnod2_pt
                                ->index_of_first_value_assigned_by_face_element(
                                  this->Id) +
                              i);

                          // Node contributes with full weight
                          hang_weight2 = 1.0;
                        }

                        if (local_unknown >= 0)
                        {
                          jacobian(local_eqn, local_unknown) +=
                            psi(jj) * psi(j) * W * hang_weight * hang_weight2;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      } // End of loop over the integration points
    }
  };


  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////


  //======================================================================
  /// A class for elements that allow the imposition of a displacement
  /// constraint for bulk solid elements via a Lagrange multiplier.
  /// Prescribed displaced is obtained from an adjacent bulk solid
  /// element (rather than from a lower-dimensional GeomObject
  /// as in the corresponding ImposeDisplacementByLagrangeMultiplierElement
  /// class. The present class is particularly suited for parallel
  /// FSI computations.
  /// \b NOTE: Currently (and for the foreseeable future) this
  /// element only works with bulk elements that do not have
  /// generalised degrees of freedom (so it won't work with
  /// Hermite-type elements, say). The additional functionality
  /// to deal with such elements could easily be added (once a
  /// a suitable test case is written). For now we simply throw
  /// errors if an attempt is made to use the element with an unsuitable
  /// bulk element.
  //======================================================================
  template<class ELEMENT>
  class FSIImposeDisplacementByLagrangeMultiplierElement
    : public virtual FaceGeometry<ELEMENT>,
      public virtual SolidFaceElement,
      public virtual ElementWithExternalElement
  {
  public:
    /// Function to describe the local dofs of the elements. The ostream
    /// specifies the output stream to which the description
    /// is written; the string stores the currently
    /// assembled output that is ultimately written to the
    /// output stream by Data::describe_dofs(...); it is typically
    /// built up incrementally as we descend through the
    /// call hierarchy of this function when called from
    /// Problem::describe_dofs(...)
    void describe_local_dofs(std::ostream& out,
                             const std::string& current_string) const
    {
      ElementWithExternalElement::describe_local_dofs(out, current_string);
      describe_nodal_local_dofs(out, current_string);
    }

    /// Constructor takes a "bulk" element and the
    /// index that identifies which face the FaceElement is supposed
    /// to be attached to. The optional identifier can be used
    /// to distinguish the additional nodal values created by
    /// this element from thos created by other FaceElements.
    FSIImposeDisplacementByLagrangeMultiplierElement(
      FiniteElement* const& element_pt,
      const int& face_index,
      const unsigned& id = 0,
      const bool& called_from_refineable_constructor = false)
      : FaceGeometry<ELEMENT>(), FaceElement(), ElementWithExternalElement()
    {
      // Set external element storage - one interaction
      this->set_ninteraction(1);

      //  Store the ID of the FaceElement -- this is used to distinguish
      // it from any others
      Id = id;

      // Build the face element
      element_pt->build_face_element(face_index, this);

#ifdef PARANOID
      {
        // Check that the bulk element is not a refineable 3d element
        if (!called_from_refineable_constructor)
        {
          if (element_pt->dim() == 3)
          {
            // Is it refineable
            RefineableElement* ref_el_pt =
              dynamic_cast<RefineableElement*>(element_pt);
            if (ref_el_pt != 0)
            {
              if (this->has_hanging_nodes())
              {
                throw OomphLibError(
                  "This face element will not work correctly if nodes are "
                  "hanging\nUse the refineable version instead. ",
                  OOMPH_CURRENT_FUNCTION,
                  OOMPH_EXCEPTION_LOCATION);
              }
            }
          }
        }
      }

      {
        // Check that the bulk element does not require generalised positional
        // degrees of freedom
        if (element_pt->nnodal_position_type() != 1)
        {
          throw OomphLibError("FSIImposeDisplacementByLagrangeMultiplierElement"
                              " cannot (currently) be used with elements that "
                              "have generalised positional dofs",
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
      }
#endif

      // Dimension of the bulk element
      unsigned dim = element_pt->dim();

      // We need dim additional values for each FaceElement node
      // to store the dim Lagrange multipliers.
      Vector<unsigned> n_additional_values(nnode(), dim);

      // Now add storage for Lagrange multipliers and set the map containing
      // the position of the first entry of this face element's
      // additional values.
      add_additional_values(n_additional_values, id);
    }


    /// Fill in the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic routine with the flag set to 0
      fill_in_generic_contribution_to_residuals_fsi_displ_lagr_multiplier(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      fill_in_generic_contribution_to_residuals_fsi_displ_lagr_multiplier(
        residuals, jacobian, 1);

      // Add the contribution of the external interaction by finite differences
      this->fill_in_jacobian_from_external_interaction_by_fd(jacobian);
    }

    /// Fill in contribution to Mass matrix and
    /// Jacobian. There is no contributiont to mass matrix
    /// so simply call the fill_in_contribution_to_jacobian term
    /// Note that the Jacobian is multiplied by minus one to
    /// ensure that the mass matrix is positive semi-definite.
    void fill_in_contribution_to_jacobian_and_mass_matrix(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix)
    {
      // Just call the jacobian calculation
      fill_in_contribution_to_jacobian(residuals, jacobian);

      // Multiply the residuals and jacobian by minus one
      const unsigned n_dof = this->ndof();
      for (unsigned i = 0; i < n_dof; i++)
      {
        residuals[i] *= -1.0;
        for (unsigned j = 0; j < n_dof; j++)
        {
          jacobian(i, j) *= -1.0;
        }
      }
    }


    /// Output function
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      // Elemental dimension
      unsigned dim_el = dim();

      // Find the number of positional types
      unsigned n_position_type = this->nnodal_position_type();

#ifdef PARANOID
      if (n_position_type != 1)
      {
        throw OomphLibError(
          "FSIImposeDisplacementByLagrangeMultiplierElement cannot (currently) "
          "be used with elements that have generalised positional dofs",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif


      // Local coord
      Vector<double> s(dim_el);

      // # of nodes,
      unsigned n_node = nnode();
      Shape psi(n_node, n_position_type);

      // Tecplot header info
      outfile << this->tecplot_zone_string(n_plot);

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points(n_plot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, n_plot, s);

        // Get shape function
        shape(s, psi);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        for (unsigned j = 0; j < n_node; j++)
        {
          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // get the node pt
          Node* nod_pt = node_pt(j);

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(Id);

          // higher dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += nodal_position(j, i) * psi(j, 0); // need to sort
                                                      // this out properly
                                                      // for generalised dofs
            lambda[i] += nod_pt->value(first_index + i) * psi(j, 0);
          }
          // In-element quantities
          for (unsigned i = 0; i < dim_el; i++)
          {
            // Loop over positional types
            for (unsigned k = 0; k < n_position_type; k++)
            {
              zeta[i] += zeta_nodal(j, k, i) * psi(j, k);
            }
          }
        }

        // Output stuff
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          outfile << x[i] << " ";
        }
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          outfile << -lambda[i] << " ";
        }
        outfile << std::endl;
      }
    }


    /// Output function
    void output(std::ostream& outfile)
    {
      unsigned n_plot = 5;
      output(outfile, n_plot);
    }


  protected:
    /// Helper function to compute the residuals and, if flag==1, the
    /// Jacobian
    void fill_in_generic_contribution_to_residuals_fsi_displ_lagr_multiplier(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag)
    {
#ifdef PARANOID
      // Find out how many positional dofs there are
      unsigned n_position_type = this->nnodal_position_type();

      if (n_position_type != 1)
      {
        throw OomphLibError(
          "FSIImposeDisplacementByLagrangeMultiplierElement cannot (currently) "
          "be used with elements that have generalised positional dofs",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Find out how many nodes there are
      unsigned n_node = nnode();

      // Dimension of element
      unsigned dim_el = dim();

      // Set up memory for the shape functions
      Shape psi(n_node);
      DShape dpsids(n_node, dim_el);

      // Set the value of n_intpt
      unsigned n_intpt = integral_pt()->nweight();

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Get the integral weight
        double w = integral_pt()->weight(ipt);

        // Only need to call the local derivatives
        dshape_local_at_knot(ipt, psi, dpsids);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        DenseMatrix<double> interpolated_a(dim_el, dim_el + 1, 0.0);

        // Loop over nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          Node* nod_pt = node_pt(j);

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(Id);

          // Assemble higher-dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += nodal_position(j, i) * psi(j);
            lambda[i] += nod_pt->value(first_index + i) * psi(j);
            for (unsigned ii = 0; ii < dim_el; ii++)
            {
              interpolated_a(ii, i) +=
                lagrangian_position(j, i) * dpsids(j, ii);
            }
          }
        }

        // Now find the local undeformed metric tensor from the tangent Vectors
        DenseMatrix<double> a(dim_el);
        for (unsigned i = 0; i < dim_el; i++)
        {
          for (unsigned j = 0; j < dim_el; j++)
          {
            // Initialise surface metric tensor to zero
            a(i, j) = 0.0;
            // Take the dot product
            for (unsigned k = 0; k < dim_el + 1; k++)
            {
              a(i, j) += interpolated_a(i, k) * interpolated_a(j, k);
            }
          }
        }


        // Find the determinant of the metric tensor
        double adet = 0.0;
        switch (dim_el + 1)
        {
          case 2:
            adet = a(0, 0);
            break;

          case 3:
            adet = a(0, 0) * a(1, 1) - a(0, 1) * a(1, 0);
            break;

          default:
            throw OomphLibError(
              "Wrong dimension "
              "fill_in_generic_contribution_to_residuals_displ_lagr_multiplier",
              "FSIImposeDisplacementByLagrangeMultiplierElement::fill_in_"
              "generic_contribution_to_residuals_fsi_displ_lagr_multiplier()",
              OOMPH_EXCEPTION_LOCATION);
        }

        // Get prescribed wall shape from adjacent bulk element
        Vector<double> r_prescribed(dim_el + 1);

        // Get the local coordinate in the solid element (copy
        // operation for Vector)
        Vector<double> s_adjacent(external_element_local_coord(0, ipt));

        // Get the position in the adjacent element
        FiniteElement* bulk_el_pt = external_element_pt(0, ipt);
        bulk_el_pt->interpolated_x(s_adjacent, r_prescribed);

        // Premultiply the weights and the square-root of the determinant of
        // the metric tensor
        double W = w * sqrt(adet);

        // Assemble residuals and jacobian

        // Loop over directions
        for (unsigned i = 0; i < dim_el + 1; i++)
        {
          // Loop over the nodes
          for (unsigned j = 0; j < n_node; j++)
          {
            // Assemble residual for Lagrange multiplier:

            // Cast to a boundary node
            BoundaryNodeBase* bnod_pt =
              dynamic_cast<BoundaryNodeBase*>(node_pt(j));

            // Local eqn number:
            int local_eqn = nodal_local_eqn(
              j,
              bnod_pt->index_of_first_value_assigned_by_face_element(Id) + i);


            if (local_eqn >= 0)
            {
              residuals[local_eqn] += (x[i] - r_prescribed[i]) * psi(j) * W;

              // Do Jacobian too?
              if (flag == 1)
              {
                // Loop over the nodes again for unknowns (only diagonal
                // contribution to direction!).
                for (unsigned jj = 0; jj < n_node; jj++)
                {
                  int local_unknown = position_local_eqn(jj, 0, i);
                  if (local_unknown >= 0)
                  {
                    jacobian(local_eqn, local_unknown) += psi(jj) * psi(j) * W;
                  }
                }
              }
            }


            // Add Lagrange multiplier contribution to bulk equations

            // Local eqn number: Node, type, direction
            local_eqn = position_local_eqn(j, 0, i);
            if (local_eqn >= 0)
            {
              // Add to residual
              residuals[local_eqn] += lambda[i] * psi(j) * W;

              // Do Jacobian too?
              if (flag == 1)
              {
                // Loop over the nodes again for unknowns (only diagonal
                // contribution to direction!).
                for (unsigned jj = 0; jj < n_node; jj++)
                {
                  // Cast to a boundary node
                  BoundaryNodeBase* bnode_pt =
                    dynamic_cast<BoundaryNodeBase*>(node_pt(jj));

                  int local_unknown = nodal_local_eqn(
                    jj,
                    bnode_pt->index_of_first_value_assigned_by_face_element(
                      Id) +
                      i);
                  if (local_unknown >= 0)
                  {
                    jacobian(local_eqn, local_unknown) += psi(jj) * psi(j) * W;
                  }
                }
              }
            }
          }
        }


      } // End of loop over the integration points
    }


    /// The number of "DOF types" that degrees of freedom in this element
    /// are sub-divided into: Just the solid degrees of freedom themselves.
    unsigned ndof_types() const
    {
      return this->dim() + 1;
    };


    /// Create a list of pairs for all unknowns in this element,
    /// so that the first entry in each pair contains the global equation
    /// number of the unknown, while the second one contains the number
    /// of the dof that this unknown is associated with.
    /// (Function can obviously only be called if the equation numbering
    /// scheme has been set up.)
    void get_dof_numbers_for_unknowns(
      std::list<std::pair<unsigned long, unsigned>>& dof_lookup_list) const
    {
      // temporary pair (used to store dof lookup prior to being added to list)
      std::pair<unsigned, unsigned> dof_lookup;

      // number of nodes
      const unsigned n_node = this->nnode();

      // Loop over directions
      unsigned dim_el = this->dim();
      for (unsigned i = 0; i < dim_el + 1; i++)
      {
        // Loop over the nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt =
            dynamic_cast<BoundaryNodeBase*>(node_pt(j));

          // Local eqn number:
          int local_eqn = nodal_local_eqn(
            j, bnod_pt->index_of_first_value_assigned_by_face_element(Id) + i);
          if (local_eqn >= 0)
          {
            // store dof lookup in temporary pair: First entry in pair
            // is global equation number; second entry is dof type
            dof_lookup.first = this->eqn_number(local_eqn);
            dof_lookup.second = i;

            // add to list
            dof_lookup_list.push_front(dof_lookup);
          }
        }
      }
    }

    /// Lagrange Id
    unsigned Id;
  };


  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////


  //======================================================================
  /// A class for elements that allow the imposition of a displacement
  /// constraint for bulk solid elements via a Lagrange multiplier.
  /// Prescribed displaced is obtained from an adjacent bulk solid
  /// element (rather than from a lower-dimensional GeomObject
  /// as in the corresponding ImposeDisplacementByLagrangeMultiplierElement
  /// class. The present class is particularly suited for parallel
  /// FSI computations.
  /// \b NOTE: Currently (and for the foreseeable future) this
  /// element only works with bulk elements that do not have
  /// generalised degrees of freedom (so it won't work with
  /// Hermite-type elements, say). The additional functionality
  /// to deal with such elements could easily be added (once a
  /// a suitable test case is written). For now we simply throw
  /// errors if an attempt is made to use the element with an unsuitable
  /// bulk element.
  ///
  /// REFINEABLE VERSION
  //======================================================================
  template<class ELEMENT>
  class RefineableFSIImposeDisplacementByLagrangeMultiplierElement
    : public virtual FSIImposeDisplacementByLagrangeMultiplierElement<ELEMENT>,
      public virtual NonRefineableSolidElementWithHangingNodes

  {
  public:
    /// Function to describe the local dofs of the element. The ostream
    /// specifies the output stream to which the description
    /// is written; the string stores the currently
    /// assembled output that is ultimately written to the
    /// output stream by Data::describe_dofs(...); it is typically
    /// built up incrementally as we descend through the
    /// call hierarchy of this function when called from
    /// Problem::describe_dofs(...)
    using FSIImposeDisplacementByLagrangeMultiplierElement<
      ELEMENT>::describe_local_dofs;

    /// Constructor takes a "bulk" element and the
    /// index that identifies which face the FaceElement is supposed
    /// to be attached to. The optional identifier can be used
    /// to distinguish the additional nodal values created by
    /// this element from thos created by other FaceElements.
    RefineableFSIImposeDisplacementByLagrangeMultiplierElement(
      FiniteElement* const& element_pt,
      const int& face_index,
      const unsigned& id = 0)
      : FSIImposeDisplacementByLagrangeMultiplierElement<ELEMENT>(
          element_pt, face_index, id, true)
    {
    }


    /// Number of continuously interpolated values: Same for
    /// all nodes since it's a refineable element
    unsigned ncont_interpolated_values() const
    {
      return node_pt(0)->nvalue();
    }

    /// Fill in the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic routine with the flag set to 0
      refineable_fill_in_generic_contribution_to_residuals_fsi_displ_lagr_multiplier(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      refineable_fill_in_generic_contribution_to_residuals_fsi_displ_lagr_multiplier(
        residuals, jacobian, 1);

      // Add the contribution of the external interaction by finite differences
      this->fill_in_jacobian_from_external_interaction_by_fd(jacobian);
    }


  protected:
    /// Helper function to compute the residuals and, if flag==1, the
    /// Jacobian
    void refineable_fill_in_generic_contribution_to_residuals_fsi_displ_lagr_multiplier(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag)
    {
      // Find out how many positional dofs there are
      unsigned n_position_type = this->nnodal_position_type();

#ifdef PARANOID
      if (n_position_type != 1)
      {
        throw OomphLibError(
          "RefineableImposeDisplacementByLagrangeMultiplierElement \n cannot "
          "(currently) be used with elements that have generalised\n "
          "positional dofs. Upgrade should be straightforward though the code "
          "is in a \n bit of state, with generalised degrees of freedom "
          "sometimes half taken into \n account, sometimes completely "
          "ignored...",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
      }
#endif

      // Find out how many nodes there are
      unsigned n_node = this->nnode();

      // Dimension of element
      unsigned dim_el = this->dim();

      // Set up memory for the shape functions
      Shape psi(n_node);
      DShape dpsids(n_node, dim_el);

      // Set the value of n_intpt
      unsigned n_intpt = this->integral_pt()->nweight();


      // Integers to store local equation number
      int local_eqn = 0;
      int local_unknown = 0;

      // Loop over the integration points
      for (unsigned ipt = 0; ipt < n_intpt; ipt++)
      {
        // Get the integral weight
        double w = this->integral_pt()->weight(ipt);

        // Only need to call the local derivatives
        this->dshape_local_at_knot(ipt, psi, dpsids);

        // Calculate the Eulerian coordinates and Lagrange multiplier
        Vector<double> x(dim_el + 1, 0.0);
        Vector<double> lambda(dim_el + 1, 0.0);
        Vector<double> zeta(dim_el, 0.0);
        DenseMatrix<double> interpolated_a(dim_el, dim_el + 1, 0.0);

        // Loop over nodes -- note in these calculations hang-ness is
        // automatically taken into account because of calls to position(...)
        // etc
        for (unsigned j = 0; j < n_node; j++)
        {
          Node* nod_pt = this->node_pt(j);

          // Cast to a boundary node
          BoundaryNodeBase* bnod_pt = dynamic_cast<BoundaryNodeBase*>(nod_pt);

          // Get the index of the first nodal value associated with
          // this FaceElement
          unsigned first_index =
            bnod_pt->index_of_first_value_assigned_by_face_element(this->Id);

          // Assemble higher-dimensional quantities
          for (unsigned i = 0; i < dim_el + 1; i++)
          {
            x[i] += this->nodal_position(j, i) * psi(j);
            lambda[i] += nod_pt->value(first_index + i) * psi(j);
            for (unsigned ii = 0; ii < dim_el; ii++)
            {
              interpolated_a(ii, i) +=
                this->lagrangian_position(j, i) * dpsids(j, ii);
            }
          }
        }


        // Now find the local undeformed metric tensor from the tangent Vectors
        DenseMatrix<double> a(dim_el);
        for (unsigned i = 0; i < dim_el; i++)
        {
          for (unsigned j = 0; j < dim_el; j++)
          {
            // Initialise surface metric tensor to zero
            a(i, j) = 0.0;
            // Take the dot product
            for (unsigned k = 0; k < dim_el + 1; k++)
            {
              a(i, j) += interpolated_a(i, k) * interpolated_a(j, k);
            }
          }
        }


        // Find the determinant of the metric tensor
        double adet = 0.0;
        switch (dim_el + 1)
        {
          case 2:
            adet = a(0, 0);
            break;

          case 3:
            adet = a(0, 0) * a(1, 1) - a(0, 1) * a(1, 0);
            break;

          default:
            throw OomphLibError(
              "Wrong dimension "
              "refineable_fill_in_generic_contribution_to_residuals_displ_lagr_"
              "multiplier",
              "RefineableImposeDisplacementByLagrangeMultiplierElement::"
              "refineablefill_in_generic_contribution_to_residuals_displ_lagr_"
              "multiplier()",
              OOMPH_EXCEPTION_LOCATION);
        }

        // Get prescribed wall shape from adjacent bulk element
        Vector<double> r_prescribed(dim_el + 1);

        // Get the local coordinate in the solid element (copy
        // operation for Vector)
        Vector<double> s_adjacent(this->external_element_local_coord(0, ipt));

        // Get the position in the adjacent element
        FiniteElement* bulk_el_pt = this->external_element_pt(0, ipt);
        bulk_el_pt->interpolated_x(s_adjacent, r_prescribed);


        // Premultiply the weights and the square-root of the determinant of
        // the metric tensor
        double W = w * sqrt(adet);

        // Assemble residuals and jacobian


        // Number of master nodes and storage for the weight of the shape
        // function
        unsigned n_master = 1;
        unsigned n_master2 = 1;
        double hang_weight = 1.0;
        double hang_weight2 = 1.0;

        // Pointer to hang info object
        HangInfo* hang_info_pt = 0;
        HangInfo* hang_info2_pt = 0;


        // Loop over nodes
        for (unsigned j = 0; j < n_node; j++)
        {
          // Local node itself (hanging or not)
          Node* local_node_pt = this->node_pt(j);

          // Local boolean to indicate whether the node is hanging
          bool is_node_hanging = local_node_pt->is_hanging();

          // If the node is hanging
          if (is_node_hanging)
          {
            hang_info_pt = local_node_pt->hanging_pt();

            // Read out number of master nodes from hanging data
            n_master = hang_info_pt->nmaster();
          }
          // Otherwise the node is its own master
          else
          {
            n_master = 1;
          }

          // Loop over the master nodes
          for (unsigned m = 0; m < n_master; m++)
          {
            // Loop over velocity components for equations
            for (unsigned i = 0; i < dim_el + 1; i++)
            {
              // Get the equation number for Lagrange multiplier eqn

              // If the node is hanging
              if (is_node_hanging)
              {
                // Cast to a boundary node
                BoundaryNodeBase* bnod_pt = dynamic_cast<BoundaryNodeBase*>(
                  hang_info_pt->master_node_pt(m));

                // Get the equation number from the master node
                local_eqn = this->local_hang_eqn(
                  hang_info_pt->master_node_pt(m),
                  bnod_pt->index_of_first_value_assigned_by_face_element(
                    this->Id) +
                    i);

                // Get the hang weight from the master node
                hang_weight = hang_info_pt->master_weight(m);
              }
              // If the node is not hanging
              else
              {
                // Cast to a boundary node
                BoundaryNodeBase* bnod_pt =
                  dynamic_cast<BoundaryNodeBase*>(local_node_pt);

                // Local equation number
                local_eqn = this->nodal_local_eqn(
                  j,
                  bnod_pt->index_of_first_value_assigned_by_face_element(
                    this->Id) +
                    i);

                // Node contributes with full weight
                hang_weight = 1.0;
              }

              // If it's not a boundary condition...
              if (local_eqn >= 0)
              {
                residuals[local_eqn] +=
                  (x[i] - r_prescribed[i]) * psi(j) * W * hang_weight;

                // Do Jacobian too?
                if (flag == 1)
                {
                  // Loop over the nodes again for unknowns (only diagonal
                  // contribution to direction!).
                  for (unsigned jj = 0; jj < n_node; jj++)
                  {
                    // Local node itself (hanging or not)
                    Node* local_node2_pt = this->node_pt(jj);

                    // Local boolean to indicate whether the node is hanging
                    bool is_node_hanging2 = local_node2_pt->is_hanging();

                    // If the node is hanging
                    if (is_node_hanging2)
                    {
                      hang_info2_pt = local_node2_pt->hanging_pt();

                      // Read out number of master nodes from hanging data
                      n_master2 = hang_info2_pt->nmaster();
                    }
                    // Otherwise the node is its own master
                    else
                    {
                      n_master2 = 1;
                    }

                    // Loop over the master nodes
                    for (unsigned m2 = 0; m2 < n_master2; m2++)
                    {
                      // Storage for local equation numbers at node indexed by
                      // type and direction
                      DenseMatrix<int> position_local_eqn_at_node2(
                        n_position_type, dim_el + 1);

                      if (is_node_hanging2)
                      {
                        // Find the equation numbers
                        position_local_eqn_at_node2 = local_position_hang_eqn(
                          local_node2_pt->hanging_pt()->master_node_pt(m2));

                        // Find the hanging node weight
                        hang_weight2 =
                          local_node2_pt->hanging_pt()->master_weight(m2);
                      }
                      else
                      {
                        // Non-loop of types of dofs
                        // for(unsigned k2=0;k2<n_position_type;k2++)
                        // {
                        unsigned k2 = 0;

                        // Loop over the displacement components
                        // for(unsigned i2=0;i2<dim_el+1;i2++)
                        unsigned i2 =
                          i; // only need that one, but need to store
                             // information in this container because
                             // it's required for hanging case.
                        {
                          position_local_eqn_at_node2(k2, i2) =
                            this->position_local_eqn(jj, k2, i2);
                        }

                        // Hang weight is one
                        hang_weight2 = 1.0;
                      }

                      unsigned k2 = 0;
                      local_unknown = position_local_eqn_at_node2(k2, i);
                      if (local_unknown >= 0)
                      {
                        jacobian(local_eqn, local_unknown) +=
                          psi(jj) * psi(j) * W * hang_weight * hang_weight2;
                      }
                    }
                  }
                }


                // Add Lagrange multiplier contribution to bulk equations


                // Storage for local equation numbers at node indexed by
                // type and direction
                DenseMatrix<int> position_local_eqn_at_node(n_position_type,
                                                            dim_el + 1);

                if (is_node_hanging)
                {
                  // Find the equation numbers
                  position_local_eqn_at_node = local_position_hang_eqn(
                    local_node_pt->hanging_pt()->master_node_pt(m));
                }
                else
                {
                  // Non-loop of types of dofs
                  // for(unsigned k2=0;k2<n_position_type;k2++)
                  // {
                  unsigned k2 = 0;

                  // Loop over the displacement components
                  // for(unsigned i2=0;i2<dim_el+1;i2++)
                  unsigned i2 = i; // only need that one, but need to store
                                   // information in this container because
                                   // it's required for hanging case.
                  {
                    position_local_eqn_at_node(k2, i2) =
                      this->position_local_eqn(j, k2, i2);
                  }
                }
                unsigned k = 0;
                local_eqn = position_local_eqn_at_node(k, i);

                /*IF it's not a boundary condition*/
                if (local_eqn >= 0)
                {
                  // Add to residual
                  residuals[local_eqn] += lambda[i] * psi(j) * W * hang_weight;

                  // Do Jacobian too?
                  if (flag == 1)
                  {
                    // Loop over the nodes again for unknowns (only diagonal
                    // contribution to direction!).
                    for (unsigned jj = 0; jj < n_node; jj++)
                    {
                      // Local node itself (hanging or not)
                      Node* local_node2_pt = this->node_pt(jj);

                      // Local boolean to indicate whether the node is hanging
                      bool is_node_hanging2 = local_node2_pt->is_hanging();

                      // If the node is hanging
                      if (is_node_hanging2)
                      {
                        hang_info2_pt = local_node2_pt->hanging_pt();

                        // Read out number of master nodes from hanging data
                        n_master2 = hang_info2_pt->nmaster();
                      }
                      // Otherwise the node is its own master
                      else
                      {
                        n_master2 = 1;
                      }

                      // Loop over the master nodes
                      for (unsigned m2 = 0; m2 < n_master2; m2++)
                      {
                        // Get the equation number for Lagrange multiplier eqn

                        // If the node is hanging
                        if (is_node_hanging2)
                        {
                          // Cast to a boundary node
                          BoundaryNodeBase* bnod2_pt =
                            dynamic_cast<BoundaryNodeBase*>(
                              hang_info2_pt->master_node_pt(m2));

                          // Get the equation number from the master node
                          local_unknown = this->local_hang_eqn(
                            hang_info2_pt->master_node_pt(m2),
                            bnod2_pt
                                ->index_of_first_value_assigned_by_face_element(
                                  this->Id) +
                              i);

                          // Get the hang weight from the master node
                          hang_weight2 = hang_info2_pt->master_weight(m2);
                        }
                        // If the node is not hanging
                        else
                        {
                          // Cast to a boundary node
                          BoundaryNodeBase* bnod2_pt =
                            dynamic_cast<BoundaryNodeBase*>(local_node2_pt);

                          // Local equation number
                          local_unknown = this->nodal_local_eqn(
                            jj,
                            bnod2_pt
                                ->index_of_first_value_assigned_by_face_element(
                                  this->Id) +
                              i);

                          // Node contributes with full weight
                          hang_weight2 = 1.0;
                        }

                        if (local_unknown >= 0)
                        {
                          jacobian(local_eqn, local_unknown) +=
                            psi(jj) * psi(j) * W * hang_weight * hang_weight2;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      } // End of loop over the integration points
    }
  };


  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////////


} // namespace oomph

#endif
